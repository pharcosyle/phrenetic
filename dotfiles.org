#+TITLE: Dotfiles
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args:elisp :lexical t

* Meta
#+begin_src elisp :tangle meta.el
(require 'dash)

(setq base-tangle-dir ".")

(defun get-tangle-dir ()
  (concat base-tangle-dir
          (when-let ((dirs (org-entry-get (point) "tangle-dir" 'inherit)))
            (-> dirs (split-string " /") (string-join "/")))))

(defun in-tangle-dir (sub-path)
  (concat (get-tangle-dir) "/" sub-path))
#+end_src
* Common
#+name: user-name
#+begin_src org
pharcosyle
#+end_src
#+name: user-full-name
#+begin_src org
Krzysztof Baranowski
#+end_src
#+name: user-email
#+begin_src org
pharcosyle@gmail.com
#+end_src
#+name: palette
| Name              | Color   |
|-------------------+---------|
| fg                | #dee2f8 |
| highlight         | #8496ff |
| comments          | #63677f |
| comment-delimiter | #939abd |
| red               | #fb8578 |
| orange            | #fdce5f |
| green             | #9fed9c |
| yellow            | #eddc91 |
| blue              | #7db9fe |
| dark-blue         | #5f68de |
| magenta           | #e29bf7 |
| violet            | #aeb9f3 |
| cyan              | #75e0f9 |
| gold              | #fdd94a |
| pink              | #ff9999 |

* Installation
** Create bootable USB
Download (or create) a Guix installation ISO
- I'm using the [[https://github.com/SystemCrafters/guix-installer/releases/latest][System Crafters Guix Installer]] since it's kept up-to-date which should speed things up a bit.
- Run ~lsblk~ to find the usb device.
#+begin_src sh
iso_file=guix-system-install-1.3.0.x86_64-linux.iso
usb_device=/dev/sdc
dd if=$iso_file of=$usb_device status=progress bs=4M
sync
#+end_src
** Install
Boot from the installation medium, select your language and country, and select "Install using the shell based process" when prompted.
*** Keyboard layout
This messed up the keyboard when I tried it on mac, not doing ~loadkeys~ at all was fine.
#+begin_src sh
# keysfile=mac-us
# loadkeys $keysfile
#+end_src
*** Networking
#+begin_src sh
# List network interfaces and find one to use.
ifconfig -a

# Is this necessary if the interface is already activated?
interface=usb0
ifconfig $interface up

dhclient -v $interface

# Test that networking is up and working.
ping -c 3 gnu.org
#+end_src
*** Partitioning
#+begin_src sh
# Check out the current block devices and partitions if you want.
lsblk

device=/dev/sda

# Make two partitions, partition types should be "EFI system partition" and "Linux x86-64 root (/)". For EFI I'm gonna do 1GB to be on the safe side, second should be remainder of free space.
cfdisk $device
parted $device set 1 esp on

efi_system_partition="$device"1
efi_label=genesis

mkfs.fat -F32 -n $efi_label $efi_system_partition

root_partition="$device"2
root_label=firmament
crypt_name=ciphered
crypt_mapping=/dev/mapper/$crypt_name

cryptsetup luksFormat $root_partition
cryptsetup open --type luks $root_partition $crypt_name

mkfs.btrfs -L $root_label $crypt_mapping
#+end_src
*** Set up subvolumes
#+begin_src sh
# I don't know if the type argument is necessary but that's how Andrew Tropin had it.
mount -t btrfs LABEL=$root_label /mnt

btrfs subvolume create /mnt/root
btrfs subvolume create /mnt/boot
btrfs subvolume create /mnt/guix-store
btrfs subvolume create /mnt/guix-var
btrfs subvolume create /mnt/log
btrfs subvolume create /mnt/home
btrfs subvolume create /mnt/persist
btrfs subvolume create /mnt/nix

# Take an empty readonly snapshot of the root subvolume (might be useful later for rolling back or comparison)
btrfs subvolume snapshot -r /mnt/root /mnt/root-blank

umount /mnt
#+end_src
*** Mount
NB: ~$crypt_mapping~ can/"should" be ~LABEL=$root_label~
#+begin_src sh
mount -o subvol=root,compress=zstd,autodefrag $crypt_mapping /mnt

mkdir /mnt/boot
mount -o subvol=boot,compress=zstd,autodefrag $crypt_mapping /mnt/boot
mkdir -p /mnt/gnu/store
mount -o subvol=guix-store,compress=zstd,autodefrag,noatime $crypt_mapping /mnt/gnu/store
mkdir -p /mnt/var/guix
mount -o subvol=guix-var,compress=zstd,autodefrag $crypt_mapping /mnt/var/guix
mkdir -p /mnt/var/log
mount -o subvol=log,compress=zstd,autodefrag $crypt_mapping /mnt/var/log
mkdir /mnt/home
mount -o subvol=home,compress=zstd,autodefrag $crypt_mapping /mnt/home
mkdir /mnt/.persist
mount -o subvol=persist,compress=zstd,autodefrag $crypt_mapping /mnt/.persist

mkdir -p /mnt/boot/efi
mount LABEL=$efi_label /mnt/boot/efi
#+end_src
*** Proceeding with installation
#+begin_src sh
herd start cow-store /mnt
#+end_src
*** System configuration
#+begin_src sh
# Grab my dotfiles, from github if I put them up at some point or maybe from a USB or another computer with `woof`, into the current directory (the one I'm already in, not `/mnt`).
# git clone https://github.com/pharcosyle/dotfiles
# guix environment --ad-hoc woof -- woof -U
# Important: `woof` didn't work for me over the local network, I had to have my other computer offer it over the public internet with localtunnel.

mkdir -p ~/.config/guix
cp ~/projects/dotfiles/ebullient/home/channels.scm ~/.config/guix
guix pull
hash guix

# Find the LUKS UUID to update it in the system config. Make sure to update in the dotfiles upstream later.
cryptsetup luksUUID $root_partition

cd ~/projects/dotfiles/ebullient
guix system --load-path=. init system/frostfire.scm /mnt
#+end_src
*** Post-installation
#+begin_src sh
# Reboot the system, take out the installation medium, and login as root when faced with a login prompt.

# Set the password for the root account.
passwd
# Set the password for my user.
my_user=pharcosyle
passwd $my_user

# Log out and log in to my user account.

# Grab my dotfiles again.

# Ensure my channels file is in `~/.config/guix` and update my channels.
guix pull

# Run a system reconfigure, home reconfigure, install manifests, and deploy `home-state.git`. Copy over all my old data.
#+end_src
* System
:PROPERTIES:
:tangle-dir+: /ebullient/system
:END:
** Components
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "components.scm")
:END:
#+begin_src scheme
(define-module (ebullient system components)
  #:use-module (guix build-system trivial)
  #:use-module ((guix modules) #:select (source-module-closure))
  #:use-module (guix gexp)
  #:use-module ((guix store) #:select (%default-substitute-urls))
  #:use-module (gnu bootloader)
  #:use-module (gnu bootloader grub)
  #:use-module ((gnu packages) #:select (specification->package))
  #:use-module ((gnu packages fonts) #:select (font-terminus))
  #:use-module ((gnu packages gnupg) #:select (guile-gcrypt))
  #:use-module ((gnu packages linux) #:select (brightnessctl pipewire-0.3))
  #:use-module ((gnu packages wm) #:select (sway swaylock))
  #:use-module (gnu services)
  #:use-module (gnu services base)
  #:use-module (gnu services desktop)
  #:use-module (gnu services nix)
  #:use-module (gnu services sound)
  #:use-module (gnu services xorg)
  #:use-module (gnu system)
  #:use-module (gnu system accounts)
  #:use-module (gnu system file-systems)
  #:use-module (gnu system keyboard)
  #:use-module (gnu system mapped-devices)
  #:use-module ((nongnu packages linux) #:select (linux linux-firmware broadcom-sta broadcom-bt-firmware))
  #:use-module ((nongnu system linux-initrd) #:select (microcode-initrd))
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:use-module ((ice-9 rdelim) #:select (read-string))
  #:use-module ((srfi srfi-1) #:select (any remove iota))
  #:use-module (ebullient utils)
  #:export (barebones-os
            basics
            boot
            initial-services
            linux-nonfree
            disk-encryption
            stateless
            btrfs
            users
            gdm
            nix
            hidpi-console-font
            nonguix-substitutes
            macbook
            macbook-kbl
            wm
            sway-wm
            miscellany))
#+end_src
#+begin_src scheme
(define-syntax-rule (system-comp os field ...)
  (operating-system
    (inherit os)
    field ...))

(define-syntax define-system-comp
  (lambda (x)
    (syntax-case x ()
      ((_ (name arg ...) field ...)
       (with-syntax ((os (datum->syntax x 'os)))
         #'(define* (name os arg ...)
             (system-comp os field ...)))))))

(define (update-services services kind update-fn)
  (update-services*
   services
   (lambda (svc)
     (eq? (service-kind svc) kind))
   update-fn))
#+end_src
*** Barebones OS
#+begin_src scheme
(define barebones-os
  (operating-system
    (host-name #f)
    (timezone #f)
    (bootloader #f)
    (services '())
    (file-systems %base-file-systems)))
#+end_src
*** Basics
Other components may inherit ~keyboard-value~ so use this component early. At the time of this writing, nothing depends on the values of hostname, etc but I could see them being useful base values to have present early.
#+begin_src scheme
(define-system-comp (basics #:key host-name timezone locale keyboard-layout)
  (host-name host-name)
  (timezone timezone)
  (locale locale)
  (keyboard-layout keyboard-layout))
#+end_src
*** EFI Boot
#+begin_src scheme
(define-system-comp (boot #:key label target)
  (bootloader (bootloader-configuration
               (bootloader grub-efi-bootloader)
               (targets (list target))
               (timeout 1)
               (keyboard-layout (operating-system-keyboard-layout os))))
  (file-systems
   (cons* (file-system
            (device (file-system-label label))
            (mount-point target)
            (type "vfat"))
          (operating-system-file-systems os))))
#+end_src
*** Initial services
Other components may wish to modify the list of operating system services so use this in the component chain early.
#+begin_src scheme
(define (selective-desktop-services pipewire?)
  (remove (lambda (service)
            (member (service-kind service)
                    (append (list gdm-service-type
                                  screen-locker-service-type)
                            (if pipewire?
                                (list pulseaudio-service-type
                                      alsa-service-type)
                                '()))))
          %desktop-services))

(define-system-comp (initial-services #:key desktop? pipewire?)
  (services
   (append (if desktop?
               (selective-desktop-services pipewire?)
               %base-services)
           (operating-system-user-services os))))
#+end_src
*** Linux nonfree
#+begin_src scheme
(define-system-comp (linux-nonfree)
  (kernel linux)
  (initrd microcode-initrd)
  (firmware (cons* linux-firmware
                   (operating-system-firmware os))))
#+end_src
*** Disk encryption
#+begin_src scheme
(define* (disk-encryption os #:key source-uuid target encrypted-mount-points)
  (let ((encrypted-device (mapped-device
                           (source (uuid source-uuid))
                           (targets (list target))
                           (type luks-device-mapping))))
    (system-comp
     os
     (mapped-devices
      (cons* encrypted-device
             (operating-system-mapped-devices os)))
     (file-systems
      (map (lambda (fs)
             (if (member (file-system-mount-point fs) encrypted-mount-points)
                 (file-system
                   (inherit fs)
                   (dependencies (cons* encrypted-device
                                        (file-system-dependencies fs))))
                 fs))
           (operating-system-file-systems os))))))
#+end_src
*** Stateless
The stateless service should come after base/desktop services (potentially others as well) so its state gets installed before theirs during activation. To this end the ~stateless-service-type~ is appended, not prepended, to operating system services. It also modifies file systems so users of this component should include it at the end of their component chain.
#+begin_src scheme
(define-system-comp (stateless #:key persist-dir bluetooth?)
  (initrd (lambda (file-systems . rest)
            (apply (operating-system-initrd os) file-systems
                   #:volatile-root? #t
                   rest)))
  (file-systems
   (map (lambda (fs)
          (if (member (file-system-mount-point fs)
                      `("/var/guix" "/var/log" ,persist-dir))
              (file-system
                (inherit fs)
                (needed-for-boot? #t))
              fs))
        (operating-system-file-systems os)))
  (services
   (append
    (operating-system-user-services os)
    (list
     (service stateless-service-type
              `(#:persist-dir ,persist-dir
                #:paths ,(append
                          '("/etc/machine-id"
                            "/var/lib/random-seed"
                            "/etc/NetworkManager/system-connections"
                            "/var/lib/NetworkManager/secret_key"
                            "/etc/guix/signing-key.pub"
                            "/etc/guix/signing-key.sec")
                          (if bluetooth?
                              (list "/var/lib/bluetooth") '()))))))))
#+end_src
**** Service
#+begin_src scheme
(define save-or-restore-users+groups
  #~(lambda (persist-dir save-or-restore)
      (for-each (lambda (path)
                  (let ((files (list path (string-append persist-dir path))))
                    (apply copy-file (case save-or-restore
                                       ((#:restore) (reverse files))
                                       ((#:save) files)))))
                '("/etc/group"
                  "/etc/passwd"
                  "/etc/shadow"))))

(define (populate-gexp config)
  (with-extensions (list guile-gcrypt)
    (with-imported-modules (source-module-closure
                            '((gnu build install)))
      #~(begin
          (use-modules ((gnu build install) #:select (populate-root-file-system)))

          (define* (populate #:key persist-dir #:allow-other-keys)
            (let* ((system-path "/var/guix/profiles/system")
                   (system-1-path "/var/guix/profiles/system-1-link")
                   (system-1-exists? (file-exists? system-1-path))
                   (system-link (readlink system-path))
                   (system-1-link (if system-1-exists?
                                      (readlink system-1-path)
                                      system-link)))
              (populate-root-file-system system-1-link ""
                                         #:extras `((,system-path -> ,system-link)))
              (unless system-1-exists?
                (delete-file system-1-path)))
            (#$save-or-restore-users+groups persist-dir #:restore))

          (apply populate '#$config)))))

(define (activate-state-gexp config)
  #~(begin
      (use-modules ((ice-9 match) #:select (match)))

      (define* (activate-state #:key persist-dir paths)

        (define (install path)
          (let loop ((components (string-tokenize path (char-set-complement (char-set #\/))))
                     (base persist-dir)
                     (target-base ""))
            (match components
              ((head tail ...)
               (let* ((path (string-append base "/" head))
                      (target-path (string-append target-base "/" head)))
                 (if (null? tail)
                     ;; The Guix code makes a point of doing stuff like this atomically. I don't really know why but I will too.
                     (let ((pivot (string-append target-path ".new")))
                       (symlink path pivot)
                       (rename-file pivot target-path))
                     (begin
                       (catch 'system-error
                         (lambda ()
                           (mkdir target-path))
                         (lambda args
                           (unless (= EEXIST (system-error-errno args))
                             (apply throw args))))
                       (let ((st (lstat path)))
                         (chown target-path (stat:uid st) (stat:gid st))
                         (chmod target-path (stat:perms st)))
                       (loop tail path target-path))))))))

        (for-each install paths)
        (#$save-or-restore-users+groups persist-dir #:save))

      (apply activate-state '#$config)))

(define stateless-service-type
  (service-type (name 'stateless)
                (extensions
                 (list (service-extension boot-service-type
                                          populate-gexp)
                       (service-extension activation-service-type
                                          activate-state-gexp)))))
#+end_src
*** Btrfs file systems
#+begin_src scheme
(define-system-comp (btrfs #:key label subvols)
  (file-systems
   (append
    (map (match-lambda
           ((subvol mount-point)
            (file-system
              (device (file-system-label label))
              (mount-point mount-point)
              (type "btrfs")
              (options (string-append "subvol=" subvol ",compress=zstd,autodefrag")))))
         subvols)
    (operating-system-file-systems os))))
#+end_src
*** Users
#+begin_src scheme
(define* (account #:key name comment admin? password salt bluetooth?)
  (user-account
   (name name)
   (comment (or comment ""))
   (group "users")
   (supplementary-groups (append '("netdev" "audio" "video")
                                 (if admin? '("wheel") '())
                                 (if bluetooth? '("lp") '())))
   (password (if password
                 (crypt password salt)
                 #f))))

(define-system-comp (users #:key who bluetooth?)
  (users
   (append (map (lambda (user)
                  (apply account (append user `(#:bluetooth? ,bluetooth?))))
                who)
           (operating-system-users os))))
#+end_src
*** GDM display manager
#+begin_src scheme
(define-system-comp (gdm #:key auto-login)
  (services
   (cons* (service gdm-service-type
                   (gdm-configuration
                    (auto-login? (if auto-login #t #f))
                    (default-user auto-login)
                    (wayland? #t)))
          (operating-system-user-services os))))
#+end_src
*** HiDPI console font
#+begin_src scheme
(define-system-comp (hidpi-console-font)
  (services
   (update-services
    (operating-system-user-services os)
    console-font-service-type
    (lambda (config)
      (map (lambda (tty-and-font)
             (cons (car tty-and-font)
                   (file-append font-terminus "/share/consolefonts/ter-132n")))
           config)))))
#+end_src
*** Nonguix substitutes
#+begin_src scheme
(define-system-comp (nonguix-substitutes)
  (services
   (update-services
    (operating-system-user-services os)
    guix-service-type
    (lambda (config)
      (guix-configuration
       (inherit config)
       (substitute-urls
        (append (guix-configuration-substitute-urls config)
                (list "https://substitutes.nonguix.org")))
       (authorized-keys
        (append (guix-configuration-authorized-keys config)
                (list (local-file "substitutes.nonguix.org.pub")))))))))
#+end_src
**** Signing key
#+begin_src scheme :tangle (in-tangle-dir "substitutes.nonguix.org.pub")
(public-key
 (ecc
  (curve Ed25519)
  (q #C1FD53E5D4CE971933EC50C9F307AE2171A2D3B52C804642A7A35F84F3A4EA98#)))
#+end_src
*** Macbook
I'm not sure if this requires [[Linux nonfree][Linux nonfree]] and/or if the blacklist refers to kernel modules that are only in the nonfree linux kernel (i.e., not linux-libre)
#+begin_src scheme
(define (with-blacklist kernel-args new)

  (define (blacklist? ka)
    (string-prefix? "modprobe.blacklist" ka))

  (if (any blacklist? kernel-args)
      (update-list kernel-args blacklist? (lambda (blacklist)
                                            (string-append blacklist "," new)))
      (cons* (string-append "modprobe.blacklist=" new) kernel-args)))

(define-system-comp (macbook #:key bluetooth?)
  (kernel-arguments (with-blacklist (operating-system-user-kernel-arguments os)
                                    "b43,b43legacy,ssb,bcm43xx,brcm80211,brcmfmac,brcmsmac,bcma"))
  (kernel-loadable-modules (cons* broadcom-sta
                                  (operating-system-kernel-loadable-modules os)))
  (firmware (append
             (if bluetooth? (list broadcom-bt-firmware) '())
             (operating-system-firmware os))))
#+end_src
**** Keyboard layout
#+begin_src scheme
(define macbook-kbl
  (keyboard-layout "us" #:model "macbook78"))
#+end_src
*** Window manager
#+begin_src scheme
(define-system-comp (wm #:key package services)
  (packages
   (cons* package
          (operating-system-packages os)))
  (services
   (append services
           (operating-system-user-services os))))
#+end_src
**** Sway
#+begin_src scheme
(define* (sway-wm os #:key laptop?)
  (wm os
      #:package sway
      #:services (append (list (screen-locker-service swaylock))
                         (if laptop?
                             (list (udev-rules-service 'backlight-add-udev-rules brightnessctl)) '()))))
#+end_src
*** Miscellany
nss-certs, Gnome, backlight control, Nix, bluetooth
#+begin_src scheme
(define-system-comp (miscellany #:key desktop? nix? pipewire? bluetooth?)
  (packages
   (cons* (specification->package "nss-certs")
          (operating-system-packages os)))
  (services
   (append
    (if desktop?
        (list (service gnome-desktop-service-type)) '())
    (if pipewire?
        (list (udev-rules-service 'pipewire-add-udev-rules pipewire-0.3)) '())
    (if nix?
        (list (service nix-service-type)) '())
    ;; (if bluetooth?
    ;;     (list (bluetooth-service #:auto-enable? #t)) '())
    (operating-system-user-services os))))
#+end_src
** Base OS
#+begin_src scheme :tangle (in-tangle-dir "base-os.scm") :noweb yes
(define-module (ebullient system base-os)
  #:use-module (ebullient system components)
  #:use-module (ebullient utils)
  #:export (base-os))

(define* (base-os #:key
                  host-name
                  (desktop? #t)
                  (laptop? #t)
                  macbook?
                  (disk-encryption? #t)
                  luks-uuid
                  (nix? #t)
                  (pipewire? desktop?)
                  (bluetooth? desktop?)
                  (aux-admin? #t)
                  (guest? laptop?))
  (-> barebones-os
      (basics #:host-name host-name
              #:timezone "America/Los_Angeles"
              #:locale "en_US.utf8"
              #:keyboard-layout (if macbook?
                                    macbook-kbl #f))
      (boot #:label "genesis"
            #:target "/boot/efi")
      (initial-services #:desktop? desktop?
                        #:pipewire? pipewire?)
      linux-nonfree
      (users #:who (append
                    '((#:name "<<user-name>>" #:comment "<<user-full-name>>" #:admin? #t))
                    (if aux-admin?
                        '((#:name "pcoulson" #:comment "Phil Coulson" #:admin? #t)) '())
                    (if guest?
                        '((#:name "gandalf" #:comment "Speak Friend and Enter" #:password "mellon" #:salt "toosimple")) '()))
             #:bluetooth? bluetooth?)
      (as-> $
        (if desktop?
            (-> $
                (gdm
                 ;; TODO
                 ;; #:auto-login (if disk-encryption?
                 ;;                      "<<user-name>>" #f)
                 )
                (sway-wm #:laptop? laptop?)
                hidpi-console-font)
            $))
      nonguix-substitutes
      (as-> $
        (if macbook?
            (macbook $ #:bluetooth? bluetooth?) $))
      (miscellany #:desktop? desktop?
                  #:nix? nix?
                  #:pipewire? pipewire?
                  #:bluetooth? bluetooth?)
      (as-> $
        (let* ((persist-dir "/.persist")
               (subvols
                (append
                 `(("root-blank" "/")
                   ("boot" "/boot")
                   ("guix-store" "/gnu/store")
                   ("guix-var" "/var/guix")
                   ("log" "/var/log")
                   ("home" "/home")
                   ("persist" ,persist-dir))
                 (if nix? '(("nix" "/nix")) '()))))
          (-> $
              (btrfs #:label "firmament"
                     #:subvols subvols)
              (as-> $
                (if disk-encryption?
                    (disk-encryption $ #:source-uuid luks-uuid
                                     #:target "ciphered"
                                     #:encrypted-mount-points (map cadr subvols))
                    $))
              (stateless #:persist-dir persist-dir
                         #:bluetooth? bluetooth?))))))
#+end_src
** Hosts
:PROPERTIES:
:tangle-dir+: /hosts
:END:
*** Frostfire
#+begin_src scheme :tangle (in-tangle-dir "frostfire.scm") :noweb yes
(define-module (ebullient system hosts frostfire)
  #:use-module (ebullient system base-os))

(define-public os
  (base-os #:host-name "frostfire"
           #:luks-uuid "<<frostfire-luks-uuid>>"
           #:macbook? #t))
#+end_src
**** LUKS UUID :external_state:
- REVIEW ~source-uuid~ is a kind of generated state (it gets created on install), perhaps I should treat it specially, like e.g. a channels lockfile. Currently I'm just putting it in this special org block, review once I've figured out how I'm doing generated state (putting it in files, redirecting it into the org file itself...)
#+name: frostfire-luks-uuid
#+begin_src org
bdda56af-6ca0-4953-bc13-d5af8715e0e5
#+end_src
* Home
:PROPERTIES:
:tangle-dir+: /ebullient/home
:END:
#+name: guix-home-profile
#+begin_src sh
~/.guix-home/profile
#+end_src
#+name: guix-extra-profiles-path
#+begin_src sh
~/.guix-extra-profiles
#+end_src
** Components
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "components.scm")
:END:
#+begin_src scheme
(define-module (ebullient home components)
  #:use-module (guix gexp)
  #:use-module (gnu home services)
  #:use-module ((gnu home services) #:select (home-profile-service-type))
  #:use-module (gnu home services shells)
  #:use-module (gnu home services shepherd)
  #:use-module ((gnu packages freedesktop) #:select (udiskie))
  #:use-module ((gnu packages gnome) #:select (network-manager-applet))
  #:use-module ((gnu packages linux) #:select (pipewire-0.3 wireplumber))
  #:use-module ((gnu packages shellutils) #:select (direnv))
  #:use-module ((gnu packages xdisorg) #:select (gammastep))
  #:use-module (gnu services)
  ;; #:use-module (gnu services configuration)
  #:use-module (gnu services shepherd)
  #:use-module (rde features)
  #:use-module ((rde features wm) #:select (feature-sway))
  #:use-module (ebullient utils)
  #:export (pipewire-services
            sway-services
            zsh-direnv-service-type
            gammastep-service-type
            nm-service-type
            udiskie-service-type))

(define serialize-posix-env-vars (@@ (gnu home services shells) serialize-posix-env-vars))
#+end_src
*** Pipewire
- TODO Once I figure out how I'm componentizing home config, decide if this should remain a list of services, I should turn it into a ~service-type~, etc
#+begin_src scheme
(define pipewire-services
  (list
   (simple-service 'pipewire-add-packages
                   home-profile-service-type
                   (list pipewire-0.3 wireplumber))
   (simple-service 'pipewire-add-shepherd-daemons
                   home-shepherd-service-type
                   (list
                    (shepherd-service
                     (provision '(pipewire))
                     (stop  #~(make-kill-destructor))
                     (start #~(make-forkexec-constructor
                               (list #$(file-append pipewire-0.3 "/bin/pipewire"))
                               #:environment-variables
                               (append (list "DISABLE_RTKIT=1")
                                       (default-environment-variables))))
                     (auto-start? #f))
                    (shepherd-service
                     (requirement '(pipewire))
                     (provision '(wireplumber))
                     (stop  #~(make-kill-destructor))
                     (start #~(make-forkexec-constructor
                               (list #$(file-append wireplumber "/bin/wireplumber"))
                               #:environment-variables
                               (append (list "DISABLE_RTKIT=1")
                                       (default-environment-variables))))
                     (auto-start? #f))
                    (shepherd-service
                     (requirement '(pipewire))
                     (provision '(pipewire-pulse))
                     (stop  #~(make-kill-destructor))
                     (start #~(make-forkexec-constructor
                               (list #$(file-append pipewire-0.3 "/bin/pipewire-pulse"))
                               #:environment-variables
                               (append (list "DISABLE_RTKIT=1")
                                       (default-environment-variables))))
                     (auto-start? #f))))
   (simple-service 'pipewire-add-asoundrc
                   home-files-service-type
                   `(("config/alsa/asoundrc"
                      ,(mixed-text-file
                        "asoundrc"
                        #~(string-append
                           "<" #$(file-append pipewire-0.3 "/share/alsa/alsa.conf.d/50-pipewire.conf") ">\n"
                           "<" #$(file-append pipewire-0.3 "/share/alsa/alsa.conf.d/99-pipewire-default.conf") ">\n"
                           "\n"
                           "pcm_type.pipewire {\n"
                           "  lib " #$(file-append pipewire-0.3 "/lib/alsa-lib/libasound_module_pcm_pipewire.so") "\n"
                           "}\n"
                           "\n"
                           "ctl_type.pipewire {\n"
                           "  lib " #$(file-append pipewire-0.3 "/lib/alsa-lib/libasound_module_ctl_pipewire.so") "\n"
                           "}\n")))))))
#+end_src
*** Sway
#+begin_src scheme
(define (sway-env-vars env-vars)
  (simple-service 'set-sway-env-vars
                  home-bash-service-type
                  (home-bash-extension
                   (bash-profile
                    (list (mixed-text-file
                           "sway-env-vars"
                           "if [[ \"$DESKTOP_SESSION\" = \"\" || \"$DESKTOP_SESSION\" = \"sway\" ]] ; then\n"
                           (serialize-posix-env-vars #f env-vars)
                           "fi"))))))

(define (conditionalize-sway-env-vars services)
  (define env-vars)
  (as-> services $
    (update-services*
     $
     (lambda (svc)
       (eq? (-> svc service-kind service-type-name) 'set-wayland-specific-env-vars))
     (lambda (vars)
       (set! env-vars vars)
       '()))
    (cons* (sway-env-vars env-vars) $)))

(define sway-services
  (conditionalize-sway-env-vars
   ((feature-home-services-getter
     (feature-sway #:xwayland? #t
                   #:sway-mod 'Mod1
                   #:extra-config
                   ;; `((include ,(file-append (@ (gnu packages wm) sway) "/etc/sway/config")))
                   ;; `((include ,(local-file "./config/sway/config")))
                   `((include "/home/pharcosyle/projects/dotfiles/config"))))
    (rde-config))))
#+end_src
*** Direnv (Zsh)
#+begin_src scheme
(define zsh-direnv-service-type
  (service-type (name 'home-zsh-direnv)
                (extensions
                 (list
                  (service-extension home-profile-service-type
                                     (const (list direnv)))
                  (service-extension home-zsh-service-type
                                     (const (home-zsh-extension
                                             ;; TODO Might be nice to make this `local-file' and src block
                                             (zshrc
                                              (list (plain-file "direnv-hook"
                                                                "eval \"$(direnv hook zsh)\""))))))))
                (default-value #f)))
#+end_src
*** Applets
**** Gammastep
- TODO broken tray icon. Probably I need to have some part of the =gammastep= package on the path so it can find the icon. Don't worry about this for now, maybe there will be some way to tell =papirus-icon-theme= to use a different icon or something.
#+begin_src scheme
(define (gammastep-shepherd-service _)
  (list
   (shepherd-service
    (provision '(gammastep))
    (start #~(lambda (wayland-display . _)
               ((make-forkexec-constructor
                 (list #$(file-append gammastep "/bin/gammastep-indicator") "-l 44:-123")
                 #:environment-variables
                 ;; (list (string-append "WAYLAND_DISPLAY=" wayland-display))
                 (call-with-input-file "/tmp/env-for-applets" read)))))
    (stop #~(make-kill-destructor))
    (respawn? #f)
    (auto-start? #f))))

(define gammastep-service-type
  (service-type (name 'home-gammastep)
                (extensions
                 (list (service-extension
                        home-shepherd-service-type
                        gammastep-shepherd-service)))
                (default-value #f)))
#+end_src
**** Network Manager
#+begin_src scheme
(define (nm-shepherd-service _)
  (list
   (shepherd-service
    (provision '(nm))
    (start #~(lambda (wayland-display . _)
               ((make-forkexec-constructor
                 (list #$(file-append network-manager-applet "/bin/nm-applet") "--indicator")
                 #:environment-variables
                 ;; (list (string-append "WAYLAND_DISPLAY=" wayland-display))
                 (call-with-input-file "/tmp/env-for-applets" read)))))
    (stop #~(make-kill-destructor))
    (respawn? #f)
    (auto-start? #f))))

(define nm-service-type
  (service-type (name 'home-nm)
                (extensions
                 (list (service-extension
                        home-shepherd-service-type
                        nm-shepherd-service)))
                (default-value #f)))
#+end_src
**** Udiskie
#+begin_src scheme
(define (udiskie-shepherd-service _)
  (list
   (shepherd-service
    (provision '(udiskie))
    (start #~(lambda (wayland-display . _)
               ((make-forkexec-constructor
                 (list #$(file-append udiskie "/bin/udiskie")
                       "--tray"
                       ;; (string-append "--file-manager="
                       ;;                #$(file-append xdg-utils "/bin/xdg-open"))
                       )
                 #:environment-variables
                 ;; (list (string-append "WAYLAND_DISPLAY=" wayland-display))
                 (call-with-input-file "/tmp/env-for-applets" read)))))
    (stop #~(make-kill-destructor))
    (respawn? #f)
    (auto-start? #f))))

(define udiskie-service-type
  (service-type (name 'home-udiskie)
                (extensions
                 (list (service-extension
                        home-shepherd-service-type
                        udiskie-shepherd-service)))
                (default-value #f)))
#+end_src
** Solitude
#+begin_src scheme :tangle (in-tangle-dir "solitude.scm") :noweb yes
(define-module (ebullient home solitude)
  #:use-module (guix gexp)
  #:use-module (gnu home)
  #:use-module (gnu home services)
  #:use-module (gnu home services mcron)
  #:use-module (gnu home services shells)
  #:use-module (gnu home services xdg)
  ;; #:use-module (gnu home-services gnupg)
  #:use-module (gnu home-services ssh)
  #:use-module (gnu home-services version-control)
  #:use-module (gnu packages)
  ;; #:use-module (gnu packages admin)
  ;; #:use-module (gnu packages gnupg)
  ;; #:use-module (gnu packages linux)
  #:use-module ((gnu packages shells) #:select (zsh))
  #:use-module (gnu services)
  ;; #:use-module (gnu system keyboard)


  #:use-module ((guix packages) #:select (package-input-rewriting))
  #:use-module ((gnu packages emacs) #:select (emacs emacs-minimal emacs-no-x))
  #:use-module ((flat packages emacs) #:select (emacs-native-comp))


  #:use-module (ebullient home doom-emacs-temp)


  #:use-module (ebullient home components)


  #:export (solitude))

;; (define emacs-variant emacs-native-comp)
(define emacs-variant emacs)

;; TODO Guix Home has an emacs service with a parameter `rebuild-elisp-packages?` that accomplishes I think the same thing as this but it's based on `substitute-keyword-arguments` instead of `package-input-rewriting`. How doe these approaches compare? Update: actually my approach won't do transitive dependencies (and maybe emacs argument like e.g. exwm has?) so it's pretty flawed. Doesn't matter though, I'm not going to be using the guix emacs packages, right?
(define with-emacs-variant
  (package-input-rewriting `((,emacs . ,emacs-variant)
                             (,emacs-minimal . ,emacs-variant)
                             (,emacs-no-x . ,emacs-variant))))

(define solitude
  (home-environment
   (packages (list (specification->package "font-fira-code") ; TODO (propagated) dependency of Doom config, move it somewhere when I figure out how I'm doing Emacs/Doom guix configuration.
                   ;; (specification->package "font-adobe-source-code-pro")
                   (specification->package "font-awesome") ; TODO for waybar, move this somewhere later
                   (specification->package "font-google-noto") ; TODO for sway (or any non-DE probably)
                   ;; emacs-variant ; TODO add this back when I can do so without eating up all my inodes (update: or do I want it in a manifest instead? Or better yet, since [if I recall] the only thing I needed the "direct" access to the emacs program for was running `doom upgrade` just make it a non-propagated input to my eventual Doom guix package. That is, if I even end up running `doom upgrade` after packaging Doom). Also delete bastille manifest
                   (with-emacs-variant doom-emacs-temp)))
   (services
    (append
     (list
      ;; TODO presumably only necessary if different from the login shell, maybe capture this when I modularize
      (simple-service 'set-default-shell-to-zsh
                      home-environment-variables-service-type
                      `(("SHELL" . ,(file-append zsh "/bin/zsh"))))
      (service home-bash-service-type
               (home-bash-configuration
                (environment-variables
                 `(("VISUAL" . ,(file-append emacs-variant "/bin/emacsclient"))
                   ("EDITOR" . "$VISUAL")))
                (bash-profile
                 (list (local-file "bash_profile")))))
     (service home-zsh-service-type
              (home-zsh-configuration
               (zshrc
                ;; TODO trying out Andrew Tropin's zsh configuration. I probably won't keep it verbatim like this but if I do don't hardcode the path
                (list (local-file "/home/pharcosyle/.config/guix/current/share/guile/site/3.0/rde/features/zsh/zshrc")
                      (local-file "zshrc")))))
      (service zsh-direnv-service-type)
      ;; TODO probably gate this
      (simple-service 'emacs-vterm-zsh-configuration
                      home-zsh-service-type
                      (home-zsh-extension
                       (zshrc
                        ;; TODO don't hardcode path
                        (list (local-file "/home/pharcosyle/.config/guix/current/share/guile/site/3.0/rde/features/zsh/vterm")))))

      (service home-xdg-user-directories-service-type
               (let* ((xdg-user-subdir "/files")
                      (xdg-dir (lambda (path)
                                 (string-append "$HOME" xdg-user-subdir path))))
                 (home-xdg-user-directories-configuration
                  (desktop "$HOME/desktop")
                  (documents (xdg-dir "/docs"))
                  (download "$HOME/dl")
                  (music (xdg-dir "/music"))
                  (pictures (xdg-dir "/pics"))
                  (publicshare (xdg-dir "/public"))
                  (templates (xdg-dir "/templates"))
                  (videos (xdg-dir "/vids")))))

      (service home-mcron-service-type
               (home-mcron-configuration
                (jobs
                 (list
                  #~(job '(next-hour)
                         (lambda ()
                           (call-with-output-file "/tmp/test-mcron-file"
                             (lambda (port)
                               (display "Output!" port))))
                         "Test mcron output")))))
      (service home-git-service-type
               (home-git-configuration
                (config
                 `((user
                    ((name . "<<user-full-name>>")
                     (email . "<<user-email>>")))
                   ;; (http "https://weak.example.com"
                   ;;   ((ssl-verify . #f)))
                   ;; (gpg
                   ;;  ((program . ,(file-append gnupg "/bin/gpg"))))
                   ;; (sendmail
                   ;;  ((annotate . #t)))
                   ))))
      (service home-ssh-service-type
               ;; (home-ssh-configuration
               ;;  (extra-config
               ;;   (list
               ;;    (ssh-host "savannah"
               ;;              '((compression . #f))))))
               )
      (simple-service 'nix-channels
                      home-files-service-type
                      (list `("nix-channels"
                              ,(local-file "nix-channels"))))
      (simple-service 'nixpkgs-config
                      home-files-service-type
                      (list `("config/nixpkgs/config.nix"
                              ,(local-file "nixpkgs-config.nix"))))
      ;; (simple-service 'doomdir
      ;;                 home-files-service-type
      ;;                 (list `("config/doom"
      ;;                         ,(local-file "doom" #:recursive? #t))))
      ;; TODO Examples from RDE I may want to make use of.
      ;; (service home-keyboard-service-type
      ;;          (keyboard-layout "us,ru" "dvorak,"
      ;;                           #:options '("grp:win_space_toggle" "ctrl:nocaps")))
      ;; (service home-gnupg-service-type
      ;;          (home-gnupg-configuration
      ;;           (gpg-agent-config
      ;;            (home-gpg-agent-configuration
      ;;             (ssh-agent? #t)))))
      ;; (service home-state-service-type
      ;;          (append
      ;;           (list
      ;;            (state-rsync "/home/bob/tmp/example-rsync-state/"
      ;;                         "abcdw@olorin.lan:/var/services/homes/abcdw/tmp-state/")
      ;;            (state-git "/home/bob/tmp/talkes/"
      ;;                       "git@git.sr.ht:~abcdw/rde"))))
      )
     pipewire-services
     sway-services

     (list
      (service gammastep-service-type)
      (service nm-service-type)
      (service udiskie-service-type))))))
#+end_src
#+begin_src sh :results output silent :dir base-tangle-dir :async
guix home --load-path=. --expression='(@ (ebullient home solitude) solitude)' reconfigure
#+end_src
** Shells
*** Bash profile
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "bash_profile")
:END:
**** Use Guix extra profiles
#+begin_src sh :noweb yes
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

for i in $GUIX_EXTRA_PROFILES/*; do
  profile=$i/$(basename "$i")
  if [ -f "$profile"/etc/profile ]; then
    GUIX_PROFILE="$profile"
    . "$GUIX_PROFILE"/etc/profile
  fi

  # Emulate guix-home setup-environment file (and thus `/etc/profile` as well). Regarding MANPATH and INFOPATH in particular, see https://guix.gnu.org/en/cookbook/en/guix-cookbook.html#Required-packages
  case $XDG_DATA_DIRS in
    ,*"$profile"/share*) ;;
    ,*) export XDG_DATA_DIRS="$profile"/share:$XDG_DATA_DIRS ;;
  esac
  case $MANPATH in
    ,*"$profile"/share/man*) ;;
    ,*) export MANPATH="$profile"/share/man:$MANPATH
  esac
  case $INFOPATH in
    ,*"$profile"/share/info*) ;;
    ,*) export INFOPATH="$profile"/share/info:$INFOPATH ;;
  esac
  case $XDG_CONFIG_DIRS in
    ,*"$profile"/etc/xdg*) ;;
    ,*) export XDG_CONFIG_DIRS="$profile"/etc/xdg:$XDG_CONFIG_DIRS ;;
  esac
  case $XCURSOR_PATH in
    ,*"$profile"/share/icons*) ;;
    ,*) export XCURSOR_PATH="$profile"/share/icons:$XCURSOR_PATH ;;
  esac

  unset profile
done
#+end_src
**** Load Nix environment
#+begin_src sh
if [ -f /run/current-system/profile/etc/profile.d/nix.sh ]; then
  . /run/current-system/profile/etc/profile.d/nix.sh
fi
#+end_src
**** Make Flatpak apps visible
#+begin_src sh
export XDG_DATA_DIRS=$HOME/.local/share/flatpak/exports/share:$XDG_DATA_DIRS
#+end_src
*** Zshrc
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "zshrc")
:END:
**** History
#+begin_src sh
HISTSIZE=1000000
SAVEHIST=$HISTSIZE
#+end_src
** Guix extra profiles
:PROPERTIES:
:tangle-dir+: /manifests
:END:
#+name: install-profiles
#+begin_src sh :results output silent :dir (get-tangle-dir) :noweb yes :async
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

profiles=$*
if [[ $# -eq 0 ]]; then
    profiles="*";
fi

for profile in $profiles; do
  profileName=$(basename $profile .scm)
  profilePath="$GUIX_EXTRA_PROFILES/$profileName"
  mkdir -p $profilePath
  guix package --profile="$profilePath/$profileName" --manifest="$profileName.scm"
done
#+end_src
#+call: install-profiles[:cmdline ...]()

#+name: upgrade-profiles
#+begin_src sh :results output silent :noweb yes :async
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

profiles=$*
if [[ $# -eq 0 ]]; then
    profiles="$GUIX_EXTRA_PROFILES/*";
fi

for profile in $profiles; do
  profileName=$(basename $profile)
  profilePath="$GUIX_EXTRA_PROFILES/$profileName"
  guix package --profile="$profilePath/$profileName" --manifest="$profileName.scm"
done
#+end_src
#+call: upgrade-profiles[:cmdline ...]()
*** Manifests
#+name: guix-extra-profile-path
#+begin_src sh :var profileName="" :noweb yes
echo "<<guix-extra-profiles-path>>/$profileName/$profileName"
#+end_src
**** multiverse
#+begin_src scheme :tangle (in-tangle-dir "multiverse.scm")
(specifications->manifest
 '("btrfs-progs" ; TODO "depends on"/"exists because of" the stateless module. Maybe it should be in some "system administration" section of Home config

   ;; "protonvpn-cli" ; REVIEW Appears to be broken after the big Guix frozen-updates upgrade.

   ;; Flatpak
   "flatpak"
   "xdg-desktop-portal"
   "xdg-desktop-portal-wlr"

   ;; General
   "xdg-utils"
   "gtk+:bin"
   "curl"
   "zip"
   "unzip"

   ;; Nice-to-have ; TODO might get rid of these and just `guix shell' or install as-needed
   "tree"
   "woof"


   ;;; Apps

   ;; Nyxt
   "nyxt"
   "gst-libav"
   "gst-plugins-bad"
   "gst-plugins-base"
   "gst-plugins-good"
   "gst-plugins-ugly"

   ;; "gimp" ; TODO maybe. Or just install as-needed with `guix shell`
   ))
#+end_src
#+begin_src elisp :noweb-ref guix-extra-profiles :noweb-sep " " :noweb yes
"<<guix-extra-profile-path("multiverse")>>"
#+end_src
**** bastille
#+begin_src scheme :tangle (in-tangle-dir "bastille.scm")
;; TODO Getting rid of this (either putting it in "multiverse" manifest or in solitude). Make it a reference to emacs-variant.
;; - although if I'm going to be running off of the latest emacs-29 I might want to keep emacs in a separate manifest to make rolling back easier.
(specifications->manifest
 '("emacs-29-pgtk-native-comp"))
#+end_src
#+begin_src elisp :noweb-ref guix-extra-profiles :noweb-sep " " :noweb yes
"<<guix-extra-profile-path("bastille")>>"
#+end_src
**** clojure manifest WIP
- TODO =clojure-tools= has, at the time of this writing, just been upstreamed from nonguix to guix. However the guix package depends on the guix =clojure= package (presumably instead of just using the one included in the downloaded clojure-tools) which is currently on version 1.10.0 (I'll definitely want a newer version) and has a dependency on icedtea (which is jdk version 8 even though now I'll want openjdk version 11 to match datomic or version 17 because it's the newest one supported by clojure). Rewrite the =clojure= package =jre= dependency to use a newer version and bump clojure somehow? What does the =clojure= package being old mean for me, if anything, since projects definte their own clojure versions (perhaps just that version of clojure will be used when invoking tools outside a project, and even then I could just specify a higher clojure version in my home directory =deps.edn=, no?) Just resurrect the nonguix clojure-tools packge in my own dotfiles? If I keep using the guix clojure-tools package that depends on =clojure= does it having its own non-propagated java dependency mean I don't have to install one in my profile any more?
#+begin_src scheme
(specifications->manifest
 '("clojure-tools" ; TODO comes from nonguix channel, I might be making that explicit later
   "icedtea" ; For clojure-tools ; TODO can I make this a non-propagated input to "clojure-tools" (`substitute*' or `wrap-program'? Automatic in some way?) or is that a bad idea / a pain?
   "clj-kondo")) ; TODO comes from nonguix channel, I might be making that explicit later
#+end_src
** Nix
*** Nix channels
#+begin_src conf :tangle (in-tangle-dir "nix-channels")
https://nixos.org/channels/nixpkgs-unstable nixpkgs
#+end_src
*** Nixpkgs config
#+begin_src nix :tangle (in-tangle-dir "nixpkgs-config.nix")
{ allowUnfree = true; }
#+end_src
*** Nix WIP
Commands and stuff (like manifests install and upgrade and guix channel pull) plus a packages "manifest"
**** Update channels
#+begin_src sh :results output silent :async
nix-channel --update
#+end_src
**** "Manifest"
#+name: nix-packages
#+begin_src org
google-chrome zoom-us
#+end_src
**** Install packages
#+begin_src sh :results output silent :async :noweb yes
nix-env --install <<nix-packages>>
#+end_src
**** Upgrade packages
#+begin_src sh :results output silent :async
nix-env --upgrade
#+end_src
** WIP Flatpak
Ran these manually
#+begin_src sh
flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

# flatpak install --user flathub com.spotify.Client
# flatpak install --user flathub us.zoom.Zoom
#+end_src
** Doom
:PROPERTIES:
:tangle-dir+: /doom
:END:
*** Init
#+begin_src elisp :tangle (in-tangle-dir "init.el")
;;; -*- lexical-binding: t; -*-
(doom! :completion
       (company +childframe)
       (vertico +icons)

       :ui
       doom
       doom-dashboard
       (emoji +unicode)
       hl-todo
       hydra
       indent-guides
       (ligatures +extra)
       modeline
       nav-flash
       ophints
       (popup +defaults +all)
       tabs
       treemacs
       vc-gutter
       vi-tilde-fringe
       window-select
       workspaces

       :editor
       (evil +everywhere)
       file-templates
       fold
       format
       lispy
       multiple-cursors
       rotate-text
       snippets
       word-wrap

       :emacs
       (dired +icons)
       electric
       (ibuffer +icons)
       undo
       vc

       :term
       eshell
       vterm

       :checkers
       (syntax +childframe)

       :tools
       direnv
       (eval +overlay)
       lookup
       (magit +forge)
       (pass +auth)
       pdf
       prodigy
       rgb
       taskrunner

       :lang
       clojure
       common-lisp
       data
       emacs-lisp
       json
       javascript
       markdown
       nix ; TODO this should be gated by Nix inclusion like system components do.
       (org +journal)
       rest
       (scheme +guile)
       sh
       web
       yaml ; TODO this should probably be specific to the krush/hyperdrive/afterburner(?) project

       :app
       calendar

       :config
       (default +bindings +smartparens))
#+end_src
*** Config
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "config.el")
:END:
**** Header
#+begin_src elisp
;;; -*- lexical-binding: t; -*-
#+end_src
**** Requires
#+begin_src elisp
(use-package! dash)
(use-package! s)
#+end_src
**** Personal Info :user:
#+begin_src elisp :noweb yes
(setq user-full-name "<<user-full-name>>"
      user-mail-address "<<user-email>>")
#+end_src
**** Locals :path:
#+begin_src elisp
(defconst biome--org-dir (concat org-directory "~/org"))
(defconst biome--org-gcal-dir (concat biome--org-dir "/gcal"))

(defconst biome--very-big 1000000)

(defconst biome--theme 'doom-nuclear)
#+end_src
#+begin_src elisp :var palette=palette
(defun biome--color (color)
  (let ((k (-> color symbol-name (substring 1))))
    (cadr (assoc k palette))))
#+end_src
**** General :UI:path:
#+begin_src elisp
;; hlissner says this must be set before org loads. I'm not sure if this is a requirement of org-mode but the Doom org config certainly does a lot of gymnastics with this variable so I'll just set this exactly like the example config does.
(setq org-directory biome--org-dir)

(setq scroll-margin 10
      save-interprogram-paste-before-kill t)

;; I like having line numbers on but hlissner says they're slow so I might want to disable them at some point. Keep in mind I use them to determine what lines are continuation lines so I might have to make the right fringe bigger if I do this and set visual-line-fringe-indicators.
;; (setq display-line-numbers-type nil)
#+end_src
***** Doom resets
#+begin_src elisp
(setq-default indent-tabs-mode t)

;; I'd like to have this on but in the Doom code it says it's more efficient not to.
;; (setq-default cursor-in-non-selected-windows t)
#+end_src
***** Doom
#+begin_src elisp
;; REVIEW Might be useful if there end up being a lot more of these and they have a lot of similarities: https://www.gnu.org/software/emacs/manual/html_node/elisp/Extending-Rx.html
(add-hook! 'doom-real-buffer-functions
  ;; (defun biome-new-buffer-p (buf)
  ;;   (s-matches?
  ;;    (rx bol "*new*"
  ;;        (* "<" (+ digit) ">")
  ;;        eol)
  ;;    (buffer-name buf)))
  ;; TODO This should be in my Org config section / module but wait to move it until I'm confident I'll be continuing with this marking-buffers-as-real approach.
  (defun biome-org-src-edit-buffer-p (buf)
    (s-matches?
     (rx bol "*Org Src " (+ anything) "*"
         (* "<" (+ digit) ">")
         eol)
     (buffer-name buf))))
#+end_src
**** Keybindings :bindings:
#+begin_src elisp
(setq help-char (string-to-char "\C-_"))
#+end_src
***** Translations
#+begin_src elisp
(defun biome--trans (&rest rest)
  (-each (-partition 2 rest)
    (-lambda ((to from))
      (define-key key-translation-map (kbd to) (kbd from)))))

(biome--trans "C-h" "DEL"
              "C-?" "C-h"

              "s-h" "<left>"
              "s-j" "<down>"
              "s-k" "<up>"
              "s-l" "<right>")
#+end_src
***** Leader/localleader
#+begin_src elisp
(setq doom-leader-alt-key "s-SPC"
      doom-localleader-key "s-m"
      doom-localleader-alt-key "s-m")
#+end_src
***** General
#+begin_src elisp
(defalias 'original-yank-pop #'yank-pop)

;; REVIEW Some of these should be in `:after' (or their respective package) sections but I'm not totally certain where I want to put bindings yet and I'm lazy.
(map! "s-V" #'original-yank-pop

      "s-SPC" doom-leader-map

      ;; Adapted from Doom macOS bindings: ~/.config/emacs/modules/config/default/config.el:263
      "s-`" #'other-frame
      "s-n" #'+default/new-buffer
      "s-z" #'undo
      "s-Z" #'redo
      "s-c" (if (featurep 'evil) #'evil-yank #'copy-region-as-kill)
      "s-v" #'yank
      "s-s" #'save-buffer
      "s-x" #'execute-extended-command
      ;; REVIEW I don't think I need this, any time I'm in visual mode I can use `evil-delete` ("d")
      ;; :v "s-x" #'kill-region
      "s-/" (cmd! (save-excursion (comment-line 1)))
      :n "s-/" #'evilnc-comment-or-uncomment-lines
      :v "s-/" #'evilnc-comment-operator

      "s-t" (lookup-key doom-leader-map (kbd "`"))
      "s-f" (lookup-key doom-leader-map (kbd "s b"))
      "s-r" (lookup-key doom-leader-map (kbd "f r"))
      "s-w" (lookup-key doom-leader-map (kbd "b k"))
      "s-d w" (lookup-key doom-leader-map (kbd "w d"))
      "s-d s-w" (cmd! (kill-current-buffer)
                      (+workspace/close-window-or-workspace))
      "s-g" (lookup-key doom-leader-map (kbd "g g"))
      "s-," (lookup-key doom-leader-map (kbd "w w"))
      "s-<" (lookup-key doom-leader-map (kbd "w W"))
      "s-y" (lookup-key doom-leader-map (kbd "i y"))
      "s-{" (lookup-key doom-leader-map (kbd "b p"))
      "s-}" (lookup-key doom-leader-map (kbd "b n"))
      "s-p" (lookup-key global-map (kbd "C-~")) ; TODO if I'm keeping this, improve it to first switch focus to a/the popup window if one isn't focused already

      "s-u" (lookup-key doom-leader-map (kbd "u"))
      "s-U" #'negative-argument         ; Trying this out.
      (:map universal-argument-map
       "s-u" #'universal-argument-more)

      (:after evil-easymotion
       "s-a" (lookup-key evilem-map (kbd "SPC")))

      "s-." #'repeat

      "s-J" #'evil-scroll-down
      "s-K" #'evil-scroll-up

      (:prefix "s-d"
       "." #'repeat-complex-command

       "h" #'git-gutter:popup-hunk
       ;; "o" #'+macos/open-in-default-program ;; TODO consider a Guix alternative? Meh.
       "r" #'projectile-replace
       "t" #'tldr
       "s" #'org-save-all-org-buffers
       "a" #'link-hint-open-multiple-links
       ;; "b" (cmd! (evil-local-mode 'toggle)
       ;;           (when evil-local-mode (evil-normal-state)))
       (:prefix "c"
        "f" #'org-gcal-fetch
        "s" #'org-gcal-sync
        "p" #'org-gcal-post-at-point)))
#+end_src
**** Modules
***** Completion
****** Vertico
******* vertico
#+begin_src elisp
(after! vertico
  (map! :map vertico-map
        "DEL" #'vertico-directory-delete-char))
#+end_src
***** UI
****** Doom
******* doom-themes
- TODO get rid of this if I'm not going to try it out again
#+begin_src elisp
;; (after! doom-themes
;;   (doom-themes-visual-bell-config))
#+end_src
****** Modeline
******* doom-modeline
#+begin_src elisp
(after! doom-modeline
  ;; (setq doom-modeline-checker-simple-format nil)
  (setq doom-modeline-major-mode-icon t)
  (setq doom-modeline-persp-name t))
#+end_src
****** Indent Guides
******* highlight-indent-guides :prog_mode:
#+begin_src elisp
(use-package! highlight-indent-guides
  :defer t
  :init
  ;; I don't want indent guides on by default, remove all the Doom module's hooks.
  (remove-hook! '(prog-mode-hook
                  text-mode-hook
                  conf-mode-hook)
    #'highlight-indent-guides-mode))
#+end_src
****** Ligatures
******* ligature
#+begin_src elisp :tangle (in-tangle-dir "init.el")
(use-package-hook! ligature
  :pre-config
  (setq +ligatures-all-modes-list
        '("www")
        +ligatures-prog-mode-list
        '(;; Fira Code (from https://github.com/tonsky/FiraCode/wiki/Emacs-instructions#using-ligatureel)
          "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\" "{-" "::"
          ":::" ":=" "!!" "!=" "!==" "-}" "----" "-->" "->" "->>"
          "-<" "-<<" "-~" "#{" "#[" "##" "###" "####" "#(" "#?" "#_"
          "#_(" ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*" "/**"
          "/=" "/==" "/>" "//" "///" "&&" "||" "||=" "|=" "|>" "^=" "$>"
          "++" "+++" "+>" "=:=" "==" "===" "==>" "=>" "=>>" "<="
          "=<<" "=/=" ">-" ">=" ">=>" ">>" ">>-" ">>=" ">>>" "<*"
          "<*>" "<|" "<|>" "<$" "<$>" "<!--" "<-" "<--" "<->" "<+"
          "<+>" "<=" "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<"
          "<~" "<~~" "</" "</>" "~@" "~-" "~>" "~~" "~~>" "%%"
          ;; Doom defaults (just the ones not already present in Fira Code)
          "|||>" "<|||" "<==>" "||>" "::=" "=!=" "!!." ">->" "---" "<~>"
          "<||" "<-<" "_|_" "~=" "|}" "|]" "|-" "{|" "[|" "]#" ":>" ":<"
          ">:" "-|" "--" "<:" "#:" "#=" "#!" ".?" "?:" "?." "__" "(*"
          "*)" "://"))
  t)
#+end_src
***** Editor
****** Evil
******* evil :bindings:theming:
#+begin_src elisp
(after! evil
  (defun biome--set-theme-cursor-color-symbols ()
    (put 'cursor 'evil-normal-color (biome--color :gold))
    (put 'cursor 'evil-emacs-color  (biome--color :pink)))

  (defadvice! biome-update-cursor-color-a (&rest _)
    :after #'+evil-update-cursor-color-h
    (when (memq biome--theme custom-enabled-themes)
      (biome--set-theme-cursor-color-symbols)))

  (map! :m [C-i] nil)) ; Remove Doom's binding for `evil-jump-forward'.
#+end_src
****** Multiple Cursors
******* evil-multiedit :evil:
#+begin_src elisp
(after! evil-multiedit
  (setq evil-multiedit-follow-matches t))
#+end_src
****** Lisp
******* lispy
#+begin_src elisp
(use-package! lispy
  :defer t
  :init
  ;; Not using lispy, remove all the Doom module's hooks.
  (remove-hook! '(lisp-mode-hook
                  emacs-lisp-mode-hook
                  ielm-mode-hook
                  scheme-mode-hook
                  racket-mode-hook
                  hy-mode-hook
                  lfe-mode-hook
                  dune-mode-hook
                  clojure-mode-hook
                  fennel-mode-hook)
    #'lispy-mode)
  (remove-hook! 'eval-expression-minibuffer-setup-hook #'doom-init-lispy-in-eval-expression-h))
#+end_src
******* lispyville :prog_mode:bindings:
#+begin_src elisp
(use-package! lispyville
  :hook (prog-mode . lispyville-mode)
  :init
  (setq lispyville-key-theme nil) ; Prevent Doom module's invocation of `lispyville-set-key-theme' from doing anything.
  :config
  (lispyville-set-key-theme
   '(operators
     c-w
     c-u
     commentary))
  (map! :map lispyville-mode-map
        "C-s-j" #'lispyville-beginning-of-next-defun
        "C-s-k" #'lispyville-beginning-of-defun
        "C-s-," #'lispyville-end-of-defun
        "C-s-a" #'lispyville-drag-backward
        "C-s-g" #'lispyville-drag-forward
        "C-s-p" #'lispyville-prettify
        (:prefix "C-s-;"
         "R" #'lispyville-raise-list)))
#+end_src
***** Emacs
****** Dired
******* dired-x :UI:hidden:
Don't hide files in dired, remove the Doom module's hook. However, via the Doom config dired-x is only loaded when ~dired-omit-mode~ is triggered so add another hook that mimics this (loads dired-x after the first use of dired). A simple =:after= would probably be fine too (and less odd) but this is lazier.
- TODO dired buffers always marked modified
  *wait to do this until I do my dired project*
  Removing the ~dired-omit-mode~ hook causes dired buffers to start off marked as modified. I don't think this was happening until I upgraded to Emacs 29 so maybe this will resolve itself on a later Emacs upgrade.
  - although even before this started happenning I recall dired buffers being marked modified and annoying to close irritating me. I don't know why I'd want that behavior to begin with but I suspect there are good reasons.
    Some remarks on modified dired buffers: [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Reverting-Dired.html]]
#+begin_src elisp
(use-package! dired-x
  :defer t
  :init
  (remove-hook! 'dired-mode-hook #'dired-omit-mode)
  (add-hook! 'dired-mode-hook
    (defun require-dired-x-h ()
      (require 'dired-x))))
#+end_src
***** Term
****** eshell :persistence:
#+begin_src elisp
(after! eshell
  (setq eshell-history-size biome--very-big)) ; Setting this to `nil' to inherit envvar HISTSIZE is another option.
#+end_src
***** Tools
****** Magit
******* magit :UI:
#+begin_src elisp
(after! magit
  (setq git-commit-style-convention-checks '(non-empty-second-line))
  (setq magit-revision-show-gravatars '("^Author:     " . "^Commit:     ")))
#+end_src
***** Lang
****** Clojure
******* clojure :bindings:theming:
#+begin_src elisp
(use-package! clojure-mode
  :defer t
  :init
  (setq clojure-refactor-map-prefix (kbd "s-M r")) ; Has to be set before clojure-mode loads. ; REVIEW temporary binding
  :config
  (set-ligatures! 'clojure-mode :lambda "fn")
  (custom-theme-set-faces! biome--theme
    `(clojure-character-face :foreground ,(doom-color 'violet) :weight bold)))
#+end_src
******* cider :persistence:
#+begin_src elisp
(after! cider
  (setq cider-repl-history-size biome--very-big
        cider-print-options '(("length" 100))))

;; REVIEW make sure this is still working after nesting in `after!'
(after! cider-repl
  (add-hook! 'cider-repl-mode-hook
             #'goto-address-prog-mode
             #'highlight-numbers-mode
             #'rainbow-delimiters-mode
             #'yas-minor-mode-on
             #'biome-sp-strict-h))
#+end_src
******* clj-refactor :bindings:
#+begin_src elisp
(after! clj-refactor
  (cljr-add-keybindings-with-prefix "s-M R")) ; REVIEW temporary binding
#+end_src
****** Emacs Lisp
******* emacs-lisp
#+begin_src elisp
(after! elisp-mode
  (setq-hook! 'emacs-lisp-mode-hook indent-tabs-mode nil))
#+end_src
****** Org
******* org :UI:path:
#+begin_src elisp
(after! org
  (setq org-agenda-files `(,biome--org-dir
                           ,biome--org-gcal-dir
                           ,(concat biome--org-dir "/projects"))
        org-log-done 'time
        org-priority-lowest ?E
        org-priority-default ?C
        org-priority-faces `((?A . ,(doom-color 'red))
                             (?B . ,(doom-color 'orange))
                             (?C . ,(doom-color 'blue))
                             (?D . ,(doom-color 'yellow))
                             (?E . ,(doom-color 'green)))))
#+end_src
******* org-persist :persistence:path:
#+begin_src elisp
(use-package! org-persist
  :defer t
  :init
  (setq org-persist-directory (concat doom-cache-dir "org-persist/")))
#+end_src
******* ob
#+begin_src elisp
(after! ob
  (setq org-babel-noweb-error-all-langs t))
#+end_src
******* evil-org :evil:bindings:
#+begin_src elisp
(after! evil-org
  (map! :map evil-org-mode-map
        :nv "C-j" #'outline-forward-same-level
        :nv "C-k" #'outline-backward-same-level))
#+end_src
****** Scheme
******* scheme
#+begin_src elisp
(after! scheme
  (setq-hook! 'scheme-mode-hook indent-tabs-mode nil))
#+end_src
******* geiser :persistence:path:guix:
Use ~:init~ to configure variables (as opposed to ~:config~, which seems like it'd be fine) because hlissner does it this way for the Geiser package so I will too.
#+begin_src elisp
(use-package! geiser
  :defer t
  :init
  (setq geiser-repl-current-project-function #'ignore) ; Reset this back to its default (don't have separate REPLs for projects) because it doesn't play nice with the Guix store.
  (setq geiser-repl-history-filename (concat doom-cache-dir "geiser-history")))
#+end_src
***** App
****** Calendar
******* org-gcal :org:user:secret:persistence:path:
#+begin_src elisp
(after! org-gcal
  (setq org-gcal-client-id "446729771716-pp79934q99aro2h8v3iki1fejcodbdoo.apps.googleusercontent.com"
        org-gcal-client-secret (-> (auth-source-search :host org-gcal-client-id) car (plist-get :secret) funcall)
        org-gcal-fetch-file-alist `((user-mail-address . ,(concat biome--org-gcal-dir "/" user-mail-address ".org"))
                                    ("addressbook%23contacts@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/contacts.org"))
                                    ("en.usa%23holiday@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/holidays.org")))
        org-gcal-recurring-events-mode 'nested))
#+end_src
***** Config
****** expand-region :bindings:
#+begin_src elisp
(use-package! expand-region
  :defer t
  :init
  (map! :nv "s-e" #'er/expand-region
        :nv "s-E" #'er/contract-region)
  :config
  (setq expand-region-fast-keys-enabled nil) ; My mapping is conventient enough and I don't want the repeat key to conflict with anything.
  ;; Copied from Doom config: ~/.config/emacs/modules/config/default/+emacs.el:12
  (defadvice! biome--quit-expand-region-a (&rest _)
    "Properly abort an expand-region region."
    :before '(evil-escape doom/escape)
    (when (memq last-command '(er/expand-region er/contract-region))
      (er/contract-region 0))))
#+end_src
***** Guix
****** Emacs integration
******* man :path:
#+begin_src elisp :noweb yes
(after! man
  (prependq! Man-header-file-path
             (-concat (-map (lambda (p)
                              (concat p "/include"))
                            '(<<guix-extra-profiles>>))
                      '("<<guix-home-profile>>/include"))))
#+end_src
******* tramp :path:
Make tramp work on Guix. Tramp is used locally to do sudo from inside Emacs so include my user-specific paths too.
#+begin_src elisp :noweb yes
(after! tramp
  (prependq! tramp-remote-path
             (-concat (-map (lambda (p)
                              (concat p "/bin"))
                            '(<<guix-extra-profiles>>))
                      '("<<guix-home-profile>>/bin"
                        "~/.config/guix/current/bin"
                        "~/.guix-profile/bin"
                        "~/.guix-profile/sbin"
                        "/run/current-system/profile/bin"
                        "/run/current-system/profile/sbin"))))
#+end_src
****** Guix.el
******* guix :UI:
#+begin_src elisp
(after! guix
  (set-popup-rules!
    '(("^\\*Guix" :height 0.5))))
#+end_src
******* guix-devel :scheme:
#+begin_src elisp
(use-package! guix-devel
  :hook (scheme-mode . guix-devel-mode))
#+end_src
******* guix-popup :bindings:
#+begin_src elisp
(use-package! guix-popup
  :defer t
  :init
  (map! :leader
        "l" #'guix))  ; REVIEW temporary binding?
#+end_src
******* guix-prettify :UI:
#+begin_src elisp
(use-package! guix-prettify
  :hook (doom-first-buffer . global-guix-prettify-mode))
#+end_src
****** Editing
- TODO The Guix repo offers some [[https://github.com/guix-mirror/guix/tree/master/etc/snippets][snippets]] and less importantly a copyright inserter I'd like to use ([[https://guix.gnu.org/manual/en/guix.html#The-Perfect-Setup][described here]]) but I don't know where if anywhere the repo code lives on my machine.
#+begin_src elisp
;; (let ((guix-source-path "???/guix"))

;;   (after! yasnippet
;;     (add-to-list 'yas-snippet-dirs (concat guix-source-path "/etc/snippets")))

;;   (after! skeleton
;;     (load-file (concat guix-source-path "/etc/copyright.el")))

;;   (after! copyright
;;     (setq copyright-names-regexp (format "%s <%s>" user-full-name user-mail-address))))
#+end_src
***** ?
****** avy
#+begin_src elisp
;; REVIEW Trying out not having this so I can use avy dispatch commands.
;; (after! avy
;;   (setq avy-single-candidate-jump t))
#+end_src
****** paren :UI:
#+begin_src elisp
(after! paren
  (setq! show-paren-delay 0))
#+end_src
****** prog-mode :prog_mode:
#+begin_src elisp
(add-hook! 'prog-mode-hook #'biome-sp-strict-h)
#+end_src
****** rainbow-delimiters :theming:
#+begin_src elisp
(after! rainbow-delimiters
  (let ((default-max rainbow-delimiters-max-face-count))
    (defun biome-set-rainbow-delimiters-max-face-count ()
      (setq rainbow-delimiters-max-face-count
            (if (memq biome--theme custom-enabled-themes)
                8 default-max))))

  (biome-set-rainbow-delimiters-max-face-count)
  (add-hook! 'doom-load-theme-hook #'biome-set-rainbow-delimiters-max-face-count)

  (custom-theme-set-faces! biome--theme
    `(rainbow-delimiters-depth-1-face :foreground ,(doom-color 'fg))
    `(rainbow-delimiters-depth-2-face :foreground ,(doom-color 'magenta))
    `(rainbow-delimiters-depth-3-face :foreground ,(doom-color 'blue))
    `(rainbow-delimiters-depth-4-face :foreground ,(doom-color 'cyan))
    `(rainbow-delimiters-depth-5-face :foreground ,(doom-color 'green))
    `(rainbow-delimiters-depth-6-face :foreground ,(doom-color 'yellow))
    `(rainbow-delimiters-depth-7-face :foreground ,(doom-color 'orange))
    `(rainbow-delimiters-depth-8-face :foreground ,(doom-color 'red))))
#+end_src
****** recentf :persistence:
#+begin_src elisp
(after! recentf
  (setq recentf-max-saved-items 500))
#+end_src
****** smartparens :bindings:
#+begin_src elisp
(after! smartparens
  (map! :map smartparens-mode-map
        "C-s-h" #'sp-backward-sexp
        "C-s-l" #'sp-forward-sexp
        "C-s-u" #'sp-backward-up-sexp
        "C-s-o" #'sp-up-sexp
        :gn "C-s-m" #'sp-backward-down-sexp ; Bind in normal mode explicitly to override the Doom mapping in ~/.config/emacs/modules/config/default/config.el:447
        "C-s-." #'sp-down-sexp
        "C-s-c" #'sp-splice-sexp
        "C-s-s" #'sp-splice-sexp-killing-backward
        "C-s-f" #'sp-splice-sexp-killing-forward
        "C-s-x" #'sp-backward-slurp-sexp
        "C-s-v" #'sp-forward-slurp-sexp
        "C-s-w" #'sp-backward-barf-sexp
        "C-s-r" #'sp-forward-barf-sexp
        (:prefix "C-s-;"
         "(" #'sp-wrap-round
         "[" #'sp-wrap-square
         "{" #'sp-wrap-curly
         "s" #'sp-split-sexp
         "j" #'sp-join-sexp
         "r" #'sp-raise-sexp
         "c" #'sp-convolute-sexp
         "w" #'sp-rewrap-sexp)))
#+end_src
******* Hook :bindings:
#+begin_src elisp
(defun biome-sp-strict-h ()
  (add-hook! 'smartparens-enabled-hook :local
             #'turn-on-smartparens-strict-mode
             (defun biome-modify-sp-strict-mode-map-h ()
               (map! :map smartparens-strict-mode-map
                     :i "DEL" #'sp-backward-delete-char))))
#+end_src
****** tldr :persistence:path:
#+begin_src elisp
(use-package! tldr
  :defer t
  :config
  (setq tldr-directory-path (concat doom-etc-dir "tldr/")))
#+end_src
****** transient :persistence:
- TODO Not sure where this should be categorized, it's a helper package required by at least magit, forge, git-timemachine
#+begin_src elisp
(after! transient
  (setq transient-history-limit biome--very-big))
#+end_src
****** undo-fu
#+begin_src elisp
(after! undo-fu
  (setq undo-fu-ignore-keyboard-quit t))
#+end_src
****** undo-tree :UI:
#+begin_src elisp
;; (after! undo-tree
;;   (setq undo-tree-visualizer-timestamps t))
#+end_src
****** emojify :UI:
#+begin_src elisp
(after! emojify
  (setq emojify-display-style 'unicode))
#+end_src
****** asdf :bindings:
- TODO donno where this should go, ~+default-minibuffer-maps~ is a doom thing I guess
#+begin_src elisp
(define-key! :keymaps +default-minibuffer-maps
  "s-J" #'scroll-up-command
  "s-K" #'scroll-down-command)
#+end_src
**** Theming :theming:
#+begin_src elisp
(setq doom-theme biome--theme)

(custom-theme-set-faces! biome--theme
  `(font-lock-comment-delimiter-face :foreground ,(biome--color :comment-delimiter))
  `(font-lock-doc-face :foreground ,(doom-color 'cyan)))
#+end_src
***** Nuclear Theme
#+begin_src elisp :tangle (in-tangle-dir "themes/doom-nuclear-theme.el") :noweb yes
<<gen-doom-theme()>>
#+end_src
#+name: gen-doom-theme
#+begin_src elisp :var palette=palette
(defun dt--color (color)
  (let ((k (-> color symbol-name (substring 1))))
    (cadr (assoc k palette))))

(defmacro dt--buffer->string (&rest body)
  `(with-temp-buffer
     ,@body
     (buffer-string)))

(defun dt--slurp (f)
  (dt--buffer->string
   (insert-file-contents f)))

(defun dt--replace (s match replacement)
  (replace-regexp-in-string match replacement s 'fixedcase 'literal))

(defun dt--replace-sexp (s match replacement)
  (dt--buffer->string
   (insert s)
   (goto-char (point-min))
   (re-search-forward match)
   ;; Calling `forward-sexp' and `backward-sexp' here to preserve whitespace.
   (forward-sexp)
   (backward-sexp)
   (kill-sexp)
   (insert (format "%S" replacement))))

(defun dt--gen-doom-theme (f)
  (-as->
   (dt--slurp f) $
   (dt--replace-sexp $ "def-doom-theme" 'doom-nuclear)
   (dt--replace $ "doom-one" "nuclear")
   (-reduce-from
    (-lambda (s (match replacement))
      (dt--replace-sexp s match replacement))
    $
    (-partition
     2
     (let ((match-base-color (lambda (form)
                               (rx-to-string `(seq "(" ,form (+ whitespace) "'("))))
           (match-face (lambda (&rest forms)
                         (rx-to-string `(seq "(" ,@forms)))))
       (list
        (funcall match-base-color "fg") (dt--color :fg)
        (funcall match-base-color "red") (dt--color :red)
        (funcall match-base-color "orange") (dt--color :orange)
        (funcall match-base-color "green") (dt--color :green)
        (funcall match-base-color "yellow") (dt--color :yellow)
        (funcall match-base-color "blue") (dt--color :blue)
        (funcall match-base-color "dark-blue") (dt--color :dark-blue)
        (funcall match-base-color "magenta") (dt--color :magenta)
        (funcall match-base-color "violet") (dt--color :violet)
        (funcall match-base-color "cyan") (dt--color :cyan)
        (funcall match-face "highlight") (dt--color :highlight)
        (funcall match-face "builtin") 'blue
        (funcall match-face "comments") (dt--color :comments)
        (funcall match-face "constants") 'yellow
        (funcall match-face "functions") 'blue
        (funcall match-face "keywords") 'magenta
        (funcall match-face "methods") 'violet
        (funcall match-face "operators") 'cyan
        (funcall match-face "type") 'orange
        (funcall match-face "variables") 'red
        (funcall match-face "numbers") 'violet
        (funcall match-face "line-number-current-line" '(+? anything) ":foreground") 'violet))))))

;; REVIEW do this better (don't hardcode it?). Add a :path: tag to this org header if necessary. Perhaps it would be best to have the doom-themes repo be an explicit dependency in some way and manage like I do other Guix or Doom/straight dependencies.
(dt--gen-doom-theme "~/.config/emacs/.local/straight/repos/themes/themes/doom-one-theme.el")
#+end_src
***** Font
#+begin_src elisp
(let ((font (font-spec :family "Fira Code Retina" :size 12)))
  (when (find-font font)
    (setq doom-font font)))
#+end_src
**** Projects
***** Dotfiles :path:
#+begin_src elisp
(load "~/projects/dotfiles/meta.el" 'noerror 'nomessage)

(pushnew! safe-local-variable-values
          '(eval . (with-eval-after-load 'geiser-guile
                     (let ((root-dir
                            (file-name-directory
                             (locate-dominating-file default-directory ".dir-locals.el"))))
                       (make-local-variable 'geiser-guile-load-path)
                       (add-to-list 'geiser-guile-load-path root-dir)))))
#+end_src
***** Nyxt
- TODO donno if I should keep this section in particular (it's not really impoportant), I'm just thinking I want to start trying out adding safe local variables for other codebases so I can get their advantages.
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(eval . (cl-flet ((enhance-imenu-lisp
                              (&rest keywords)
                              (dolist (keyword keywords)
                                (add-to-list
                                 'lisp-imenu-generic-expression
                                 (list (purecopy (concat (capitalize keyword)
                                                         (if (string= (substring-no-properties keyword -1) "s")
                                                             "es"
                                                           "s")))
                                       (purecopy (concat "^\\s-*("
                                                         (regexp-opt
                                                          (list (concat "define-" keyword))
                                                          t)
                                                         "\\s-+\\(" lisp-mode-symbol-regexp "\\)"))
                                       2)))))
                     ;; This adds the argument to the list of imenu known keywords.
                     (enhance-imenu-lisp
                      "bookmarklet-command"
                      "class"
                      "command"
                      "ffi-method"
                      "function"
                      "mode"
                      "parenscript"
                      "user-class"))))
#+end_src
***** Hyperdrive :path:
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(cider-preferred-build-tool . shadow-cljs)
          '(cider-default-cljs-repl . shadow)
          '(cider-shadow-default-options . ":app")
          '(cider-offer-to-open-cljs-app-in-browser . nil)
          '(cider-clojure-cli-global-options . "-A:dev")
          '(eval . (setenv "DATOMIC_APP_INFO_MAP" "{:app-name \"neutrino\"}"))
          '(eval . (setenv "DATOMIC_ENV_MAP" "{:env :dev}"))
          '(cider-clojure-cli-global-options . nil))

(prodigy-define-service
  :name "Amplify Mock"
  :command "amplify"
  :args '("mock")
  :cwd "~/projects/Krush/hyperdrive/apps/singularity"
  :kill-process-buffer-on-stop t)

(prodigy-define-service
  :name "Datomic Access (exogenesis)"
  :command "bash"
  :args '("datomic" "client" "access" "exogenesis")
  :cwd "~/projects/Krush/hyperdrive/ion/team"
  :kill-process-buffer-on-stop t)
#+end_src
***** Massrealty :path:
#+begin_src elisp
;; (pushnew! safe-local-variable-values
;;           '(ssh-deploy-root-remote . "/ssh:massrealty@35.196.144.73:/home/massrealty/deploy/homes/public_html/")
;;           '(ssh-deploy-automatically-detect-remote-changes . t))

;; (after! org-gcal
;;   (add-to-list 'org-gcal-fetch-file-alist `("krzysztof@massrealty.com" . ,(concat biome--org-gcal-dir "/krzysztof@massrealty.com.org")) 'append))
#+end_src
**** WIP
#+begin_src elisp
(after! org
  (add-to-list 'org-agenda-files (concat biome--org-dir "/spring_cleaning") 'append))

;; (map! "s-b" (cmd!
;;              ;; (message "chainging margin")
;;              ;; (message "%s" (selected-window))
;;              (set-window-margins (selected-window) nil (if (cdr (window-margins))
;;                                                            nil 12))))

;; I don't think I'll ever need this with Sway. Is it worth keeping this and having an "I'm not on Sway / some WM" conditional around it?
;; (add-to-list 'initial-frame-alist '(fullscreen . fullboth))

(map! "s-A" #'app-launcher-run-app)

(map! :leader
      "s-," (lookup-key doom-leader-map (kbd "<")))

(after! company
  (map! :map company-active-map
        "s-[" #'company-show-doc-buffer ; Currently opens Help, it would be better if I made it use Helpful.
        "s-]" #'company-show-location))

(after! evil-org
  (map! :map evil-org-mode-map
        (:prefix "g"
         :nv "{" #'evil-backward-paragraph
         :nv "}" #'evil-forward-paragraph)))

;; TODO Maybe do this if popping to the side is too annoying
;; (after! geiser-repl
;;   (setq geiser-repl-use-other-window nil))

(load "~/projects/dotfiles/doom-additional.el" 'noerror 'nomessage)
#+end_src
***** dotfiles auto-tangle :path:
- TODO Might be easier to do this with file-local variables.
#+begin_src elisp
;; (setq biome--dotfiles-dir "~/projects/dotfiles")

;; (add-hook! 'org-mode-hook
;;   (defun biome-add-org-autotangle-after-save-hook-h ()
;;     (add-hook! 'after-save-hook :local
;;       (defun biome-autotangle-h ()
;;         (when (file-in-directory-p buffer-file-name biome--dotfiles-dir)
;;           ;; TODO ensure there aren't files in the output directory that no longer correspond to the org file. Just wipe it?
;;           (let ((org-confirm-babel-evaluate nil))
;;             (org-babel-tangle)))))))
#+end_src
***** org-tanglesync
#+begin_src elisp
;; (use-package! org-tanglesync
;;   :hook ((org-mode . org-tanglesync-mode)
;;          ((prog-mode text-mode) . org-tanglesync-watch-mode))
;;   :config
;;   (setq org-tanglesync-watch-files '("/home/pharcosyle/projects/dotfiles/dotfiles.org")))
#+end_src
*** Packages
#+begin_src elisp :tangle (in-tangle-dir "packages.el")
;; -*- no-byte-compile: t; -*-

(package! dash :pin "da167c51e9fd167a48d06c7c0ee8e3ac7abd9718") ; TODO make this be introduced by my doom config (where I need it)?
(package! expand-region :pin "7e5bbe2763c12bae3e77fe0c49bcad05ff91dbfe")
(package! tldr :pin "d3fd2a809a266c005915026799121c78e8b358f0")
(package! trashed :pin "ddf5830730544435a068f2dc9ac75a81ea69df1d")

(package! guix :pin "c9aef52121b458297e70bb50f49f7276b4a8d759")
(package! build-farm :pin "5c268a3c235ace0d79ef1ec82c440120317e06f5") ; REVIEW trying out
(package! guix-packaging ; REVIEW trying out
  :recipe (:host github
           :repo "ryanprior/emacs-guix-packaging"
           :files (:defaults "snippets"))
  :pin "d843088252467db3c8a09de40ae9a62050196a0e")

(package! bluetooth :pin "a1ea361f17c6b4e5353160539cd3df6754007a9d") ; TODO just maybe make this dependent on my "bluetooth feature"

(package! symon :pin "8dd8b6df49b03cd7d31b85aedbe9dd08fb922335")

;; TODO this should probably be specific to the krush/hyperdrive/afterburner(?) project
;; (package! graphql-mode :pin "2371316a750b807de941184d49ca19d277ecadcd")

(package! org-tanglesync :pin "af83a73ae542d5cb3c9d433cbf2ce1d4f4259117")

(package! i3wm-config-mode :pin "c70bdc1367e461299e13a4797bc9d9d950184edd") ; TODO maybe make this part of a Sway / Window Manager feature or introduced by my Dotfiles project

;; REVIEW Breaks stuff after I updated to emacs 29 latest:
;; Compiling EmacSQL SQLite binary ...
;; Code Review initialization: (error "No EmacSQL SQLite binary available, aborting")
(package! code-review :disable t)

(package! app-launcher
  :recipe (:host github
           :repo "SebastienWae/app-launcher")
  :pin "80a9ed37892ee6e21fe44487ed11f66a15e3f440")

(package! 0x0 :pin "63cd5eccc85e527f28e1acc89502a53245000428")
#+end_src
** WIP emacs
*** doom-emacs-temp
- TODO probably "export" the ~doom~ program to user profile
#+begin_src scheme :tangle (in-tangle-dir "doom-emacs-temp.scm")
(define-module (ebullient home doom-emacs-temp)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module (guix build-system trivial)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module ((gnu packages base) #:select (coreutils))
  ;; #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages llvm) #:select (clang))
  #:use-module ((gnu packages rust-apps) #:select (fd ripgrep))
  #:use-module ((gnu packages version-control) #:select (git)))

(define-public doom-emacs-temp
  (package
    (name "doom-emacs-temp")
    (version "0")
    (source #f)
    ;; TODO Ideally these wouldn't be propagated inputs. Instead of tracking down usages of these and doing `substitute' everywhere maybe `wrap-prgram' is an option? However maybe there are other things in these inputs than just binaries Doom depends on or it has parts outside of emacs that recquire them?
    (propagated-inputs
     (list
      ;; Required
      ;; emacs ; TODO uncomment and wrap usage(s) with `package-input-rewriting`
      git
      ripgrep
      ;; Optional
      coreutils ; TODO might not be necessary because emacs Guix package already adds "coreutils/bin" to PATH with `wrap-program'
      fd
      clang ; TODO I still don't know what this is for. Notably hlissner doesn't install clang, nor gcc, in his emacs "module" in his dotfiles.
      ))
    (build-system trivial-build-system)
    (arguments
     `(#:modules ((guix build utils))
       #:builder
       ,#~(begin
            (use-modules (guix build utils))
            (mkdir-p (string-append #$output "/asdf"))
            (with-output-to-file (string-append #$output "/asdf/asdf.txt")
              (lambda _
                (display "asdffffffffffff")))
            #t)))
    (synopsis "An Emacs framework for the stubborn martian hacker")
    (description synopsis)
    (home-page "https://github.com/hlissner/doom-emacs")
    (license license:expat)))
#+end_src
* Channels
:PROPERTIES:
:tangle-dir+: /ebullient
:END:
#+begin_src scheme :tangle (in-tangle-dir "channels.scm")
(define-module (ebullient channels)
  #:use-module (guix channels)
  #:use-module ((srfi srfi-1) #:select (remove))
  #:export (get-channels
            guix
            nonguix
            rde
            flat))

(define* (get-channels #:rest cs)
  (append
   cs
   (remove (let ((names (map (lambda (c) (channel-name c)) cs)))
             (lambda (c)
               (member (channel-name c) names)))
           %default-channels)))

(define guix %default-guix-channel)

(define nonguix
  (channel
   (name 'nonguix)
   (url "https://gitlab.com/nonguix/nonguix")
   (introduction
    (make-channel-introduction
     "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
     (openpgp-fingerprint
      "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5")))))

(define rde
  (channel
   (name 'rde)
   (url "https://git.sr.ht/~abcdw/rde")
   (introduction
    (make-channel-introduction
     "257cebd587b66e4d865b3537a9a88cccd7107c95"
     (openpgp-fingerprint
      "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0")))))

(define flat
  (channel
   (name 'flat)
   (url "https://github.com/flatwhatson/guix-channel.git")
   (introduction
    (make-channel-introduction
     "33f86a4b48205c0dc19d7c036c85393f0766f806"
     (openpgp-fingerprint
      "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490")))))
#+end_src
* WIP channels
#+begin_src scheme :tangle (in-tangle-dir "frostfire-channels.scm")
(use-modules (ebullient channels))
(get-channels nonguix)
#+end_src
#+begin_src scheme :tangle (in-tangle-dir "solitude-channels.scm")
(use-modules (ebullient channels))
(get-channels nonguix rde flat)
#+end_src
#+begin_src sh :results output silent :dir base-tangle-dir :async
guix pull --load-path=. --channels=solitude-channels.scm
guix describe --format=channels > solitude-channels-lock.scm
#+end_src
#+begin_src sh :results output silent :dir base-tangle-dir :async
GUIX_EXTRA=$HOME/.guix-extra
mkdir -p $GUIX_EXTRA
profileName=frostfire
profilePath="$GUIX_EXTRA/$profileName"
mkdir -p $profilePath
guix pull --load-path=. --channels=frostfire-channels.scm --profile="$profilePath/$profileName"

guix_exe="$GUIX_EXTRA/$profileName/$profileName"/bin/guix
$guix_exe describe --format=channels > frostfire-channels-lock.scm
#+end_src
#+begin_src sh :results output silent :dir base-tangle-dir :async
$guix_exe="$GUIX_EXTRA/$profileName/$profileName"/bin/guix
sudo $guix_exe system --load-path=. --expression='(@ (ebullient system hosts frostfire) frostfire)' reconfigure
#+end_src
* Packages
:PROPERTIES:
:tangle-dir+: /ebullient/packages
:END:
** Emacs 29 with pgtk/nativecomp
#+begin_src scheme :tangle (in-tangle-dir "emacs.scm")
(define-module (ebullient packages emacs)
  #:use-module ((gnu packages emacs) #:select (emacs-next-pgtk))
  #:use-module ((gnu packages gcc) #:select (gcc-11)))

(define emacs-from-git (@@ (flat packages emacs) emacs-from-git))
(define emacs-with-native-comp (@@ (flat packages emacs) emacs-with-native-comp))

(define-public emacs-29-pgtk-native-comp
  (emacs-from-git
   (emacs-with-native-comp emacs-next-pgtk gcc-11 'full-aot)
   #:pkg-name "emacs-29-pgtk-native-comp"
   #:pkg-version "29.0.50"
   #:pkg-revision "0"
   #:git-repo "https://git.savannah.gnu.org/git/emacs.git"
   #:git-commit "dcc97fec29785051d7d11a66beb5f44fbaae6289"
   #:checksum "1xph27x953pgigb09dkjgfcb10ldlclbxwa0hmmawmxyyx3865bn"))
#+end_src
* Utils
:PROPERTIES:
:tangle-dir+: /ebullient
:END:
#+begin_src scheme :tangle (in-tangle-dir "utils.scm")
(define-module (ebullient utils)
  #:use-module (guix packages)
  #:use-module (gnu services)
  #:export (update-list
            ->
            as->
            update-services*))

(define (update-list l pred f)
  (map (lambda (x)
         (if (pred x) (f x) x))
       l))

(define-syntax ->
  (syntax-rules ()
    ((_ value) value)
    ((_ value (f1 . body) next ...) (-> (f1 value . body) next ...))
    ((_ value f1 next ...) (-> (f1 value) next ...))))

(define-syntax as->
  (syntax-rules ()
    ((_ expr name) expr)
    ((_ expr name form form* ...)
     (let ((name expr))
       (as-> form name form* ...)))))

(define (update-services* services pred update-fn)
  (update-list
   services
   pred
   (lambda (svc)
     (service (service-kind svc)
              (update-fn (service-value svc))))))
#+end_src
* Dev
** Git ignore
#+begin_src gitignore :tangle (in-tangle-dir ".gitignore")
/meta.el

/.gitignore
/ebullient/
/.dir-locals.el

# WIP
/frostfire-channels.scm
/solitude-channels.scm
#+end_src
** Github
*** Git config
#+begin_src gitconfig :tangle (in-tangle-dir ".git/config")
[remote "origin"]
	url = https://github.com/pharcosyle/dotfiles.git
	fetch = +refs/heads/*:refs/remotes/origin/*

[branch "master"]
	remote = origin
	merge = refs/heads/master
#+end_src
* Dev local
** Git config
#+begin_src gitconfig :tangle (in-tangle-dir ".git/config")
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
#+end_src
** Emacs directory-local variables
- TODO Causes gesier to fail to load outside of this directory
  *don't do this until I figure out how I'm doing per-project Emcas config* I might not end up doing Geiser setup this way at all
  Since the ~with-eval-after-load~ body will get called wherever geiser-guile is first loaded, if the geiser library isn't loaded yet and I e.g. visit a file in this directory, then leave, then try to =M-x guix p e= while I'm viewing a file elsewhere it'll fail to run since it loads geiser internally and can't find a dominating .dir-locals.
  - an alternative approach to setting up geiser for a project: [[https://github.com/guix-mirror/guix/blob/master/.dir-locals.el#L21][guix/.dir-locals.el at master  guix-mirror/guix  GitHub]]
    Maybe try that or something like it.
    - here's where I got the original approach, for reference: [[https://github.com/flatwhatson/flycheck-guile#troubleshooting][GitHub - flatwhatson/flycheck-guile: A Flycheck checker for GNU Guile]]
#+begin_src elisp :tangle (in-tangle-dir ".dir-locals.el")
((nil
  (eval . (with-eval-after-load 'geiser-guile
            (let ((root-dir
                   (file-name-directory
                    (locate-dominating-file default-directory ".dir-locals.el"))))
              (make-local-variable 'geiser-guile-load-path)
              (add-to-list 'geiser-guile-load-path root-dir))))))
#+end_src
