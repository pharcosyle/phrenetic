#+TITLE: Phrenetic
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args:elisp :lexical t

* Table of Contents :TOC:
- [[#meta][Meta]]
  - [[#path-hierarchy][Path hierarchy]]
- [[#install][Install]]
  - [[#program][Program]]
  - [[#package][Package]]
- [[#system][System]]
  - [[#components][Components]]
- [[#home][Home]]
  - [[#components-1][Components]]
  - [[#packages][Packages]]
- [[#common][Common]]
  - [[#packages-1][Packages]]
  - [[#stateless][Stateless]]
- [[#utils][Utils]]
  - [[#branching][Branching]]
  - [[#functions][Functions]]
  - [[#guix][Guix]]
- [[#auxillary][Auxillary]]
  - [[#packages-2][Packages]]
- [[#configurations][Configurations]]
  - [[#frostfire][Frostfire]]
  - [[#operating-systems][Operating systems]]
  - [[#home-environments][Home environments]]
- [[#channel][Channel]]
- [[#dev][Dev]]
  - [[#git-config][Git config]]
  - [[#git-ignore][Git ignore]]
  - [[#github][Github]]
- [[#dev-local][Dev local]]
  - [[#git-config-1][Git config]]
  - [[#emacs-directory-local-variables][Emacs directory-local variables]]

* Meta
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "meta.el")
:END:
#+begin_src elisp
;;; -*- lexical-binding: t; -*-
#+end_src
** Path hierarchy
#+begin_src elisp
(setq meta--base-dir ".")

(defun meta-get-dir ()
  (concat meta--base-dir
          (when-let ((dirs (org-entry-get (point) "meta-dir" 'inherit)))
            (thread-first dirs (split-string " /") (string-join "/")))))

(defun meta-in-dir (sub-path)
  (concat (meta-get-dir) "/" sub-path))
#+end_src
* Install
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "ebullient/install.scm")
:END:
Run with ~sudo~.
#+begin_src scheme
(define-module (ebullient install)
  #:use-module (guix build-system trivial)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((gnu packages base) #:select (coreutils))
  #:use-module ((gnu packages cryptsetup) #:select (cryptsetup))
  #:use-module ((gnu packages disk) #:select (dosfstools parted))
  #:use-module ((gnu packages linux) #:select (btrfs-progs util-linux+udev))
  #:use-module ((gnu packages package-management) #:select (guix))
  #:use-module (ebullient utils)
  #:export (installer-package))
#+end_src
** Program
#+begin_src scheme
(define* (installer-program #:key
                            os-name
                            efi?
                            boot-label
                            boot-target
                            root-label
                            disk-encryption?
                            luks-label
                            filesystem
                            mountables
                            btrfs-mount-flags
                            btrfs-mount-options)
  (program-file
   "installer"
   #~(begin
       (use-modules ((ice-9 match) #:select (match-lambda))
                    ((ice-9 readline) #:select (readline)))

       (define* (cmd command #:rest args)
         (display (string-join (cons (basename command) args) " "))
         (newline)
         (apply system* (cons command args)))

       (define* (read-user-input prompt #:key default)
         (let ((input (readline (string-append prompt
                                               (if default
                                                   (string-append " (default " default ")") "")
                                               ": "))))
           (if (string-null? input)
               (or default (exit))
               input)))

       (define (user-pause text)
         (readline (string-append text " Press enter to continue.")))

       (define (display-block-devices)
         (display "Block devices:")
         (newline)
         (system* #$(file-append util-linux+udev "/bin/lsblk"))
         (newline))

       (display-block-devices)
       (define device
         (read-user-input "Enter device (for exmple, /dev/sda)"))

       (let ((parted-bin #$(file-append parted "/sbin/parted"))
             (align "optimal")
             (boot-size "1GB"))
         (cmd parted-bin device "mklabel" "gpt")
         (for-each (match-lambda
                     ((label start end)
                      (cmd parted-bin "--align" align device "mkpart" label start end)))
                   `(("sky" "0%" ,boot-size)
                     ("earth" ,boot-size "100%")))
         (cmd parted-bin device "set" "1" (if #$efi? "esp" "bios_grub") "on")
         (for-each (lambda (n)
                     (cmd parted-bin device "align-check" align n))
                   '("1" "2")))
       (user-pause "Check that disks are aligned.")

       (display-block-devices)
       (define boot-partition
         (read-user-input (string-append "Boot partition")
                          #:default (string-append device "1")))
       (define root-partition
         (read-user-input (string-append "Root partition")
                          #:default (string-append device "2")))

       (cmd #$(file-append dosfstools "/sbin/mkfs.fat") "-F" "32" "-n" #$boot-label boot-partition)

       (define system-root
         (if #$disk-encryption?
             (let* ((crypt-name "deciphered-new")
                    (crypt-mapping (string-append "/dev/mapper/" crypt-name))
                    (cryptsetup-bin #$(file-append cryptsetup "/bin/cryptsetup")))
               (cmd cryptsetup-bin "luksFormat" "--type" "luks2" "--pbkdf" "pbkdf2" "--label" #$luks-label root-partition)
               (cmd cryptsetup-bin "open" root-partition crypt-name)
               (cmd cryptsetup-bin "luksUUID" root-partition)
               (user-pause "Take note of your LUKS UUID.")
               crypt-mapping)
             root-partition))

       (case #$filesystem
         ;; ((#:filesystem/ext4)
         ;;  (cmd #$(file-append e2fsprogs "/sbin/mkfs.ext4") "-L" #$root-label system-root))
         ((#:filesystem/btrfs)
          (cmd #$(file-append btrfs-progs "/bin/mkfs.btrfs") "--label" #$root-label system-root)))

       (define mount-dir
         (read-user-input (string-append "Mount directory")
                          #:default "/mnt"))

       (define mount-bin "/run/setuid-programs/mount")
       (define umount-bin "/run/setuid-programs/umount")

       (when (eq? #$filesystem #:filesystem/btrfs)
         (let ((btrfs-bin #$(file-append btrfs-progs "/bin/btrfs")))
           (cmd mount-bin system-root mount-dir)
           (for-each (lambda (subvol)
                       (cmd btrfs-bin "subvolume" "create" (string-append mount-dir "/" subvol)))
                     (map car '#$mountables))
           (cmd umount-bin mount-dir)))

       (let* ((mkdir-bin #$(file-append coreutils "/bin/mkdir"))
              (mkdirp-cmd (lambda (dir)
                            (cmd mkdir-bin "-p" dir))))
         (case #$filesystem
           ;; ((#:filesystem/ext4)
           ;;  (cmd mount-bin system-root mount-dir))
           ((#:filesystem/btrfs)
            (for-each
             (match-lambda
               ((subvol . mount-point)
                (let ((path-on-mount (string-append mount-dir mount-point)))
                  (mkdirp-cmd path-on-mount)
                  (cmd mount-bin "-o"
                       (string-append
                        "subvol=" subvol
                        (let ((opts (append
                                     (or '#$btrfs-mount-options '())
                                     (map (lambda (flag)
                                            (string-replace-substring (symbol->string flag) "-" ""))
                                          (or '#$btrfs-mount-flags '())))))
                          (if (null? opts)
                              ""
                              (string-append "," (string-join opts ",")))))
                       system-root path-on-mount))))
             '#$mountables)))
         (let ((boot-target-on-mount (string-append mount-dir #$boot-target)))
           (mkdirp-cmd boot-target-on-mount)
           (cmd mount-bin boot-partition boot-target-on-mount)))

       (let ((source-dir "/etc/config-source"))
         (cmd #$(file-append guix "/bin/guix") "time-machine"
              (string-append "--channels=" source-dir "/exuberant/channels-lock")
              "--"
              "system"
              (string-append "--load-path=" source-dir)
              "init"
              (string-append source-dir "/exuberant/" #$os-name)
              mount-dir))

       (cmd umount-bin (string-append mount-dir #$boot-target))
       (case #$filesystem
         ;; ((#:filesystem/ext4)
         ;;  (cmd umount-bin mount-dir))
         ((#:filesystem/btrfs)
          (for-each
           (lambda (mount-point)
             (cmd umount-bin (string-append mount-dir mount-point)))
           (map cdr '#$mountables)))))))
#+end_src
** Package
#+begin_src scheme
(define* (installer-package #:rest opts)
  (package
    (inherit blank-package)
    (name "installer")
    (source (apply installer-program opts))
    (build-system trivial-build-system)
    (arguments
     `(#:builder
       ,#~(begin
            (let* ((bin (string-append #$output "/bin")))
              (mkdir #$output)
              (mkdir bin)
              (symlink #$source (string-append bin "/install"))))))))
#+end_src
* System
:PROPERTIES:
:meta-dir+: /ebullient/system
:END:
#+begin_src scheme :tangle (meta-in-dir "../system.scm")
(define-module (ebullient system)
  #:use-module (gnu system)
  #:use-module (gnu system file-systems)
  #:export (blank-os))

(define blank-os
  (operating-system
    (host-name #f)
    (timezone #f)
    (bootloader #f)
    (services '())
    (file-systems %base-file-systems)))
#+end_src
** Components
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "components.scm")
:END:
*** General
#+begin_src scheme
(define-module (ebullient system components)
  #:use-module ((guix hash) #:select (vcs-file?))
  #:use-module ((guix modules) #:select (source-module-closure))
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((guix store) #:select (%default-substitute-urls))
  #:use-module (gnu bootloader)
  #:use-module (gnu bootloader grub)
  #:use-module ((gnu packages certs) #:select (nss-certs))
  #:use-module ((gnu packages fonts) #:select (font-terminus))
  #:use-module ((gnu packages gnupg) #:select (guile-gcrypt))
  #:use-module ((gnu packages linux) #:select (brightnessctl pipewire-0.3))
  #:use-module (gnu services)
  #:use-module (gnu services base)
  #:use-module (gnu services desktop)
  #:use-module ((gnu services networking) #:select (network-manager-service-type))
  #:use-module (gnu services nix)
  #:use-module (gnu services shepherd)
  #:use-module (gnu services sound)
  #:use-module (gnu services xorg)
  #:use-module (gnu system)
  #:use-module (gnu system accounts)
  #:use-module (gnu system file-systems)
  #:use-module (gnu system keyboard)
  #:use-module (gnu system mapped-devices)
  #:use-module ((nongnu packages linux) #:select (linux linux-firmware broadcom-sta broadcom-bt-firmware))
  #:use-module ((nongnu system linux-initrd) #:select (microcode-initrd))
  #:use-module ((rde packages) #:select ((sway-latest . sway)))
  #:use-module ((ebullient packages haskell-apps) #:select (kmonad))
  #:use-module ((ebullient packages wm) #:select (swaylock-effects))
  #:use-module ((ebullient stateless) #:prefix stateless:)
  #:use-module (ebullient utils)
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:use-module ((ice-9 rdelim) #:select (read-string))
  #:use-module ((srfi srfi-1) #:select (any append-map remove iota))
  #:export (source
            base-services
            nss
            linux-nonfree
            accounts
            nonguix-substitutes
            nix
            hidpi-console-font
            kmonad-tool
            desktop-services
            pipewire-multimedia
            network-manager
            bluetooth
            gdm
            gnome-desktop
            wm
            sway-wm
            host-info
            grub-efi
            btrfs
            disk-encryption
            stateless
            console-keyboard-layouts
            macbook
            macbook-kb-layout))

(define-syntax-rule (system-comp os field ...)
  (operating-system
    (inherit os)
    field ...))

(define-syntax define-system-comp
  (lambda (x)
    (syntax-case x ()
      ((_ (name arg ...) field ...)
       (with-syntax ((os (datum->syntax x 'os)))
         #'(define* (name os arg ...)
             (system-comp os field ...)))))))
#+end_src
**** Source
#+begin_src scheme
(define-system-comp (source #:key path)
  (services
   (append
    (operating-system-user-services os)
    (list
     (simple-service
      'config-source
      etc-service-type
      `(("config-source" ,(local-file
                           path
                           #:recursive? #t
                           #:select? (negate vcs-file?)))))))))
#+end_src
**** Base services
#+begin_src scheme
(define-system-comp (base-services)
  (services
   (append %base-services
           (operating-system-user-services os))))
#+end_src
**** NSS
#+begin_src scheme
(define-system-comp (nss)
  (packages
   (cons* nss-certs
          (operating-system-packages os))))
#+end_src
**** Linux nonfree
#+begin_src scheme
(define-system-comp (linux-nonfree)
  (kernel linux)
  (initrd microcode-initrd)
  (firmware (cons* linux-firmware
                   (operating-system-firmware os))))
#+end_src
**** Accounts
#+begin_src scheme
(define-system-comp (accounts #:key users-info)
  (users
   (append
    (operating-system-users os)
    (map (lambda (user-info)
           (apply account (append-map
                           (match-lambda
                             ((k . v)
                              (list k v)))
                           user-info)))
         users-info))))

(define* (account #:key
                  name
                  comment
                  shell
                  admin?
                  password
                  salt)
  (user-account
   (name name)
   (comment (or comment ""))
   (group "users")
   (supplementary-groups (append '("netdev" "audio" "video")
                                 (if admin? '("wheel") '())))
   (shell (case shell
            ;; ((#:shell/bash) (file-append bash "/bin/bash"))
            ;; ((#:shell/zsh) (file-append zsh "/bin/zsh"))
            (else (default-shell))))
   (password (if password
                 (crypt password (or salt "toosimple"))
                 #f))))
#+end_src
**** Nonguix substitutes
This could be done using the new [[https://github.com/guix-mirror/guix/commit/fcad6226486b52e5d45531f60811d35eac34fa67][guix-extension]] but it works fine now so I won't change it.
#+begin_src scheme
(define-system-comp (nonguix-substitutes)
  (services
   (modify-services (operating-system-user-services os)
     (guix-service-type
      config =>
      (guix-configuration
       (inherit config)
       (substitute-urls
        (append (guix-configuration-substitute-urls config)
                (list "https://substitutes.nonguix.org")))
       (authorized-keys
        (append (guix-configuration-authorized-keys config)
                (list (local-file "substitutes.nonguix.org.pub")))))))))
#+end_src
***** Signing key
#+begin_src scheme :tangle (meta-in-dir "substitutes.nonguix.org.pub")
(public-key
 (ecc
  (curve Ed25519)
  (q #C1FD53E5D4CE971933EC50C9F307AE2171A2D3B52C804642A7A35F84F3A4EA98#)))
#+end_src
**** Nix
#+begin_src scheme
(define-system-comp (nix)
  (services
   (cons* (service nix-service-type)
          (operating-system-user-services os))))
#+end_src
**** Console
***** HiDPI console font
#+begin_src scheme
(define-system-comp (hidpi-console-font)
  (services
   (modify-services (operating-system-user-services os)
     (console-font-service-type
      config =>
      (map (lambda (tty-and-font)
             (cons (car tty-and-font)
                   (file-append font-terminus "/share/consolefonts/ter-132n")))
           config)))))
#+end_src
***** KMonad
Must succeed "Accounts" component.
#+begin_src scheme
(define-system-comp (kmonad-tool #:key who)
  (packages
   (cons* kmonad
          (operating-system-packages os)))
  (users
   (map (lambda (account)
          (if (member (user-account-name account) who)
              (user-account
               (inherit account)
               (supplementary-groups (append (user-account-supplementary-groups account)
                                             '("input"))))
              account))
        (operating-system-users os)))
  (services
   (cons* (udev-rules-service 'kmonad-add-udev-rules kmonad)
          (operating-system-user-services os))))
#+end_src
**** Desktop
#+begin_src scheme
(define (remove-services services kinds)
  (remove (lambda (s)
            (member (service-kind s) kinds))
          services))
#+end_src
***** Desktop services
#+begin_src scheme
(define-system-comp (desktop-services)
  (services
   (append
    (operating-system-user-services os)
    (remove-services
     %desktop-services
     (append (map service-kind %base-services)
             (list network-manager-service-type
                   gdm-service-type
                   screen-locker-service-type))))))
#+end_src
***** Pipewire
#+begin_src scheme
(define-system-comp (pipewire-multimedia)
  (services
   (as-> (operating-system-user-services os) $
         (remove-services $ (list pulseaudio-service-type
                                  alsa-service-type))
         (cons* (udev-rules-service 'pipewire-add-udev-rules
                                    pipewire-0.3)
                $))))
#+end_src
***** Network
****** Network manager
#+begin_src scheme
(define-system-comp (network-manager #:key stateless?)
  (services
   (append
    (operating-system-user-services os)
    (list
     (service network-manager-service-type))
    (if stateless?
        (list
         (simple-service
          'network-manager-stateless
          stateless-service-type
          '((#:state . (((#:path . "/etc/NetworkManager/system-connections/")
                         (#:store . #:machine))
                        ((#:path . "/var/lib/NetworkManager/secret_key")
                         (#:store . #:machine)
                         (#:parent-dir-perms . ((#:mode . #o700)))))))))
        '()))))
#+end_src
***** Bluetooth
#+begin_src scheme
(define-system-comp (bluetooth #:key
                               who
                               stateless?)
  (users
   (map (lambda (account)
          (if (member (user-account-name account) who)
              (user-account
               (inherit account)
               (supplementary-groups (append (user-account-supplementary-groups account)
                                             '("lp"))))
              account))
        (operating-system-users os)))
  (services
   (append
    (operating-system-user-services os)
    ;; (list
    ;;  (bluetooth-service #:auto-enable? #t))
    (if stateless?
        (list
         (simple-service
          'bluetooth-stateless
          stateless-service-type
          '((#:state . (((#:path . "/var/lib/bluetooth/")
                         (#:store . #:machine)
                         (#:mode . #o700)))))))
        '()))))
#+end_src
***** Display managers
****** GDM
#+begin_src scheme
(define-system-comp (gdm #:key
                         (wayland? #t)
                         auto-login)
  (services
   (cons* (service gdm-service-type
                   (gdm-configuration
                    (auto-login? (if auto-login #t #f))
                    (default-user auto-login)
                    (wayland? wayland?)))
          (operating-system-user-services os))))
#+end_src
***** Desktop environments
****** Gnome
#+begin_src scheme
(define-system-comp (gnome-desktop)
  (services
   (cons* (service gnome-desktop-service-type)
          (operating-system-user-services os))))
#+end_src
***** Window managers
#+begin_src scheme
(define-system-comp (wm #:key package services)
  (packages
   (cons* package
          (operating-system-packages os)))
  (services
   (append services
           (operating-system-user-services os))))
#+end_src
****** Sway
#+begin_src scheme
(define* (sway-wm os)
  (wm os
      #:package sway
      #:services (cons* swaylock-service
                        (list brightnessctl-udev-rules))))
#+end_src
***** Screen lockers
****** Swaylock
#+begin_src scheme
(define swaylock-service
  (screen-locker-service swaylock-effects "swaylock"))
#+end_src
***** Backlight
****** Brightnessctl
#+begin_src scheme
(define brightnessctl-udev-rules
  (udev-rules-service 'brightnessctl-add-udev-rules brightnessctl))
#+end_src
*** Device-specific
**** Host
#+begin_src scheme
(define-system-comp (host-info #:key
                               host-name
                               timezone
                               locale)
  (host-name host-name)
  (timezone timezone)
  (locale (or locale "en_US.utf8")))
#+end_src
**** File systems and boot
***** Bootloader
****** Grub
#+begin_src scheme
;; ...
#+end_src
****** Grub EFI
#+begin_src scheme
(define-system-comp (grub-efi #:key
                              label
                              target)
  (bootloader (bootloader-configuration
               (bootloader grub-efi-bootloader)
               (targets (list target))
               (timeout 1)))
  (file-systems
   (cons* (file-system
            (device (file-system-label label))
            (mount-point target)
            (type "vfat"))
          (operating-system-file-systems os))))
#+end_src
***** File systems
****** Ext4
#+begin_src scheme
;; (define-system-comp (ext4 #:key label)
;;   (file-systems
;;    (cons* (file-system
;;             (device (file-system-label label))
;;             (mount-point "/")
;;             (type "ext4"))
;;           (operating-system-file-systems os))))
#+end_src
****** Btrfs
#+begin_src scheme
(define-system-comp (btrfs #:key
                           label
                           subvols
                           flags
                           options)
  (file-systems
   (append
    (map (match-lambda
           ((subvol . mount-point)
            (file-system
              (device (file-system-label label))
              (mount-point mount-point)
              (type "btrfs")
              (flags (or flags '()))
              (options (string-append
                        "subvol=" subvol
                        (if options
                            (string-append "," (string-join options ","))
                            ""))))))
         subvols)
    (operating-system-file-systems os))))
#+end_src
***** Disk encryption
Must succeed "File systems" component.
#+begin_src scheme
(define* (disk-encryption os
                          #:key
                          label
                          source-uuid
                          (target "deciphered")
                          encrypted-mount-points)
  (let ((encrypted-device (mapped-device
                           (source (uuid source-uuid))
                           (targets (list target))
                           (type luks-device-mapping))))
    (system-comp
     os
     (mapped-devices
      (cons* encrypted-device
             (operating-system-mapped-devices os)))
     (file-systems
      (map (lambda (fs)
             (if (member (file-system-mount-point fs) encrypted-mount-points)
                 (file-system
                   (inherit fs)
                   (dependencies (cons* encrypted-device
                                        (file-system-dependencies fs))))
                 fs))
           (operating-system-file-systems os))))))
#+end_src
***** Stateless
Must succeed "File systems" and "Accounts" components. To be useful, the stateless service's activation must come before that of other services that create state (to this end the ~stateless-service-type~ is appended, not prepended, to operating system services) and including this component after /all/ others is the safest play.
#+begin_src scheme
(define-system-comp (stateless #:key
                               persist-dir
                               machine-dir
                               who)
  (file-systems
   (->> (operating-system-file-systems os)
        (cons* (file-system
                 (device ":/root") ; HACK Guix boot will hang forever waiting for a device to appear even though this is a tmpfs. Fake it out by using a name that looks like an NFS device (see `canonicalize-device-spec'). Thus the ":/" is necessary but the name is otherwise arbitrary.
                 (mount-point "/")
                 (type "tmpfs")
                 (check? #f)))
        (map (lambda (fs)
               (if (member (file-system-mount-point fs)
                           `("/var/guix"
                             ,persist-dir
                             ,machine-dir))
                   (file-system
                     (inherit fs)
                     (needed-for-boot? #t))
                   fs)))))
  (users
   (map (lambda (account)
          (if (member (user-account-name account) (map car who))
              (user-account
               (inherit account)
               (create-home-directory? #f))
              account))
        (operating-system-users os)))
  (services
   (append
    (operating-system-user-services os)
    (list
     (service stateless-service-type
              `((#:persist-dir . ,persist-dir)
                (#:machine-dir . ,machine-dir)
                (#:homes . ,(->> users
                                 (filter (lambda (account)
                                           (member (user-account-name account) (map car who))))
                                 (map (lambda (account)
                                        `(,(user-account-name account) . ,(user-account-home-directory account))))))
                (#:hes . ,who)))
     (simple-service
      'stateless-system-state
      stateless-service-type
      '((#:state . (((#:path . "/etc/machine-id")
                     (#:store . #:machine))
                    ((#:path . "/var/lib/random-seed")
                     (#:store . #:machine))
                    ((#:path . "/etc/guix/signing-key.pub")
                     (#:store . #:machine)
                     (#:parent-dir-perms . ((#:mode . #o111))))
                    ((#:path . "/etc/guix/signing-key.sec")
                     (#:store . #:machine)
                     (#:parent-dir-perms . ((#:mode . #o111))))))))))))
#+end_src
****** Service
******* Populate
#+begin_src scheme
(define (populate-gexp log-state-dir)
  (with-extensions (list guile-gcrypt)
    (with-imported-modules (source-module-closure
                            '((guix build utils)
                              (gnu build install)))
      #~(begin
          (use-modules ((guix build utils) #:select (mkdir-p))
                       ((gnu build install) #:select (populate-root-file-system)))

          (let* ((system-path "/var/guix/profiles/system")
                 (system-1-path "/var/guix/profiles/system-1-link")
                 (system-1-exists? (file-exists? system-1-path))
                 (system-link (readlink system-path))
                 (system-1-link (if system-1-exists?
                                    (readlink system-1-path)
                                    system-link)))
            (populate-root-file-system system-1-link ""
                                       #:extras `((,system-path -> ,system-link)))
            (unless system-1-exists?
              (delete-file system-1-path)))

          (let* ((dir "/var/log")
                 (state-dir (string-append #$log-state-dir dir)))
            (rmdir dir) ; It already exists, created by `populate-root-file-system'.
            (mkdir-p state-dir)
            (symlink state-dir dir))))))
#+end_src
******* Users
#+begin_src scheme
(define (user-homes-shepherd-service user-homes state-dirs)
  (shepherd-service
   (provision '(stateless-user-homes))
   (requirement '(file-systems))
   (one-shot? #t)
   (start (with-imported-modules '((guix build utils))
            #~(lambda ()
                (let ((mkdirp-user-home
                       (lambda (dir uid gid)
                         (mkdir-p dir)
                         (chmod dir #o700)
                         (chown dir uid gid))))
                  (for-each
                   (lambda (user-home)
                     (let* ((pw (getpwnam (car user-home)))
                            (uid (passwd:uid pw))
                            (gid (passwd:gid pw))
                            (home (cdr user-home)))
                       (mkdirp-user-home home uid gid)
                       (for-each
                        (lambda (state-dir)
                          (mkdirp-user-home (string-append state-dir home) uid gid))
                        '#$state-dirs)))
                   '#$user-homes))
                #t)))))

(define (activate-home-shepherd-services hes)
  (let ((svc
         (lambda (user he)
           (shepherd-service
            (provision (list (symbol-append 'stateless-home- (string->symbol user))))
            (requirement '(stateless-user-homes))
            (one-shot? #t)
            (start #~(make-forkexec-constructor
                      '(#$(file-append he "/activate"))
                      #:user #$user
                      #:group (group:name (getgrgid (passwd:gid (getpw #$user))))
                      #:log-file (string-append "/var/log/stateless-home-" #$user ".log")
                      #:environment-variables
                      (list (string-append "HOME=" (passwd:dir (getpw #$user))))))
            (stop #~(make-kill-destructor))))))
    (map (match-lambda
           ((user . he)
            (svc user he)))
         hes)))
#+end_src
******* Service type
#+begin_src scheme
(define stateless-service-type
  (service-type
   (name 'stateless)
   (extensions
    (list (service-extension boot-service-type
                             (lambda (config)
                               (populate-gexp (assoc-ref config #:machine-dir))))
          (service-extension activation-service-type
                             (lambda (config)
                               (stateless:activate-gexp
                                `',(assoc-ref config #:state)
                                ""
                                (assoc-ref config #:persist-dir)
                                (assoc-ref config #:machine-dir))))
          (service-extension shepherd-root-service-type
                             (lambda (config)
                               (cons* (user-homes-shepherd-service
                                       (assoc-ref config #:homes)
                                       (list
                                        (assoc-ref config #:persist-dir)
                                        (assoc-ref config #:machine-dir)))
                                      (activate-home-shepherd-services
                                       (assoc-ref config #:hes)))))
          (service-extension profile-service-type
                             (lambda (config)
                               (list (stateless:diff-tool-package
                                      "stateless-diff"
                                      `',(assoc-ref config #:state)
                                      `',(assoc-ref config #:ignore)
                                      "/"
                                      (assoc-ref config #:persist-dir)
                                      (assoc-ref config #:machine-dir)))))))
   (compose identity)
   (extend stateless:extend-proc)
   (description "Initialize a stateless system.")))
#+end_src
*** Hardware-specific
**** Console
***** Console keyboard layouts
Must succeed "Bootloader" component.
#+begin_src scheme
(define-system-comp (console-keyboard-layouts #:key kb-layout)
  (keyboard-layout kb-layout)
  (bootloader (bootloader-configuration
               (inherit (operating-system-bootloader os))
               (keyboard-layout kb-layout))))
#+end_src
**** Macbook
#+begin_src scheme
(define* (macbook os #:key bluetooth?)
  (-> os
      (macbook-wireless #:bluetooth? bluetooth?)
      macbook-power-key))
#+end_src
***** Wireless
I'm not sure if this requires the nonfree linux kernel and/or if the blacklist refers to kernel modules not present in linux-libre.
#+begin_src scheme
(define-system-comp (macbook-wireless #:key bluetooth?)
  (kernel-arguments (with-blacklist (operating-system-user-kernel-arguments os)
                                    "b43,b43legacy,ssb,bcm43xx,brcm80211,brcmfmac,brcmsmac,bcma"))
  (kernel-loadable-modules (cons* (broadcom-with-patch-updates broadcom-sta)
                                  (operating-system-kernel-loadable-modules os)))
  (firmware (append
             (if bluetooth? (list broadcom-bt-firmware) '())
             (operating-system-firmware os))))

(define (with-blacklist kernel-args new)

  (define blacklist-param "modprobe.blacklist")
  (define (blacklist? ka)
    (string-prefix? blacklist-param ka))

  (if (any blacklist? kernel-args)
      (map (lambda (arg)
             (if (blacklist? arg)
                 (string-append arg "," new)
                 arg))
           kernel-args)
      (cons* (string-append blacklist-param "=" new) kernel-args)))
#+end_src
****** Broadcom STA
#+begin_src scheme
(define-public (broadcom-with-patch-updates broadcom)
  (package
    (inherit broadcom)
    (source
     (origin
       (inherit (package-source broadcom))
       (patches
        (append
         (-> broadcom package-source origin-patches)
         (list
          "/.persist/home/pharcosyle/phrenetic_for_now/ebullient/system/patches/broadcom-sta-linux-5.17.patch"
          "/.persist/home/pharcosyle/phrenetic_for_now/ebullient/system/patches/broadcom-sta-linux-5.18.patch"
          "/.persist/home/pharcosyle/phrenetic_for_now/ebullient/system/patches/broadcom-sta-pedantic-fix.patch")))))))
#+end_src
******* Patches
:PROPERTIES:
:meta-dir+: /patches
:VISIBILITY: content
:END:
******** Linux 5.17
#+begin_src diff :tangle (meta-in-dir "broadcom-sta-linux-5.17.patch")
From 31b7849092c43805c7fbaf7518b99874aa1b310c Mon Sep 17 00:00:00 2001
From: Joan Bruguera <joanbrugueram@gmail.com>
Date: Wed, 12 Jan 2022 20:49:20 +0100
Subject: [PATCH] Tentative fix for broadcom-wl 6.30.223.271 driver for Linux 5.17-rc1

Set netdev->dev_addr through dev_addr_mod + PDE_DATA fix

Since Linux 5.17 netdev->dev_addr is const and must be changed through
dev_addr_mod, otherwise a warning is logged in dmesg and bad things may happen.

NB: The #if is not wrong, dev_addr_mod is defined since Linux 5.15-rc1

Plus a trivial fix for PDE_DATA.

Applies on top of all the patches applied to broadcom-wl-dkms 6.30.223.271-28 on Arch Linux.

See also: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=adeef3e32146a8d2a73c399dc6f5d76a449131b1
          https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=359745d78351c6f5442435f81549f0207ece28aa
---
 src/wl/sys/wl_linux.c | 16 +++++++++++++---
 1 file changed, 13 insertions(+), 3 deletions(-)

diff --git a/src/wl/sys/wl_linux.c b/src/wl/sys/wl_linux.c
index e491df7..e4614fb 100644
--- a/src/wl/sys/wl_linux.c
+++ b/src/wl/sys/wl_linux.c
@@ -93,6 +93,10 @@ struct iw_statistics *wl_get_wireless_stats(struct net_device *dev);
 
 #include <wlc_wowl.h>
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0))
+#define PDE_DATA pde_data
+#endif
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
 static void wl_timer(struct timer_list *tl);
 #else
@@ -490,6 +494,12 @@ wl_if_setup(struct net_device *dev)
 #endif
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0)
+static inline void eth_hw_addr_set(struct net_device *dev, const void *addr) {
+	memcpy(dev->dev_addr, addr, ETHER_ADDR_LEN);
+}
+#endif
+
 static wl_info_t *
 wl_attach(uint16 vendor, uint16 device, ulong regs,
 	uint bustype, void *btparam, uint irq, uchar* bar1_addr, uint32 bar1_size)
@@ -634,7 +644,7 @@ wl_attach(uint16 vendor, uint16 device, ulong regs,
 			WL_ERROR(("wl%d: Error setting MAC ADDRESS\n", unit));
 	}
 #endif 
-	bcopy(&wl->pub->cur_etheraddr, dev->dev_addr, ETHER_ADDR_LEN);
+	eth_hw_addr_set(dev, wl->pub->cur_etheraddr.octet);
 
 	online_cpus = 1;
 
@@ -1835,7 +1845,7 @@ wl_set_mac_address(struct net_device *dev, void *addr)
 
 	WL_LOCK(wl);
 
-	bcopy(sa->sa_data, dev->dev_addr, ETHER_ADDR_LEN);
+	eth_hw_addr_set(dev, sa->sa_data);
 	err = wlc_iovar_op(wl->wlc, "cur_etheraddr", NULL, 0, sa->sa_data, ETHER_ADDR_LEN,
 		IOV_SET, (WL_DEV_IF(dev))->wlcif);
 	WL_UNLOCK(wl);
@@ -3010,7 +3020,7 @@ _wl_add_monitor_if(wl_task_t *task)
 	else
 		dev->type = ARPHRD_IEEE80211_RADIOTAP;
 
-	bcopy(wl->dev->dev_addr, dev->dev_addr, ETHER_ADDR_LEN);
+	eth_hw_addr_set(dev, wl->dev->dev_addr);
 
 #if defined(WL_USE_NETDEV_OPS)
 	dev->netdev_ops = &wl_netdev_monitor_ops;
-- 
2.35.1

#+end_src
******** Linux 5.18
#+begin_src diff :tangle (meta-in-dir "broadcom-sta-linux-5.18.patch")
diff -u -r a/src/shared/linux_osl.c b/src/shared/linux_osl.c
--- a/src/shared/linux_osl.c	2022-05-24 20:51:15.662604980 +0000
+++ b/src/shared/linux_osl.c	2022-05-24 21:13:38.264472425 +0000
@@ -599,6 +599,8 @@
 	va = kmalloc(size, GFP_ATOMIC | __GFP_ZERO);
 	if (va)
 		,*pap = (ulong)__virt_to_phys(va);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	va = dma_alloc_coherent(&((struct pci_dev *)osh->pdev)->dev, size, (dma_addr_t*)pap, GFP_ATOMIC);
 #else
 	va = pci_alloc_consistent(osh->pdev, size, (dma_addr_t*)pap);
 #endif
@@ -612,6 +614,8 @@
 
 #ifdef __ARM_ARCH_7A__
 	kfree(va);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	dma_free_coherent(&((struct pci_dev *)osh->pdev)->dev, size, va, (dma_addr_t)pa);
 #else
 	pci_free_consistent(osh->pdev, size, va, (dma_addr_t)pa);
 #endif
@@ -623,7 +627,11 @@
 	int dir;
 
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	dir = (direction == DMA_TX)? DMA_TO_DEVICE: DMA_FROM_DEVICE;
+#else
 	dir = (direction == DMA_TX)? PCI_DMA_TODEVICE: PCI_DMA_FROMDEVICE;
+#endif
 
 #if defined(__ARM_ARCH_7A__) && defined(BCMDMASGLISTOSL)
 	if (dmah != NULL) {
@@ -641,7 +649,11 @@
 				ASSERT(totsegs + nsegs <= MAX_DMA_SEGS);
 				sg->page_link = 0;
 				sg_set_buf(sg, PKTDATA(osh, skb), PKTLEN(osh, skb));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+				dma_map_single(&((struct pci_dev *)osh->pdev)->dev, PKTDATA(osh, skb), PKTLEN(osh, skb), dir);
+#else
 				pci_map_single(osh->pdev, PKTDATA(osh, skb), PKTLEN(osh, skb), dir);
+#endif
 			}
 			totsegs += nsegs;
 			totlen += PKTLEN(osh, skb);
@@ -656,7 +668,11 @@
 	}
 #endif 
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	return (dma_map_single(&((struct pci_dev *)osh->pdev)->dev, va, size, dir));
+#else
 	return (pci_map_single(osh->pdev, va, size, dir));
+#endif
 }
 
 void BCMFASTPATH
@@ -665,8 +681,13 @@
 	int dir;
 
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	dir = (direction == DMA_TX)? DMA_TO_DEVICE: DMA_FROM_DEVICE;
+	dma_unmap_single(&((struct pci_dev *)osh->pdev)->dev, (uint32)pa, size, dir);
+#else
 	dir = (direction == DMA_TX)? PCI_DMA_TODEVICE: PCI_DMA_FROMDEVICE;
 	pci_unmap_single(osh->pdev, (uint32)pa, size, dir);
+#endif
 }
 
 #if defined(BCMDBG_ASSERT)
#+end_src
******** Pedantic fix
#+begin_src diff :tangle (meta-in-dir "broadcom-sta-pedantic-fix.patch")
diff --git a/src/shared/linux_osl.c b/shared/linux_osl.c
index 711b771..5a2636a 100644
--- a/src/shared/linux_osl.c
+++ b/src/shared/linux_osl.c
@@ -1105,7 +1105,7 @@ osl_os_get_image_block(char *buf, int len, void *image)
 	if (!image)
 		return 0;
 
-	rdlen = kernel_read(fp, fp->f_pos, buf, len);
+	rdlen = kernel_read(fp, (void *)fp->f_pos, (size_t)len, (loff_t *)buf);
 	if (rdlen > 0)
 		fp->f_pos += rdlen;
 
diff --git a/src/wl/sys/wl_cfg80211_hybrid.c b/wl/sys/wl_cfg80211_hybrid.c
index 41c16d8..d39d9de 100644
--- a/src/wl/sys/wl_cfg80211_hybrid.c
+++ b/src/wl/sys/wl_cfg80211_hybrid.c
@@ -790,6 +790,7 @@ wl_set_auth_type(struct net_device *dev, struct cfg80211_connect_params *sme)
 		break;
 	case NL80211_AUTHTYPE_NETWORK_EAP:
 		WL_DBG(("network eap\n"));
+		break;
 	default:
 		val = 2;
 		WL_ERR(("invalid auth type (%d)\n", sme->auth_type));
@@ -2347,21 +2348,20 @@ wl_bss_roaming_done(struct wl_cfg80211_priv *wl, struct net_device *ndev,
                     const wl_event_msg_t *e, void *data)
 {
 	struct wl_cfg80211_connect_info *conn_info = wl_to_conn(wl);
+	s32 err = 0;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
 	struct cfg80211_bss *bss;
 	struct wlc_ssid *ssid;
+	struct cfg80211_roam_info roam_info;
 	ssid = &wl->profile->ssid;
 	bss = cfg80211_get_bss(wl_to_wiphy(wl), NULL, (s8 *)&wl->bssid,
 	ssid->SSID, ssid->SSID_len, WLAN_CAPABILITY_ESS, WLAN_CAPABILITY_ESS);
-	struct cfg80211_roam_info roam_info = {
-		.bss = bss,
-		.req_ie = conn_info->req_ie,
-		.req_ie_len = conn_info->req_ie_len,
-		.resp_ie = conn_info->resp_ie,
-		.resp_ie_len = conn_info->resp_ie_len,
-	};
+	roam_info.bss = bss;
+	roam_info.req_ie = conn_info->req_ie;
+	roam_info.req_ie_len = conn_info->req_ie_len;
+	roam_info.resp_ie = conn_info->resp_ie;
+	roam_info.resp_ie_len = conn_info->resp_ie_len;
 #endif
-	s32 err = 0;
 
 	wl_get_assoc_ies(wl);
 	memcpy(wl->profile->bssid, &e->addr, ETHER_ADDR_LEN);
diff --git a/src/wl/sys/wl_iw.h b/wl/sys/wl_iw.h
index 3ab084f..471d11f 100644
--- a/src/wl/sys/wl_iw.h
+++ b/src/wl/sys/wl_iw.h
@@ -70,7 +70,6 @@ struct cntry_locales_custom {
 #define	WL_IW_RSSI_EXCELLENT	-57	
 #define	WL_IW_RSSI_INVALID	 0	
 #define MAX_WX_STRING 80
-#define isprint(c) bcm_isprint(c)
 #define WL_IW_SET_ACTIVE_SCAN	(SIOCIWFIRSTPRIV+1)
 #define WL_IW_GET_RSSI			(SIOCIWFIRSTPRIV+3)
 #define WL_IW_SET_PASSIVE_SCAN	(SIOCIWFIRSTPRIV+5)
diff --git a/src/wl/sys/wl_linux.c b/wl/sys/wl_linux.c
index d13fb98..97ae2a6 100644
--- a/src/wl/sys/wl_linux.c
+++ b/src/wl/sys/wl_linux.c
@@ -797,14 +797,15 @@ wl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	pci_read_config_dword(pdev, 0x40, &val);
 	if ((val & 0x0000ff00) != 0)
 		pci_write_config_dword(pdev, 0x40, val & 0xffff00ff);
-		bar1_size = pci_resource_len(pdev, 2);
-		#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
-		bar1_addr = (uchar *)ioremap(pci_resource_start(pdev, 2),
-			bar1_size);
-		#else
-		bar1_addr = (uchar *)ioremap_nocache(pci_resource_start(pdev, 2),
-			bar1_size);
-		#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0) */
+
+	bar1_size = pci_resource_len(pdev, 2);
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+	bar1_addr = (uchar *)ioremap(pci_resource_start(pdev, 2),
+		bar1_size);
+	#else
+	bar1_addr = (uchar *)ioremap_nocache(pci_resource_start(pdev, 2),
+		bar1_size);
+	#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0) */
 	wl = wl_attach(pdev->vendor, pdev->device, pci_resource_start(pdev, 0), PCI_BUS, pdev,
 		pdev->irq, bar1_addr, bar1_size);
 
#+end_src
***** Power key
Make the power key suspend instead of power off. It's part of the keyboard on MacBooks and too easy to press by accident. This is also the behavior on macOS.
#+begin_src scheme
(define-system-comp (macbook-power-key)
  (services
   (modify-services (operating-system-user-services os)
     (elogind-service-type
      config =>
      (elogind-configuration
       (inherit config)
       (handle-power-key 'suspend))))))
#+end_src
***** Keyboard layout
#+begin_src scheme
(define macbook-kb-layout
  (keyboard-layout "us" #:model "macbook78"))
#+end_src
* Home
:PROPERTIES:
:meta-dir+: /ebullient/home
:END:
#+begin_src scheme :tangle (meta-in-dir "../home.scm")
(define-module (ebullient home)
  #:use-module (gnu home)
  #:use-module (gnu services)
  #:export (create-he))

(define (create-he services)
  (home-environment
   (services
    (filter service? services))))
#+end_src
** Components
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "components.scm")
:END:
#+begin_src scheme
(define-module (ebullient home components)
  #:use-module (guix gexp)
  #:use-module (gnu home services)
  #:use-module (gnu home services shells)
  #:use-module (gnu home services shepherd)
  #:use-module (gnu home services ssh)
  #:use-module (gnu home services xdg)
  #:use-module (gnu home-services terminals)
  #:use-module (gnu home-services version-control)
  #:use-module ((gnu packages compression) #:select (zip unzip))
  #:use-module ((gnu packages curl) #:select (curl))
  #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages fonts) #:select (font-iosevka-aile font-iosevka-etoile font-liberation font-gnu-unifont font-awesome))
  #:use-module ((gnu packages freedesktop) #:select (udiskie xdg-utils xdg-user-dirs desktop-file-utils xdg-desktop-portal xdg-desktop-portal-wlr))
  #:use-module ((gnu packages glib) #:select (dbus))
  #:use-module ((gnu packages gnome) #:select (dconf network-manager-applet))
  #:use-module ((gnu packages gnome-xyz) #:select (arc-theme))
  #:use-module ((gnu packages image) #:select (grim slurp swappy))
  #:use-module ((gnu packages linux) #:select (brightnessctl psmisc pipewire-0.3 wireplumber))
  #:use-module ((gnu packages music) #:select (playerctl))
  #:use-module ((gnu packages package-management) #:select (flatpak))
  #:use-module ((gnu packages pulseaudio) #:select (pulseaudio pavucontrol))
  #:use-module ((gnu packages qt) #:select (qtwayland))
  #:use-module ((gnu packages rust-apps) #:select (swayhide))
  #:use-module ((gnu packages shells) #:select (zsh))
  #:use-module ((gnu packages shellutils) #:select (direnv))
  #:use-module ((gnu packages terminals) #:select (alacritty))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module ((gnu packages web) #:select (jq))
  #:use-module ((gnu packages wm) #:select (mako swayidle waybar))
  #:use-module ((gnu packages xdisorg) #:select (gammastep rofi wl-clipboard))
  #:use-module (gnu services)
  #:use-module (gnu services shepherd)
  #:use-module (gnu system keyboard)
  #:use-module (rde home services wm)
  #:use-module (rde home services xdisorg)
  #:use-module ((rde packages) #:select (rofi-wayland (sway-latest . sway)))
  #:use-module ((rde packages fonts) #:select (font-noto-color-emoji))
  #:use-module ((rde serializers elisp) #:select (serialize-elisp-config))
  #:use-module ((rde serializers ini) #:select (serialize-ini-config))
  #:use-module ((ebullient home packages doom-emacs) #:select (doom-emacs))
  #:use-module ((ebullient home packages emacs) #:select (emacs-fully-loaded-pgtk))
  #:use-module ((ebullient home packages fonts) #:select (font-adobe-source-code-pro))
  #:use-module ((ebullient packages haskell-apps) #:select (kmonad))
  #:use-module ((ebullient packages wm) #:select (swaylock-effects))
  #:use-module ((ebullient stateless) #:prefix stateless:)
  #:use-module (ebullient utils)
  #:use-module ((srfi srfi-1) #:select (append-map))
  #:export (he-packages
            he-stateless
            he-shells
            he-nix
            he-emacs
            he-doom
            he-git
            he-ssh
            he-direnv
            he-fonts
            font-mono
            font-sans
            font-serif
            font-unicode
            he-kmonad
            he-xdg
            he-mesa
            he-gtk
            he-desktop-packages
            he-pipewire
            he-flatpak
            he-gdm
            he-wm-common
            he-sway
            he-swaylock
            swaylock-screen-locker
            he-swayidle
            swayidle-idle-manager
            he-mako
            he-waybar
            he-rofi
            rofi-menu
            rofi-application-launcher
            he-alacritty
            alacritty-terminal))

(define stateless-ensure-profiles-gexp
  (with-imported-modules '((guix build utils))
    #~(lambda (profiles)
        (use-modules ((guix build utils) #:select (mkdir-p)))

        (let ((no-follow-file-exists? (lambda (file)
                                        (false-if-exception (lstat file)))))
          (for-each
           (lambda (i)
             (let ((link (car i))
                   (profile (cdr i)))
               (when (and (no-follow-file-exists? profile)
                          (not (no-follow-file-exists? link)))
                 (mkdir-p (dirname link))
                 (symlink profile link))))
           profiles)))))
#+end_src
*** Packages
#+begin_src scheme
(define* (he-packages #:key
                      (packages (list curl
                                      zip
                                      unzip)))
  (list
   (simple-service
    'packages-add-packages
    home-profile-service-type
    packages)))
#+end_src
*** Stateless
#+begin_src scheme
(define* (he-stateless #:key
                       persist-dir
                       machine-dir
                       (extra-state '(((#:path . "org/")
                                       (#:store . #:persist))
                                      ((#:path . "work/")
                                       (#:store . #:persist)))))
  (append
   (list
    (service home-stateless-service-type
             `((#:persist-dir . ,persist-dir)
               (#:machine-dir . ,machine-dir))))

   (let ((guix-profile ".guix-profile")
         (guix-current "guix/current"))
     (list
      (simple-service
       'stateless-home-state
       home-stateless-service-type
       `((#:state . ,(append
                      '(((#:path . (#:xdg-base "XDG_LOG_HOME"))
                         (#:store . #:machine))
                        ((#:path . ("Trash/" #:xdg-base "XDG_DATA_HOME"))
                         (#:store . #:machine)
                         (#:mode . #o700))
                        ((#:path . ("guix/" #:xdg-base "XDG_CACHE_HOME"))
                         (#:store . #:machine))
                        ((#:path . ("guile/" #:xdg-base "XDG_CACHE_HOME"))
                         (#:store . #:machine)))
                      extra-state))
         (#:ignore . ,(list ".guix-home"
                            guix-profile
                            `(,guix-current #:xdg-base "XDG_CONFIG_HOME")))))

      (simple-service
       'stateless-guix-ensure-profiles
       home-activation-service-type
       #~(#$stateless-ensure-profiles-gexp
          (let ((user-profiles-dir (string-append "/var/guix/profiles/per-user/" (passwd:name (getpwuid (getuid))))))
            `((,(string-append (getenv "HOME") "/" #$guix-profile) . ,(string-append user-profiles-dir "/guix-profile"))
              (,(string-append (getenv "XDG_CONFIG_HOME") "/" #$guix-current) . ,(string-append user-profiles-dir "/current-guix"))))))))

   (stateless-skeletons)))
#+end_src
**** Service
***** Diff tool
#+begin_src scheme
(define guix-home-files
  (with-imported-modules '((guix build utils))
    #~(begin
        (use-modules ((guix build utils) #:select (find-files)))

        (let ((home-files
               (let* ((home-dir (getenv "HOME"))
                      (guix-home-dir (string-append
                                      home-dir "/.guix-home/" #$home-files-directory "/")))
                 (map (lambda (file)
                        (string-append
                         home-dir
                         (string-drop file (string-length guix-home-dir))))
                      (find-files guix-home-dir)))))
          (make-known home-files symlink-to-store?)))))
#+end_src
***** Service type
#+begin_src scheme
(define path-with-home-expansion
  #~(lambda (path)
      (cond
       ((string? path) (string-append (getenv "HOME") "/" path))
       ((list? path)
        (apply
         (lambda* (#:optional tail #:key xdg-base)
           (string-append (getenv xdg-base) "/" (or tail "")))
         path)))))

(define state-with-home-expansions
  #~(lambda (state)
      (map (lambda (i)
             (acons #:path (#$path-with-home-expansion (assoc-ref i #:path)) i))
           state)))

(define ignore-with-home-expansions
  #~(lambda (ignore)
      (map #$path-with-home-expansion ignore)))

(define homedir-gexp #~(getenv "HOME"))

(define home-stateless-service-type
  (service-type
   (name 'home-stateless)
   (extensions
    (list (service-extension home-activation-service-type
                             (lambda (config)
                               (stateless:activate-gexp
                                #~(#$state-with-home-expansions '#$(assoc-ref config #:state))
                                homedir-gexp
                                (assoc-ref config #:persist-dir)
                                (assoc-ref config #:machine-dir))))
          (service-extension home-profile-service-type
                             (lambda (config)
                               (list (stateless:diff-tool-package
                                      "home-stateless-diff"
                                      #~(#$state-with-home-expansions '#$(assoc-ref config #:state))
                                      #~(#$ignore-with-home-expansions '#$(assoc-ref config #:ignore))
                                      homedir-gexp
                                      (assoc-ref config #:persist-dir)
                                      (assoc-ref config #:machine-dir)
                                      #:additional-known
                                      guix-home-files))))))
   (compose identity)
   (extend stateless:extend-proc)
   (description "Initialize a stateless home.")))
#+end_src
**** Skeletons
#+begin_src scheme
(define (stateless-skeletons)
  (list
   (simple-service
    'stateless-skeletons
    home-files-service-type
    (map (lambda (file)
           `(,file
             ,(skel-file file #:strip-dot? #t)))
         '(".Xdefaults"
           ".gdbinit"
           ".guile")))

   (simple-service
    'stateless-skeletons-xdg
    home-xdg-configuration-files-service-type
    `(("nano/nanorc"
       ,(skel-file ".config/nano/nanorc"))))))

(define* (skel-file file* #:key strip-dot?)
  (let ((file (string-append "/etc/skel/" file*)))
    (if strip-dot?
        (local-file file (substring file* 1))
        (local-file file))))
#+end_src
*** Shells
#+begin_src scheme
(define* (he-shells #:key
                    stateless?
                    login-shell
                    interactive-shell
                    (bashrc (local-file "bashrc"))
                    (zshrc (local-file "zshrc")))
  (let ((setup-shell? (lambda (shell)
                        (memq shell (list login-shell interactive-shell)))))
    (append
     (if (setup-shell? #:shell/bash)
         (list
          (service home-bash-service-type
                   (home-bash-configuration
                    (bashrc
                     (list (local-file "bashrc")))))
          (when stateless?
            (simple-service
             'bash-stateless
             home-stateless-service-type
             '((#:state . (((#:path . ("bash/" #:xdg-base "XDG_STATE_HOME"))
                            (#:store . #:persist))))))))
         '())
     (if (setup-shell? #:shell/zsh)
         (list
          (service home-zsh-service-type
                   (home-zsh-configuration
                    (zshrc
                     (list zshrc))))
          (when stateless?
            (simple-service
             'zsh-stateless
             home-stateless-service-type
             '((#:state . (((#:path . ("zsh/" #:xdg-base "XDG_STATE_HOME"))
                            (#:store . #:persist))
                           ((#:path . ("zsh/" #:xdg-base "XDG_CACHE_HOME"))
                            (#:store . #:machine))))))))
         '())
     (list
      (when-not (eq? login-shell interactive-shell)
                (simple-service
                 'set-shell-env-var
                 home-environment-variables-service-type
                 `(("SHELL" . ,(case interactive-shell
                                 ;; ((#:shell/bash) (file-append bash "/bin/bash"))
                                 ((#:shell/zsh) (file-append zsh "/bin/zsh")))))))))))
#+end_src
**** Bash
***** Bashrc
#+begin_src sh :tangle (meta-in-dir "bashrc")
HISTFILE=${XDG_STATE_HOME:-$HOME/.local/var/lib}/bash/.bash_history
#+end_src
**** Zsh
***** Zshrc
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "zshrc")
:END:
****** Andrew Tropin's zshrc
- TODO trying out Andrew Tropin's zsh configuration verbatim for now. Should I also try out vanilla zshell?
#+begin_src sh
# Prevent freezing output on ^s, needed for various isearches
hash stty 2> /dev/null && stty -ixon

# Completions and other stuff
autoload -U compinit
compinit -d ${XDG_CACHE_HOME:-$HOME/.cache}/zsh/.zcompdump

# Enable bash completion, requires to source them from somewhere
# autoload -U bashcompinit && bashcompinit

zstyle ':completion:*' menu select
zstyle ':completion:*' insert-tab false

# Automatically update cache of binaries avaliable in $PATH
zstyle ':completion:*' rehash true # Can have a performance penalty

# Approximate completion
# zstyle ':completion:::::' completer _complete _approximate
# zstyle ':completion:*:approximate:*' max-errors 2

# Fuzzy completion
# https://superuser.com/questions/415650/does-a-fuzzy-matching-mode-exist-for-the-zsh-shell
zstyle ':completion:*' matcher-list '' \
  'm:{a-z\-}={A-Z\_}' \
  'r:[^[:alpha:]]||[[:alpha:]]=** r:|=* m:{a-z\-}={A-Z\_}' \
  'r:|?=** m:{a-z\-}={A-Z\_}'

# Make kill completion smart
zstyle ':completion:*:*:*:*:processes' command "ps -u $USER -o pid,user,args -w -w"

# Colored completion for files and dirs according to LS_COLORS

hash dircolors 2> /dev/null && eval $(dircolors --sh) && \
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

# Prompt theme setup
clear_fn() {
#  zle reset-prompt
  zle kill-buffer
}

prompt_rde_precmd() {
  # Prevent killing prompt on ^C
  trap 'clear_fn' SIGINT
}

prompt_rde_setup() {
  if [[ $UID -eq 0 ]]; then
    user_part='%F{red}>%f'
  else
    user_part='%F{green}>%f'
  fi
  if [ -n "$GUIX_ENVIRONMENT" ]; then
    genv_part='%F{blue}>%f'
  fi
  # exit_code_part='%(?..[%?])'

  PS1="$user_part$genv_part "
  # RPS1="$exit_code_part"

  # Fish-like C-c behavior
  # add-zsh-hook precmd prompt_rde_precmd
}

# Load promptinit and set rde theme
autoload -Uz promptinit && promptinit
prompt_themes+=( rde )
prompt rde

setopt printexitvalue # Instead of using RPS1 for status code

echo -en "\033[6 q" # Make a cursor to be a vertical bar

# Remove slashes and dashes from wordchars to make M-b, M-f work
# correctly
WORDCHARS=""

# Configure history
# HISTSIZE=5000
# SAVEHIST=$HISTSIZE
HISTFILE=${XDG_STATE_HOME:-$HOME/.local/var/lib}/zsh/.zhistory

#setopt incappendhistory # Save history to shared file, but not read
setopt sharehistory     # Share history across shell sessions
setopt histignorespace  # Ignore commands that start with space

# Configuring help (M-h to call it on current command/function)
autoload -Uz run-help
(( ${+aliases[run-help]} )) && unalias run-help
autoload -Uz run-help-git

# Delete, home, end buttons
bindkey  "^[[3~"  delete-char
bindkey  "^[[H"   beginning-of-line
bindkey  "^[[F"   end-of-line

# Launch $VISUAL or $EDITOR, for emacsclient if there is no server
# avaliable $ALTERNATE_EDITOR will be used.
autoload -z edit-command-line
zle -N edit-command-line
bindkey "^X^E" edit-command-line

alias help=run-help
alias try='guix shell man-db coreutils'
alias ls='ls -p --color=auto'
alias ll='ls -l'
alias grep='grep --color=auto'
#+end_src
****** History
#+begin_src sh
HISTSIZE=1000000
SAVEHIST=$HISTSIZE
#+end_src
*** Nix
#+begin_src scheme
(define* (he-nix #:key
                 stateless?
                 (nix-channels (local-file "nix-channels"))
                 (nixpkgs-config (local-file "nixpkgs-config.nix")))
  (append
   (list
    (simple-service
     'nix-add-channels
     home-files-service-type
     `((".nix-channels"
        ,nix-channels)))

    (simple-service
     'nix-add-nixpkgs-config
     home-xdg-configuration-files-service-type
     `(("nixpkgs/config.nix"
        ,nixpkgs-config))))

   (if stateless?
       (let ((nix-profile ".nix-profile")
             (nix-channels ".nix-defexpr/channels"))
         (list
          (simple-service
           'stateless-nix-ensure-profiles
           home-activation-service-type
           #~(#$stateless-ensure-profiles-gexp
              (let ((user-profiles-dir (string-append "/nix/var/nix/profiles/per-user/" (passwd:name (getpwuid (getuid))))))
                `((,(string-append (getenv "HOME") "/" #$nix-profile) . ,(string-append user-profiles-dir "/profile"))
                  (,(string-append (getenv "HOME") "/" #$nix-channels) . ,(string-append user-profiles-dir "/channels"))))))

          (simple-service
           'nix-stateless
           home-stateless-service-type
           `((#:state . (((#:path . ("nix/" #:xdg-base "XDG_CACHE_HOME"))
                          (#:store . #:machine))))
             (#:ignore . ,(list nix-profile
                                nix-channels))))))
       '())

   (google-chrome-services #:stateless? stateless?)))
#+end_src
**** Load Nix environment
TODO and remove "tangle no"
- I vaguely recall not being sure I wanted to source nix.sh, or make sure it was sourced earlier than guix stuff, so it wouldn't override guix env vars (but wouldn't that mess up one or the other, nix or guix?)
#+begin_src sh :tangle no
if [ -f /run/current-system/profile/etc/profile.d/nix.sh ]; then
  . /run/current-system/profile/etc/profile.d/nix.sh
fi
#+end_src
**** Nix channels
#+begin_src conf :tangle (meta-in-dir "nix-channels")
https://nixos.org/channels/nixpkgs-unstable nixpkgs
#+end_src
**** Nixpkgs config
#+begin_src nix :tangle (meta-in-dir "nixpkgs-config.nix")
{ allowUnfree = true; }
#+end_src
**** Nix WIP
TODO and remove all the COMMENT keywords
Commands and stuff (like manifests install and upgrade and guix channel pull) plus a packages "manifest"
***** COMMENT Update channels
#+begin_src sh :results output silent :async
nix-channel --update
#+end_src
***** COMMENT "Manifest"
- TODO might want to / see if I can make this a simple bulleted list I pass with :var to source block(s)
#+name: nix-packages
#+begin_src org
google-chrome zoom-us
#+end_src
***** COMMENT Install packages
Removed ":noweb yes" for now
#+begin_src sh :results output silent :async
nix-env --install <<nix-packages>>
#+end_src
***** COMMENT Upgrade packages
#+begin_src sh :results output silent :async
nix-env --upgrade
#+end_src
***** how to pin packages?
Is [[https://nixos.wiki/wiki/FAQ/Pinning_Nixpkgs][this]] the right way? Maybe the new nix CLI will have a better option?
***** [2022-08-21 Sun] stateless first install
Maybe make a simple home-activation-service that ensures the nix profile packages are installed so I don't have to do it manually after a fresh computer install (better reproducability!). Mount the nix subvolume in the installation script.
**** Google Chrome
#+begin_src scheme
(define* (google-chrome-services #:key stateless?)
  (list
   (when stateless?
     (simple-service
      'google-chrome-stateless
      home-stateless-service-type
      '((#:state . (((#:path . ("google-chrome/" #:xdg-base "XDG_CACHE_HOME"))
                     (#:store . #:machine)
                     (#:mode . #o700))
                    ((#:path . ("google-chrome/" #:xdg-base "XDG_CONFIG_HOME"))
                     (#:store . #:machine)
                     (#:mode . #o700))
                    ((#:path . ".pki/")
                     (#:store . #:machine)
                     (#:mode . #o700)))))))))
#+end_src
*** Emacs
#+begin_src scheme
(define* (he-emacs #:key
                   (emacs emacs-fully-loaded-pgtk)
                   zsh-vterm?)
  (list
   (simple-service
    'emacs-add-package
    home-profile-service-type
    (list emacs))

   (simple-service
    'emacs-set-editor-env-vars
    home-environment-variables-service-type
    `(("VISUAL" . ,(file-append emacs "/bin/emacsclient"))
      ("EDITOR" . "$VISUAL")))

   (when zsh-vterm?
     (simple-service
      'emacs-zsh-vterm
      home-zsh-service-type
      (home-zsh-extension
       (zshrc
        (list (local-file "zsh-vterm"))))))))
#+end_src
**** Configure zsh for vterm
#+begin_src sh :tangle (meta-in-dir "zsh-vterm")
vterm_printf(){
    if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ] ); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    elif ([ "${TERM%%-*}" = "eterm" ] || [ "${TERM%%-*}" = "dumb" ]); then
        # Do nothing for Emacs' term and ansi-term, and other dumb terminals.
    else
        printf "\e]%s\e\\" "$1"
    fi
}

vterm_prompt_end() {
    # USERNAME=$(whoami)
    # HOSTNAME=$(hostname)
    vterm_printf "51;A$USER@$HOST:$(pwd)";
}
setopt PROMPT_SUBST
PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'
#+end_src
**** Emacs packages
:PROPERTIES:
:meta-dir+: /packages
:header-args+: :tangle (meta-in-dir "emacs.scm")
:END:
#+begin_src scheme
(define-module (ebullient home packages emacs)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages compression) #:select (zstd))
  #:use-module ((gnu packages emacs) #:select (emacs emacs-next-pgtk))
  #:use-module ((gnu packages gcc) #:select (gcc-12))
  #:use-module (ebullient utils)
  #:use-module ((srfi srfi-1) #:select (remove))
  #:export (emacs-fully-loaded-pgtk))

(define emacs-with-native-comp (@@ (flat packages emacs) emacs-with-native-comp))
#+end_src
***** Emacs latest :version:
Use the github mirror since the canonical repo (https://git.savannah.gnu.org/git/emacs.git) doesn't allow shallow fetches.
#+begin_src scheme
(define-public (with-emacs-latest emacs)
  (-> emacs
      (with-git-commit #:upstream-version "29.0.50"
                       #:commit "06d7161476255c77defa119fffa842b7abaa0dcb"
                       #:hash "099wp5bd21zmbjlfn58n5sp7l8xmskg3ai63xy9ijh5spkjl1q5q")
      (with-git-url "https://github.com/emacs-mirror/emacs")))
#+end_src
***** Wayland =Super= fix
#+begin_src scheme
(define-public (with-wayland-super-fix emacs)
  (package
    (inherit emacs)
    (source
     (origin
       (inherit (package-source emacs))
       (patches
        (cons
         "/.persist/home/pharcosyle/phrenetic_for_now/ebullient/home/packages/patches/wayland-super-fix.patch"
         ;; "/home/pharcosyle/work/phrenetic/ebullient/home/packages/patches/wayland-super-fix.patch" ; (local-file "patches/wayland-super-fix.patch") ; TODO why isn't this working with local-file?
              (-> emacs package-source origin-patches)))))))
#+end_src
****** WAIT [#E] Remove the Wayland =Super= fix
Once either:
- The issue [[https://gitlab.gnome.org/GNOME/gtk/-/issues/4913][GDK_SUPER_MASK is not set on Super key press events on Wayland / wlroots (#49...]] is resolved.
  As discussed in [[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=55362][#55362 - 29.0.50; Super key no longer works on Wayland - GNU bug report logs]].
- I find a workaround with KMonad after I start using it.
****** Patch
#+begin_src diff :tangle (meta-in-dir "patches/wayland-super-fix.patch")
diff --git src/pgtkterm.c src/pgtkterm.c
index 566fc1f03d..1cb4d5dac0 100644
--- a/src/pgtkterm.c
+++ b/src/pgtkterm.c
@@ -5207,7 +5207,7 @@ pgtk_gtk_to_emacs_modifiers (struct pgtk_display_info *dpyinfo, int state)
     mod |= mod_ctrl;
   if (state & GDK_META_MASK || state & GDK_MOD1_MASK)
     mod |= mod_meta;
-  if (state & GDK_SUPER_MASK)
+  if (state & GDK_SUPER_MASK || state & GDK_MOD4_MASK)
     mod |= mod_super;
   if (state & GDK_HYPER_MASK)
     mod |= mod_hyper;
@@ -5340,7 +5340,7 @@ key_press_event (GtkWidget *widget, GdkEvent *event, gpointer *user_data)
       /* While super is pressed, the input method will always always
 	 resend the key events ignoring super.  As a workaround, don't
 	 filter key events with super or hyper pressed.  */
-      if (!(event->key.state & (GDK_SUPER_MASK | GDK_HYPER_MASK)))
+      if (!(event->key.state & (GDK_SUPER_MASK | GDK_MOD4_MASK | GDK_HYPER_MASK)))
 	{
 	  if (pgtk_im_filter_keypress (f, &event->key))
 	    return TRUE;
@@ -5356,8 +5356,9 @@ key_press_event (GtkWidget *widget, GdkEvent *event, gpointer *user_data)
       /* make_lispy_event turns chars into control chars.
          Don't do it here because XLookupString is too eager.  */
       state &= ~GDK_CONTROL_MASK;
-      state &= ~(GDK_META_MASK
-		 | GDK_SUPER_MASK | GDK_HYPER_MASK | GDK_MOD1_MASK);
+      state &= ~(GDK_META_MASK | GDK_MOD1_MASK
+		 | GDK_SUPER_MASK | GDK_MOD4_MASK
+		 | GDK_HYPER_MASK);

       nbytes = event->key.length;
       if (nbytes > copy_bufsiz)
#+end_src
***** Epoch patch update
#+begin_src scheme
(define-public (with-epoch-patch-update emacs)
  (package
    (inherit emacs)
    (source
     (origin
       (inherit (package-source emacs))
       (patches
        (->>(-> emacs package-source origin-patches)
            (remove
             (lambda (patch)
               (string-suffix? "emacs-source-date-epoch.patch" patch)))
            (cons
             "/.persist/home/pharcosyle/phrenetic_for_now/ebullient/home/packages/patches/emacs-source-date-epoch.patch"
             ;; "/home/pharcosyle/work/phrenetic/ebullient/home/packages/patches/emacs-source-date-epoch.patch" ; (local-file "patches/emacs-source-date-epoch.patch") ; TODO why isn't this working with local-file?
             )))))))
#+end_src
****** Patch
#+begin_src diff :tangle (meta-in-dir "patches/emacs-source-date-epoch.patch")
Honor SOURCE_DATE_EPOCH variable to avoid non-determinism in generated
"autoloads" files.

--- a/lisp/obsolete/autoload.el
+++ b/lisp/obsolete/autoload.el
@@ -419,8 +419,12 @@
   ;;              nil t))
   ;;        (match-end 2))))
   (insert generate-autoload-section-header)
-  (prin1 `(autoloads ,autoloads ,load-name ,file ,time)
-	 outbuf)
+  (let* ((env  (getenv "SOURCE_DATE_EPOCH"))
+         (time (if env
+                   (seconds-to-time (string-to-number env))
+                 time)))
+    (prin1 `(autoloads ,autoloads ,load-name ,file ,time)
+           outbuf))
   (terpri outbuf)
   ;; Break that line at spaces, to avoid very long lines.
   ;; Make each sub-line into a comment.
#+end_src
***** Native comp
#+begin_src scheme
(define-public (with-native-comp emacs)
  (emacs-with-native-comp emacs gcc-12 'full-aot))
#+end_src
***** Findable C source
#+begin_src scheme
(define-public (with-findable-C-source emacs)
  (package
    (inherit emacs)
    (arguments
     (substitute-keyword-arguments (package-arguments emacs)
       ((#:phases phases '%standard-phases)
        #~(modify-phases #$phases
            (add-after 'unpack 'patch-C-source-directory
              (lambda _
                (substitute* "lisp/emacs-lisp/find-func.el"
                  (("\\(expand-file-name \"src\" source-directory\\)")
                   (string-append "\"" #$(file-append (package-source emacs) "/src") "\"")))))))))))
#+end_src
***** =zstd=
#+begin_src scheme
(define-public (with-zstd emacs)
  (package
    (inherit emacs)
    (propagated-inputs
     (modify-inputs (package-propagated-inputs emacs)
       (prepend zstd)))))
#+end_src
****** TODO [#E] Add =zstd= to emacs program wrapper
i.e. by using ~wrap-program~ on the emacs executable instead of just adding it to the propagated inputs. It's a bit tricky (see the ~strip-double-wrap~ build phase in the emacs package definition) and I don't want to mess it up and introduce possibly subtle problems.
***** Path integration improvements
#+begin_src scheme
(define-public (with-path-integration-improvements emacs)
  (package
    (inherit emacs)
    (source
     (origin
       (inherit (package-source emacs))
       (snippet
        `(begin
           ,(origin-snippet (package-source emacs))
           (let ((wrap-in-quotes (lambda (s)
                                   (string-append "\"" s "\""))))
             (with-directory-excursion "lisp"
               (substitute* "net/tramp.el"
                 (("\\(tramp-default-remote-path" start-of-list)
                  (string-join
                   (cons start-of-list
                         (map wrap-in-quotes
                              (list "~/.config/guix/current/bin"
                                    "~/.guix-home/profile")))
                   " ")))
               (substitute* "man.el"
                 (("\"/usr/local/include\"" last-item)
                  (string-join
                   (list last-item
                         (wrap-in-quotes "~/.guix-home/profile/include"))
                   " ")))))))))))
#+end_src
***** Emacs fully loaded :package:
#+begin_src scheme
(define* (emacs-fully-loaded* #:key pgtk?)
  (-> (if pgtk?
          (-> emacs-next-pgtk
              with-emacs-latest
              with-wayland-super-fix
              with-epoch-patch-update)
          emacs)
      with-native-comp
      with-findable-C-source
      with-zstd
      with-path-integration-improvements))

;; (define emacs-fully-loaded (emacs-fully-loaded*))
(define emacs-fully-loaded-pgtk (emacs-fully-loaded* #:pgtk? #t))
#+end_src
*** Doom
#+begin_src scheme
(define* (he-doom #:key
                  stateless?
                  console?
                  (doom-private (local-file "doom-private" #:recursive? #t))
                  email
                  theme
                  font
                  font-variable-pitch
                  font-unicode
                  font-serif)
  (list
   (simple-service
    'doom-add-packages
    home-profile-service-type
    (list `(,doom-emacs "bin")))

   (simple-service
    'doom-add-config
    home-xdg-configuration-files-service-type
    `(("emacs"
       ,doom-emacs)
      ("doom"
       ,(directory-union
         "doom-private-with-params"
         `(,doom-private
           ,(file-union
             "params-dir"
             `(("params.el"
                ,(mixed-text-file
                  "params.el"
                  (serialize-elisp-config
                   #f
                   `((setq param-console? ,(if console? 't 'nil)
                           param-email ,email
                           param-theme ,(symbol-append ': (keyword->symbol theme))
                           param-font-name ,(assoc-ref font #:font/name)
                           param-font-size ,(+ (assoc-ref font #:font/size) 2)
                           param-font-weight ,(if-let ((weight (assoc-ref font #:font/weight)))
                                                      `',weight
                                                      'nil)
                           param-font-variable-pitch-name ,(assoc-ref font-variable-pitch #:font/name)
                           param-font-unicode-name ,(assoc-ref font-unicode #:font/name)
                           param-font-serif-name ,(assoc-ref font-serif #:font/name)))))))))))))

   (when stateless?
     (simple-service
      'doom-stateless
      home-stateless-service-type
      `((#:state . (((#:path . ("doom-local/" #:xdg-base "XDG_STATE_HOME"))
                     (#:store . #:machine))
                    ,@(let* ((doom (lambda (subpath)
                                     `(,(string-append "doom/" subpath) #:xdg-base "XDG_STATE_HOME")))
                             (doom-persist (lambda (subpath)
                                             `((#:path . ,(doom subpath))
                                               (#:store . #:persist))))
                             (doom-machine (lambda (subpath)
                                             `((#:path . ,(doom subpath))
                                               (#:store . #:machine)))))
                        (list
                         (doom-persist "cache/cider-repl-history")
                         (doom-persist "cache/geiser-history.guile")
                         (doom-persist "cache/projectile.projects")
                         (doom-persist "cache/recentf")
                         (doom-persist "cache/savehist")
                         (doom-persist "cache/saveplace")
                         (doom-persist "etc/bookmarks")
                         (doom-persist "etc/eshell/history")
                         (doom-persist "etc/eshell/lastdir")
                         (doom-persist "etc/eshell/z")
                         (doom-persist "etc/org-clock-save.el")
                         (doom-persist "etc/scratch/")
                         (doom-persist "etc/transient/history")
                         (doom-machine "cache/autosave/")
                         (doom-machine "cache/guix-packaging/")
                         (doom-machine "cache/org-gcal/token.gpg")
                         (doom-machine "cache/org/persist/")
                         (doom-machine "cache/projectile.cache")
                         (doom-machine "cache/tramp")
                         (doom-machine "cache/undo-fu-session/")
                         (doom-machine "etc/persist/org-gcal--sync-tokens")
                         (doom-machine "etc/workspaces/autosave/"))))))))))
#+end_src
**** Doom Emacs :package:version:
:PROPERTIES:
:meta-dir+: /packages
:END:
#+begin_src scheme :tangle (meta-in-dir "doom-emacs.scm")
(define-module (ebullient home packages doom-emacs)
  #:use-module (guix build-system copy)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module ((gnu packages rust-apps) #:select (fd ripgrep))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module ((ebullient home packages all-the-icons-fonts) #:select (all-the-icons-fonts)))

(define-public doom-emacs
  (let ((commit "c44bc81a05f3758ceaa28921dd9c830b9c571e61")
        (revision "0"))
    (package
      (name "doom-emacs")
      (version (git-version "3.0.0-dev" revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/doomemacs/doomemacs")
               (commit commit)))
         (sha256
          (base32
           "1izn00gz1sg1b08cvip1i5fqzknqx61pc0s8rgvihz15wk8nbanx"))
         (file-name (git-file-name name version))
         (patches
          (list (local-file "patches/change-paths.patch")))))
      (build-system copy-build-system) ; TODO LICENSE file gets installed to a "share/" folder, not hurting anything but maybe remove. More generally perhaps check to see what other changes there might be between a simple checkout of the repo and what copy-build-system does.
      (arguments
       (list
        ;; #:install-plan
        ;; '(("." "share/doom-emacs/"))
        ;; #:tests? #t
        ;; #:test-command '("./bin/doom" "test")
        #:phases
        #~(modify-phases %standard-phases
            (add-after 'install 'symlink-bin
              (lambda _
                (mkdir #$output:bin)
                (symlink (string-append #$output "/bin")
                         (string-append #$output:bin "/bin")))))))
      (propagated-inputs
       (list git
             ripgrep
             fd
             all-the-icons-fonts))
      (outputs '("out" "bin"))
      (synopsis "An Emacs framework for the stubborn martian hacker")
      (description "Doom is a configuration framework for GNU Emacs tailored for
Emacs bankruptcy veterans who want less framework in their frameworks, a modicum
of stability (and reproducibility) from their package manager, and the
performance of a hand rolled config (or better).")
      (home-page "https://github.com/doomemacs/doomemacs")
      (license license:expat))))
#+end_src
***** WAIT Doom tests :wait_on_doom:
Nonfunctional at the moment ([[doom:core/core-cli.el::212][hlissner has them commented out]]) but once they're working determine if they make sense to run during packaging (if they can find places where my patches, substitutions, etc. can mess stuff up). I'm concerned they'll take too long to run or require network access (to download Straight dependencies). Make sure there aren't any side effect files that end up getting installed.
***** Emacs packages :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "emacs-xyz.scm")
:END:
#+begin_src scheme
(define-module (ebullient home packages emacs-xyz)
  #:use-module (guix build-system copy)
  #:use-module (guix build-system emacs)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages emacs-xyz) #:select (emacs-tldr) #:prefix emacs-xyz:)
  #:use-module ((gnu packages compression) #:select (unzip))
  #:use-module (ebullient utils))
#+end_src
****** guix-contributing
#+begin_src scheme
(define-public emacs-guix-contributing
  (package
    (name "emacs-guix-contributing")
    (version "0")
    (source
     (local-file "guix-contributing.el"))
    (build-system emacs-build-system)
    (arguments
     '(#:phases
       (modify-phases %standard-phases
         (add-after 'unpack 'patch-guix-source-path
           (lambda* (#:key inputs #:allow-other-keys)
             (make-file-writable "guix-contributing.el")
             (emacs-substitute-variables "guix-contributing.el"
               ("guix-contributing-source-path" (search-input-directory inputs "share/guix-emacs-development"))))))))
    (inputs
     (list guix-emacs-development))
    (home-page #f)
    (synopsis "Some Emacs integration to assist in contributing to Guix")
    (description "See https://guix.gnu.org/manual/en/guix.html#The-Perfect-Setup")
    (license license:gpl3+)))
#+end_src
******* Source
Tempel snippets now available under =/etc/snippets/tempel= as of [2022-08-30 Tue] and this [[https://github.com/guix-mirror/guix/commit/c4acaf412064568a546034871a9e0d3888aa7937][commit]].
#+begin_src elisp :tangle (meta-in-dir "guix-contributing.el")
(defvar guix-contributing-source-path "~/src/guix")

(with-eval-after-load 'yasnippet
  (add-to-list 'yas-snippet-dirs (concat guix-contributing-source-path "/etc/snippets/yas")))

(load-file (concat guix-contributing-source-path "/etc/copyright.el"))

(when (and user-full-name
           user-mail-address)
  (setq copyright-names-regexp (format "%s <%s>" user-full-name user-mail-address)))

(provide 'guix-contributing)
#+end_src
******* Guix's Emacs development code
Use the github mirror since the canonical repo doesn't allow shallow fetches.
#+begin_src scheme
(define guix-emacs-development*
  (let ((commit "bf0389a3806509650b7a8425973ac5aac722901a")
        (revision "0"))
    (package
      (name "guix-emacs-development")
      (version (git-version "1.3.0" revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://git.savannah.gnu.org/git/guix.git")
               (commit commit)))
         (sha256
          (base32
           "0x4mpw017q4l14aimlyzxxa68jz2rn6zb8m8l7s791fkkdn2paja"))))
      (build-system copy-build-system)
      (arguments
       `(#:install-plan
         '(("etc/copyright.el" "share/guix-emacs-development/etc/copyright.el")
           ("etc/snippets" "share/guix-emacs-development/etc/snippets"))))
      (home-page #f)
      (synopsis #f)
      (description #f)
      (license #f))))

(define guix-emacs-development
  (with-git-url guix-emacs-development* "https://github.com/guix-mirror/guix"))
#+end_src
****** tldr
#+begin_src scheme
(define-public emacs-tldr
  (package
    (inherit emacs-xyz:emacs-tldr)
    (arguments
     (substitute-keyword-arguments (package-arguments emacs-xyz:emacs-tldr)
       ((#:phases phases '%standard-phases)
        #~(modify-phases #$phases
            (add-after 'unpack 'patch-tldr-directory-path
              (lambda* (#:key inputs #:allow-other-keys)
                (emacs-substitute-variables "tldr.el"
                  ("tldr-directory-path" (search-input-directory inputs "share/tldr-pages")))))))))
    (inputs (modify-inputs (package-inputs emacs-xyz:emacs-tldr)
              (prepend tldr-pages)))))
#+end_src
******* tldr pages
#+begin_src scheme
(define tldr-pages
  (let ((commit "7ee7ed0f4afc90ef05b1dde87f6fec5b462a0394")
        (revision "0"))
    (package
      (name "tldr-pages")
      (version (git-version "1.5b" revision commit))
      (source
       (origin
         (method url-fetch/zipbomb)
         (uri (string-append "https://raw.githubusercontent.com/tldr-pages/tldr-pages.github.io/" commit "/assets/tldr.zip"))
         (sha256
          (base32
           "0a09ycfrxiaxv0hzjrkwi56l0ga5d7ydrlclmk4vd6ndb242vhgr"))))
      (build-system copy-build-system)
      (arguments
       `(#:install-plan
         '(("." "share/tldr-pages/"))))
      (home-page "https://tldr.sh")
      (synopsis "A collection of community-maintained help pages for command-line tools")
      (description synopsis)
      (license license:cc-by4.0))))
#+end_src
***** all-the-icons fonts :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "all-the-icons-fonts.scm")
:END:
#+begin_src scheme
(define-module (ebullient home packages all-the-icons-fonts)
  #:use-module (guix build-system font)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((gnu packages emacs-xyz) #:select (emacs-all-the-icons))
  #:use-module ((gnu packages fonts) #:select (font-google-material-design-icons font-awesome))
  #:use-module (ebullient utils))

(define-public all-the-icons-fonts
  (let ((commit "6f876fa11ef64af20d9b2a44fdabac6446de51ba")
        (revision "0"))
    (package
      (name "all-the-icons-fonts")
      (version (git-version (package-version emacs-all-the-icons) revision commit))
      (source
       (origin
         (inherit (package-source emacs-all-the-icons))
         (uri (git-reference
               (inherit (-> emacs-all-the-icons package-source origin-uri))
               (commit commit)))
         (sha256
          (base32
           "1n975ziy5wyfnmmpak1vsj7nqzm5ciw811pcg7rdmc2ljlc90n5p"))
         (file-name (git-file-name name version))))
      (build-system font-build-system)
      (arguments
       `(#:phases
         (modify-phases %standard-phases
           (add-before 'install 'remove-unbundled-fonts
             (lambda _
               (with-directory-excursion "fonts"
                 (for-each delete-file
                           (list "fontawesome.ttf"
                                 "material-design-icons.ttf"))))))))
      (propagated-inputs
       (list font-awesome
             font-google-material-design-icons))
      (home-page (package-home-page emacs-all-the-icons))
      (synopsis (package-synopsis emacs-all-the-icons))
      (description (package-description emacs-all-the-icons))
      (license (package-license emacs-all-the-icons)))))
#+end_src
***** Patches
****** Change paths
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "patches/change-paths.patch")
:END:
******* Core
#+begin_src diff
diff --git a/lisp/doom.el b/lisp/doom.el
index 6dbbefb5e..e39890b0c 100644
--- a/lisp/doom.el
+++ b/lisp/doom.el
@@ -221,7 +221,9 @@ downloaded/installed by packages. Must end in a slash.")
       (expand-file-name (file-name-as-directory localdir))
     (if doom-profile
         doom-profile-dir
-      (expand-file-name ".local/" doom-emacs-dir)))
+      (expand-file-name "doom-local/"
+                        (or (getenv-internal "XDG_STATE_HOME")
+                            "~/.local/state"))))
   "Root directory for local storage.
 
 Use this as a storage location for this system's installation of Doom Emacs.
@@ -229,10 +231,18 @@ Use this as a storage location for this system's installation of Doom Emacs.
 These files should not be shared across systems. By default, it is used by
 `doom-data-dir' and `doom-cache-dir'. Must end with a slash.")
 
+
+(defconst doom-state-dir
+  (if-let (localdir (getenv-internal "DOOMLOCALDIR"))
+      (concat (expand-file-name (file-name-as-directory localdir)) "state/")
+    (expand-file-name "doom/"
+                      (or (getenv-internal "XDG_STATE_HOME")
+                          "~/.local/state"))))
+
 (defconst doom-data-dir
   (if doom-profile
       doom-profile-data-dir
-    (concat doom-local-dir "etc/"))
+    (concat doom-state-dir "etc/"))
   "Directory for non-volatile local storage.
 
 Use this for files that don't change much, like server binaries, external
@@ -241,7 +251,7 @@ dependencies or long-term shared data. Must end with a slash.")
 (defconst doom-cache-dir
   (if doom-profile
       doom-profile-cache-dir
-    (concat doom-local-dir "cache/"))
+    (concat doom-state-dir "cache/"))
   "Directory for volatile local storage.
 
 Use this for files that change often, like cache files. Must end with a slash.")
@@ -258,7 +268,7 @@ autoloaded core functions (in lisp/lib/*.el).")
 (defconst doom-env-file
   (if doom-profile
       (expand-file-name "env" doom-profile-dir)
-    (concat doom-local-dir "env"))
+    (concat doom-state-dir "env"))
   "The location of your envvar file, generated by `doom env`.
 
 This file contains environment variables scraped from your shell environment,
@@ -319,7 +329,7 @@ users).")
   ;; Don't store eln files in ~/.emacs.d/eln-cache (where they can easily be
   ;; deleted by 'doom upgrade').
   ;; REVIEW Use `startup-redirect-eln-cache' when 28 support is dropped
-  (add-to-list 'native-comp-eln-load-path (expand-file-name "eln/" doom-cache-dir)))
+  (add-to-list 'native-comp-eln-load-path (expand-file-name "eln/" doom-local-dir)))
 
 
 ;;
@@ -345,7 +355,7 @@ users).")
 
 ;; Allow the user to store custom.el-saved settings and themes in their Doom
 ;; config (e.g. ~/.doom.d/).
-(setq custom-file (expand-file-name "custom.el" doom-user-dir))
+(setq custom-file (expand-file-name "custom.el" doom-state-dir))
 
 ;; By default, Emacs stores `authinfo' in $HOME and in plain-text. Let's not do
 ;; that, mkay? This file stores usernames, passwords, and other treasures for
#+end_src
******* RSS module
#+begin_src diff
diff --git a/modules/app/rss/config.el b/modules/app/rss/config.el
index a292f4006..fe3dbfa29 100644
--- a/modules/app/rss/config.el
+++ b/modules/app/rss/config.el
@@ -20,8 +20,8 @@ easier to scroll through.")
 (use-package! elfeed
   :commands elfeed
   :init
-  (setq elfeed-db-directory (concat doom-local-dir "elfeed/db/")
-        elfeed-enclosure-default-dir (concat doom-local-dir "elfeed/enclosures/"))
+  (setq elfeed-db-directory (concat doom-cache-dir "elfeed/db/")
+        elfeed-enclosure-default-dir (concat doom-cache-dir "elfeed/enclosures/"))
   :config
   (setq elfeed-search-filter "@2-week-ago "
         elfeed-show-entry-switch #'pop-to-buffer
#+end_src
***** packaging doom WIP
Extremely WIP, basically just a scratchpad
****** first attempts
Had =:tangle (meta-in-dir "packaging-doom-wip-1.scm")=
#+begin_src scheme :tangle no
(define-module (ebullient home packaging-doom-wip)
  #:use-module (guix build-system trivial)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  ;; #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module (ebullient home packages emacs)
  #:use-module (ebullient home packages doom-emacs)
  )

;; (define doom-inputs
;;   (computed-file
;;    "doom-inputs"
;;    (with-imported-modules '((guix build utils))
;;      #~(begin
;;          (use-modules (guix build utils))
;;          (invoke (string-append #+doom-emacs:bin "/bin/doom") "help")
;;          (copy-file #$(local-file "nixpkgs-config.nix") #$output)
;;          ;; `emacs-substitute-sexps' might be useful here if my needs get more sophisticated.
;;          ;; (substitute* #$output
;;          ;;   (("(dunstctl|dunst)" all) (case (string->symbol all)
;;          ;;                               ((dunst) (string-append #$(file-append dunst "/bin/dunst")
;;          ;;                                                       " -config " #$(local-file "dunstrc")))
;;          ;;                               ((dunstctl) #$(file-append dunst "/bin/dunstctl"))))
;;          ;;   (("nm-applet") #$(file-append network-manager-applet "/bin/nm-applet"))
;;          ;;   (("pasystray") #$(file-append pasystray "/bin/pasystray"))
;;          ;;   (("redshift-gtk") (string-append #$redshift:gtk "/bin/redshift-gtk"))
;;          ;;   (("udiskie") #$(file-append udiskie "/bin/udiskie")))
;;          ))))


(define-public temp-doom-emacs
  (package
    (name "doom-emacs")
    (version "0")
    (source
     (local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t))
    (build-system (@ (guix build-system copy) copy-build-system))
    (synopsis "")
    (description "")
    (home-page "")
    (license #f)))

(define-public doom-inputs
  (package
    (name "doom-inputs")
    (version "0")
    (source #f)
    (inputs
     (list emacs-29-pgtk+native-comp
           ;; doom-emacs
           temp-doom-emacs
           ;; (local-file "doom-private" #:recursive? #t)
           git
           ;; (local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/straight.el" #:recursive? #t)
           ;; (local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/use-package" #:recursive? #t)
           ))
    (build-system trivial-build-system)
    (arguments
     `(#:modules ((guix build utils))
       #:builder
       ,#~(begin
            (use-modules (guix build utils))
            (let ((doom-private #$(local-file "doom-private" #:recursive? #t))
                  (doom-local-dir (string-append #$output "/doom-local")))
              (mkdir-p doom-local-dir)

              ;; (mkdir-p (string-append #$output "/asdf"))
              ;; (with-output-to-file (string-append #$output "/asdf/asdf.txt")
              ;;   (lambda _
              ;;     (display "asdffffffffffff")))

              (setenv "PATH" (string-append (getenv "PATH")
                                            ":" (assoc-ref %build-inputs "emacs-29-pgtk+native-comp") "/bin"
                                            ":" (assoc-ref %build-inputs "git") "/bin"
                                            ))
              ;; (setenv "DOOMDIR" (assoc-ref %build-inputs "doom-private"))
              (setenv "DOOMDIR" doom-private)
              (setenv "DOOMLOCALDIR" doom-local-dir)

              ;; (chdir #$output)
              ;; (invoke "git" "clone" "https://github.com/dracula/gtk")

              ;; (display "hi!")
              ;; (display doom-private)
              ;; (display straight-el)

              (let ((repos-dir (string-append doom-local-dir "/straight/repos")))
                (mkdir-p repos-dir)
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/straight.el" #:recursive? #t)
                         (string-append repos-dir "/straight.el"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/use-package" #:recursive? #t)
                         (string-append repos-dir "/use-package"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/melpa" #:recursive? #t)
                         (string-append repos-dir "/melpa"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/gnu-elpa-mirror" #:recursive? #t)
                         (string-append repos-dir "/gnu-elpa-mirror"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/el-get" #:recursive? #t)
                         (string-append repos-dir "/el-get"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/emacsmirror-mirror" #:recursive? #t)
                         (string-append repos-dir "/emacsmirror-mirror")))

              (setenv "HOME" "/tmp/asdfasdf")
              (mkdir-p "/tmp/asdfasdf")

              ;; (symlink #$(local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
              ;;            (string-append #$output "/temp-doom-emacs"))
              (let ((doom
                     ;; #$(local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
                     (assoc-ref %build-inputs "doom-emacs")
                     ;; (string-append #$output "/temp-doom-emacs")
                     ))
                ;; (invoke (string-append #$(@ (gnu packages base) coreutils) "/bin/echo") "asdfasdfsdf")
                ;; (invoke (string-append doom "/bin/doom") "help")
                (invoke (string-append doom "/bin/doom") "install" "--no-config" "--no-env" "--no-fonts" "--no-hooks")
                )

              ;; (copy-file #$(local-file "nixpkgs-config.nix") #$output)
              )


            #t)))

    ;; (arguments
    ;;  `(;; #:install-plan
    ;;    ;; '(("." "share/doom-emacs/"))
    ;;    ;; #:tests? #t
    ;;    ;; #:test-command '("./bin/doom" "test")
    ;;    #:phases
    ;;    ,#~(modify-phases %standard-phases
    ;;         (add-after 'install 'symlink-bin
    ;;           (lambda _
    ;;             (mkdir #$output:bin)
    ;;             (symlink (string-append #$output "/bin")
    ;;                      (string-append #$output:bin "/bin")))))))

    (synopsis "")
    (description "")
    (home-page "")
    (license #f)))





(use-modules ((guix packages) #:select (content-hash content-hash-algorithm content-hash-value)))

(define doom-build
  (computed-file
   "doom-build"
   (with-imported-modules '((guix build utils))
     #~(begin
         (use-modules (guix build utils))

         ;; (mkdir-p #$output)

         (setenv "GIT_SSL_NO_VERIFY" "true") ; do ssl if it's easy. Also if I'm using `(guix build git) git-fetch' consider if it setting this variable leaks out.

         ;; (invoke (string-append #+doom-emacs:bin "/bin/doom") "help")
         ;; (copy-file #$(local-file "nixpkgs-config.nix") #$output)
         ;; (invoke (string-append #$(@ (gnu packages wget) wget) "/bin/wget") "--no-check-certificate" "https://xkcd.com/")
         ;; (copy-file "index.html" #$output)

         ;; TODO Consider making e.g. emacs, git not ungexped in a let but instead everywhere they're used (and move this let outside of the gexp). Then I could use file-append instead of string-append in places I guess. Which is better practice?
         (let ((doom-private #+(file-union "doom-private"
                                           `(("init.el" ,(file-append (local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
                                                                      "/init.example.el"))
                                             ("config.el" ,(file-append (local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
                                                                        "/core/templates/config.example.el"))
                                             ("packages.el" ,(file-append (local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
                                                                          "/core/templates/packages.example.el")))))
               ;; (doom-private #$(local-file "doom-private" #:recursive? #t))
               (doom-local-dir (string-append #$output "/doom-local"))
               (emacs #+emacs-29-pgtk+native-comp)
               (git #+git)
               ;; (emacs (assoc-ref %build-inputs "emacs-29-pgtk+native-comp"))
               ;; (git (assoc-ref %build-inputs "git"))
               (doom-emacs #+temp-doom-emacs)
               ;; (doom-emacs #+doom-emacs)
               ;; (doom-emacs (assoc-ref %build-inputs "doom-emacs"))
               ;; (doom-emacs #$(local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t))
               )
           (mkdir-p doom-local-dir)

           (setenv "PATH" (string-append (getenv "PATH")
                                         ":" emacs "/bin"
                                         ":" git "/bin"
                                         ":" #+(@ (gnu packages base) coreutils) "/bin" ; donno if this is necessary
                                         ":" #+(@ (gnu packages base) sed) "/bin"
                                         ))
           ;; Is this a better/cleaner way to do path-setting? Consider also the comment (from git-download.scm), should I add more stuff to the path?
           ;;
           ;; The 'git submodule' commands expects Coreutils, sed,
           ;; grep, etc. to be in $PATH.
           ;; (set-path-environment-variable "PATH" '("bin")
           ;;                                (match '#+inputs
           ;;                                  (((names dirs outputs ...) ...)
           ;;                                   dirs)))

           (setenv "DOOMDIR" doom-private)
           (setenv "DOOMLOCALDIR" doom-local-dir)

           ;; (chdir #$output)
           ;; (invoke "git" "clone" "https://github.com/dracula/gtk")

           ;; donno if this is necessary
           (setenv "HOME" "/tmp/asdfasdf")
           (mkdir-p "/tmp/asdfasdf")

           ;; temporary straight.el experimentation
           ;; (mkdir-p "/tmp/asdfasdf/123456")
           (mkdir-p (string-append doom-local-dir "/straight/repos"))
           (symlink #+(local-file "/home/pharcosyle/work/dotfiles/straight.el" #:recursive? #t)
                    (string-append doom-local-dir "/straight/repos/straight.el"))

           ;; (copy-file #$(local-file "nixpkgs-config.nix") (string-append doom-local-dir "/asdf.txt"))
           ;; (invoke (string-append doom-emacs "/bin/doom") "help")
           (invoke (string-append doom-emacs "/bin/doom") "install" "--no-config" "--no-env" "--no-fonts" "--no-hooks")
           ;; (invoke (string-append doom-emacs "/bin/doom") "upgrade")
           ;; (invoke (string-append doom-emacs "/bin/doom") "build")
           ;; (invoke (string-append doom-emacs "/bin/doom") "sync")

           ;; (invoke (string-append emacs "/bin/emacs") "--batch" "--eval=\"(progn (load user-init-file) (straight-freeze-versions))\"")
           ;; (invoke (string-append emacs "/bin/emacs") "--batch" "--eval='(progn (message \"hello!\"))'")
           ;; (invoke "emacs" "--batch" "--eval='(message \"hello!\")'")
           ;; (chdir #$output)
           ;; (invoke "emacs" "--batch" "--eval='(with-temp-file \"asdf.txt\" (insert \"asdfasdf\"))'")
           ;; (invoke "emacs" "--batch" "--eval='(message \"hello!\")'")
           ;; (invoke "emacs" "--help")
           ;; (invoke "echo" (string-append (string-append emacs "/bin/emacs") "--batch" (string-append "--load=" doom-emacs "/init.el") "--eval=(progn (message \"hi\") (message \"yo\"))"))
           ;; (invoke (string-append emacs "/bin/emacs") "--batch" (string-append "--load=" doom-emacs "/init.el") "--eval=(progn (message \"hi\") (straight-freeze-versions) (message \"yo\"))")
           ;; (invoke "echo" "asdf")

           )))
   #:options (let ((ch (content-hash "1zcpkabkizadc3j9jqnnpyqm4d71bnvxz2x6as53f6wjwn82ahd9")))
               (list #:hash (content-hash-value ch)
                     #:hash-algo (content-hash-algorithm ch)
                     #:recursive? #t
                     ;; #:substitutable? #f ; This isn't appropriate, right?
                     ))))

;; (define-public doom-build-pkg
;;   (package
;;     (name "doom-build-pkg")
;;     (version "0")
;;     (source doom-build)
;;     (build-system (@ (guix build-system copy) copy-build-system))
;;     (synopsis "")
;;     (description "")
;;     (home-page "")
;;     (license #f)))
#+end_src
****** second attempt
Had =:tangle (meta-in-dir "packaging-wip-2.scm") :comments link=
#+begin_src scheme :tangle no
(define-module (ebullient home packaging-wip)
  ;; #:use-module (guix build-system trivial)
  ;; #:use-module (guix gexp)
  ;; #:use-module (guix git-download)
  ;; #:use-module (guix packages)
  ;; #:use-module ((guix licenses) #:prefix license:)
  ;; ;; #:use-module ((gnu packages emacs) #:select (emacs))
  ;; #:use-module ((gnu packages version-control) #:select (git))
  ;; #:use-module (ebullient home packages emacs)
  ;; #:use-module (ebullient home packages doom-emacs)

  #:use-module ((guix packages) #:select (package-input-rewriting))
  #:use-module ((gnu packages emacs) #:select (emacs emacs-minimal emacs-no-x emacs-next emacs-next-pgtk emacs-xwidgets emacs-no-x-toolkit emacs-wide-int))

  )
(define emacs-variant (@ (ebullient home packages emacs) emacs-29-pgtk+native-comp))

;; TODO does this rewrite recursively?
;; package-input-rewriting/spec says it specifically does this while package-input-rewriting does not. And what about using `package-mapping'? I can check the final product for references to emacs/emacs-minimal but still read over the source code of each later. What about native-inputs, sometimes emacs(-minimal) is in there.
;; TODO do I need to specify all of the different emacs packages for rewriting?
;; Does it work without doing this already? Would package-input-rewriting/spec handle them somehow? Does `package/inherit' (in both the -spec and non-spec versions)?
(define with-emacs-variant
  (package-input-rewriting `((,emacs . ,emacs-variant)
                             (,emacs-minimal . ,emacs-variant)
                             (,emacs-no-x . ,emacs-variant)

                             ;; TODO maybe ths should be in a nested `package-input-rewriting' or having packages with themselves as input rewrites
                             ;; will cause problems, I donno. Putting this here for now.
                             (,(@ (gnu packages emacs-xyz) emacs-dash) . ,(@ (ebullient home packages emacs-xyz) emacs-dash)))))

;; (define-public test-reftex
;;   (with-emacs-variant (@ (gnu packages emacs-xyz) emacs-company-reftex)))
;; (define-public test-dash-existing
;;   (with-emacs-variant (@ (gnu packages emacs-xyz) emacs-dash)))
;; (define-public test-dash
;;   (with-emacs-variant (@ (ebullient home packages emacs-xyz) emacs-dash)))

;; (define orig-pkg (@ (gnu packages emacs-xyz) emacs-build-farm))
;; (define orig-pkg (@ (gnu packages emacs-xyz) emacs-cider))
(define orig-pkg (@ (gnu packages emacs-xyz) emacs-buttercup))

(define-public test-pkg
  (with-emacs-variant orig-pkg))





(use-modules (guix packages)
             (guix git-download))

(define (git-origin url commit hash recursive?)
  (origin
    (method git-fetch)
    (uri (git-reference
          (url url)
          (commit commit)
          (recursive? recursive?)))
    (sha256
     (base32
      hash))))



(use-modules (gnu packages)
             (guix profiles)
             ;; ((srfi srfi-1) #:select (remove))
             ;; (ebullient utils)
             )

;; (define (doom-ps)
;;   (->> (call-with-input-file "../doom-packaging/guix-doom-emacs-packages-from-straight-build-cache.txt" read)
;;        (remove
;;         (lambda (dpns)
;;           (member dpns (list "donnager"

;;                              "straight"

;;                              ;; TODO built-in, ignoring for now but handle this when grabbing from ~doom-packages~. It marks them as ~:ignored t~
;;                              ;; - but what about built-in 'prefer, this isn't marked specially
;;                              "hideshow"
;;                              "vc"
;;                              "vc-annotate"
;;                              "smerge-mode"
;;                              "elisp-mode"
;;                              "css-mode"

;;                              "org-elpa"
;;                              "melpa"
;;                              "gnu-elpa-mirror"
;;                              "el-get"
;;                              "emacsmirror-mirror"
;;                              ))))))

(define (emacs-ps)
  (map (lambda (x)
         (string-append "emacs-" x))
       (doom-ps)))

;; (display
;;  (map (lambda (x)
;;         (find-best-packages-by-name x #f))
;;       (emacs-ps)))

;; (display
;;  (->> (emacs-ps)
;;       (map (lambda (x)
;;              (let ((found (find-best-packages-by-name x #f)))
;;                (if (null? found)
;;                  x '()))))
;;       (remove null?)))

(use-modules (gnu packages emacs-xyz)
             (ebullient home packages emacs-xyz)
             ;; (ebullient home packages emacs-xyz-batch)
             )

(define (str->pkg x)
  (primitive-eval
   (string->symbol
    (if (equal? "emacs-git-modes" x)
        "git-modes"
        x))))

;; (let ((the-manifest
;;        (packages->manifest
;;         (map str->pkg (emacs-ps)))))
;;   ;; (display the-manifest)
;;   #f)






(use-modules ((guix base32) #:select (bytevector->nix-base32-string))
             ((guix build git) #:select (git-fetch) #:prefix other:)
             (guix build utils)
             ((guix hash) #:select (file-hash*)))

(define* (git-checkout-hash url commit #:key recursive?)
  (let ((dir (string-append "/tmp" "/8888")))
    (when (file-exists? dir)
      (delete-file-recursively dir))
    (if (other:git-fetch url commit dir
                         #:recursive? recursive?
                         ;; #:git-command (string-append #+git "/bin/git")
                         )
        (let ((hash (bytevector->nix-base32-string (file-hash* dir))))
          (delete-file-recursively dir)
          hash)
        #f)))


(define (test-get-hash)
  (display
   (git-checkout-hash
    "https://github.com/emacs-evil/evil-surround"
    "282a975bda83310d20a2c536ac3cf95d2bf188a5"
    #:recursive? #t)))

;; (test-get-hash)


(define* (find-hash doom-pkg p commit #:key recursive?)
  (let ((hasher (lambda (url)
                  (git-checkout-hash url commit #:recursive? recursive?))))
    (as-> hasher $
          ($ (if (eq? (-> p package-source origin-method) git-fetch)
                 (-> p
                     package-source
                     origin-uri
                     git-reference-url)
                 (string-append "https://github.com/emacs-straight/" doom-pkg)))
          (if $ $ "NONE_FOUND"))))

;; TODO later: maybe don't look for hashes if the requested commit is already in the Guix package
;; - and maybe if the hashes turn out to be the same after doing `git-checkout-hash', presumably
;; because the Guix package had a git tag or something but it ended up being the same as the
;; Doom-requested commit, don't save the hash? Meh.
;; TODO maybe don't write out the hashes file
;; Just cache the results somehow in the guix store so hash generation can be run as-needed
(define (hashes ps)
  (let ((commits (call-with-input-file "../doom-packaging/straight-commits.txt" read)))
    (map
     (lambda (doom-pkg)
       (let* ((p (str->pkg (string-append "emacs-" doom-pkg)))
              (commit (assoc-ref commits doom-pkg))
              (hash (find-hash doom-pkg p commit #:recursive? #t)))
         (kvm #:package doom-pkg
              #:commit commit
              #:hash hash)))
     ps)))

(define (spit f content)
  (call-with-output-file f
    (lambda (port)
      (write content port))))

;; (define write-hashes (partial spit "../doom-packaging/hashes.txt"))

;; (write-hashes
;;  (hashes (list "restart-emacs" "smartparens")))
;; (write-hashes (doom-ps))
#+end_src
****** active WIP
******* clojure part
******** clj file
I had =:tangle ebullient/src/protostar/hickeyland.clj :comments link= for the source block options here.
#+begin_src clojure :tangle no
(ns protostar.hickeyland
  (:require [clojure.alpha.spec :as s]
            [clojure.edn :as edn]
            [clojure.java.io :as io]
            [clojure.string :as str]))

;; TODO At end: just maybe try doing this, slurp, any anything else impure as some sort of "coeffects"
(defn- file-exists? [f]
  (.exists (io/file f)))


(s/defop nospec [_]
  any?)



(s/def ::str->edn (s/conformer edn/read-string)) ; TODO donno if I want to use this or just do it in clojure code (is that more idiomatic then writing a spec/conformer for everything?)


(s/def :char/blank #{\space \tab})
;; (s/def :char/newline #{\newline}) ; TODO remvoe if not needed

(s/def ::text->lines (s/conformer str/split-lines)) ; TODO donno if I want to use this or just do it in clojure code (is that more idiomatic then writing a spec/conformer for everything?)

(s/def ::str->chars (s/conformer seq))
(s/def ::chars->str (s/conformer (partial apply str)))



;; TODO would this be better / more flexible if I made it check validity (`valid?`) and then did conforming in a separate step?
;; TODO s/defop works currently but might not be the idiomatic way to do this
(s/defop s-filter [spec]
  (s/conformer
   (fn [xs]
     (keep (fn [x]
             (let [conformed (s/conform spec x)]
               (when-not (s/invalid? conformed)
                 conformed)))
           xs))))


(s/def :elisp/form any?)
(s/def :elisp/t #{t})
(s/def :elisp/list->car (s/conformer first)) ; TODO remove if not needed
(s/def :elisp/list->cdr (s/conformer next)) ; TODO remove if not needed
(s/def :elisp/plist->map (s/conformer (partial apply hash-map))) ; TODO remove if not needed
(s/def :elisp/nil-or-non-nil :elisp/form) ; TODO think this (perhaps just the name) through more?


(s/def :epkg.dep/name symbol?)
(s/def :epkg.dep/version (nospec string?))
(s/def :epkg.dep/name+ver (s/cat :name :epkg.dep/name
                                 :_version (s/? (nospec :epkg.dep/version))))
(s/def :epkg.dep/name+ver->name
  (s/conformer (fn [[form x]]
                 (case form
                   :name x
                   :name+ver (:name x)))))
(s/def :epkg/dep (s/or :name :epkg.dep/name
                       :name+ver :epkg.dep/name+ver))

(s/def :epkg/deps (s/coll-of :epkg/dep))
(s/def :epkg/deps->name-strs
  (s/coll-of (s/and
              :epkg.dep/name+ver->name
              (s/conformer str))))

;; Testing
;; (def test-deps '((emacs "24.1") another (seq) (cl-lib "0.5")))
;; (s/valid? :epkg/deps test-deps)
;; (s/explain-str :epkg/deps test-deps)
;; (s/conform :epkg/deps test-deps)
;; (s/conform
;;  (s/and
;;   :epkg/deps
;;   :epkg/deps->name-strs)
;;  test-deps)

;; TODO ideally do this better / more flexibly / maybe faster
(s/def :epkg.simple/req-header-name
  (s/&
   (s/+ char?)
   ::chars->str
   #(= "Package-Requires:" %))) ; TODO (if keeping things this way) could this just be a literal set predicate?

(s/def :epkg.simple/req-header-line
  (s/and
   ::str->chars
   (s/cat :_comment (s/&
                     (s/+ #{\;})
                     ::chars->str)
          :_ws (s/&
                (s/* :char/blank)
                ::chars->str)
          :_req-header :epkg.simple/req-header
          :_ws2 (s/&
                 (s/* :char/blank)
                 ::chars->str)
          :deps (s/&
                 (s/* char?)
                 ::chars->str
                 ::str->edn
                 :epkg/deps))))

(s/def :epkg.simple/reqs
  (s/and
   ::text->lines
   (s-filter :epkg.simple/req-header-line)
   ;; TODO spec that there should be exactly :count 1?
   (s/conformer first)
   ;; TODO what was I trying here?
   ;; (s/conformer (fn [xs]
   ;;                (or (first xs) :clojure.alpha.spec/invalid)))
   ))

;; Testing
;; (def test-pkgrequires-line ";; Package-Requires: ((emacs \"24.1\") (cl-lib \"0.5\"))")
;; (s/conform :epkg.simple/reqs (str "asdf\n" test-pkgrequires-line))
;; (s/explain-str :epkg.simple/reqs test-pkgrequires-line)

(s/def :epkg.multifile/reqs
  (s/cat :_define-package #{define-package}
         :_name (nospec string?)
         :_version (nospec :epkg.dep/version)
         :_docstring (s/? (nospec string?))
         :requirements (s/? (s/cat
                             :quote #(= (symbol (str \')) %) ; "Artifact" of `edn/read-string`.
                             :form :epkg/deps))
         :_extra (s/* (nospec nil))))

;; Testing
;; (s/conform :epkg.multifile/reqs {:pname "magit" :dir "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp"})
;; (s/conform :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp/magit-pkg.el")))
;; (s/explain-str :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp/magit-pkg.el")))
;; (s/conform :epkg.multifile/reqs "asdf")
;; (s/conform :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/drag-stuff.el/drag-stuff-pkg.el")))

;; TODO Might not need to test if file-exists for simple packages, is there always a packagename.el file? Or should always be one if there's no -pkg.el so its find to have it as a fallthrough case?
;; TODO maybe do coeffects if it's easy
;; Maybe see my now-deleted cofx attempts
(s/def :epkg/reqs->deps
  (s/or :multifile
        (s/and
         (s/conformer
          (fn [{:keys [pname dir]}]
            (let [f (str dir "/" pname "-pkg.el")]
              (if (file-exists? f)
                (-> f slurp edn/read-string)
                :clojure.alpha.spec/invalid))))
         :epkg.multifile/reqs
         (s/conformer #(get-in % [:requirements :form])))
        :simple
        (s/and
         (s/conformer
          (fn [{:keys [pname dir]}]
            (let [f (str dir "/" pname ".el")]
              (if (file-exists? f)
                (-> f slurp edn/read-string)
                :clojure.alpha.spec/invalid))))
         :epkg.simple/reqs
         (s/conformer :deps))))

(defn epkg-dependencies [name dir]
  (let [deps
        (s/conform
         (s/and
          :epkg/reqs->deps
          (s/conformer (fn [[_ reqs]] reqs))
          :epkg/deps->name-strs)
         {:pname name :dir dir})]
    (when-not (s/invalid? deps)
      deps)))

;; Testing
;; (epkg-dependencies "magit" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp")
;; (println (epkg-dependencies "dash" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/dash"))
;; (println (epkg-dependencies "helpful" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/helpful"))
;; (println (epkg-dependencies "evil" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/evil"))
;; (println (epkg-dependencies "drag-stuff" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/drag-stuff.el"))
;; (println (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/evil/evil-pkg.el"))




(s/def ::forge-repo
  (s/and
   ::str->chars
   (s/cat :user-name (s/&
                      (s/+ char?)
                      ::chars->str)
          :slash #{\/}
          :repo-name (s/&
                      (s/+ char?)
                      ::chars->str))))

(s/def ::glob string?)

(s/def ::recipe-subdirective
  (s/alt :subdir string?
         :exclude #{:exclude}))

(s/def ::recipe-defaults #{:defaults})




; TODO better sha and ref specs
(s/def :git/sha string?)
(s/def :git/ref string?)

(s/def :melpa.recipe.files/element
  (s/alt :glob ::glob
         :sublist (s/nest
                   (s/cat :subdirective ::recipe-subdirective
                          :elements (s/+ :melpa.recipe.files/element)))))
(s/def :melpa.recipe/files
  (s/cat
   :defaults (s/? ::recipe-defaults)
   :elements (s/* :melpa.recipe.files/element)))

(s/def :melpa.recipe/name symbol?)
(s/def :melpa.recipe/fetcher #{git hg github gitlab})
(s/def :melpa.recipe.vc/url string?)
(s/def :melpa.recipe.forge/repo ::forge-repo)
;; TODO nb: "commit" is used only once in all of the melpa recipes. Do doom/straight even consider it?
(s/def :melpa.recipe.git/commit (s/or :git/sha
                                      :git/ref))
(s/def :melpa.recipe.git/branch string?) ; TODO do better spec? It can be a git or hg branch, right?
;; -- originial position of :melpa.recipe/files before I moved it up --
;; TODO nb: ignoring :version-regexp and :old-names, I don't care about them, right (straight doesn't seem to)? And I'm excluding from even this validation spec stuff I don't care about, right? Or just maybe spec them but do a `s/select` that doesn't include them (or use `nospec`)? Remember to add them to :melpa.recipe/schema.

(s/def :melpa.recipe/props
  (s/schema {;; :melpa.recipe/name
             :fetcher :melpa.recipe/fetcher
             :files :melpa.recipe/files}))

(s/def :melpa.recipe/vc-props
  (s/schema {:url :melpa.recipe.vc/url}))

(s/def :melpa.recipe/forge-props
  (s/schema {:repo :melpa.recipe.forge/repo}))

(s/def :melpa.recipe/git-props
  (s/schema {:commit :melpa.recipe.git/commit
             :branch :melpa.recipe.git/branch}))

(defmulti melpa-recipe-fetcher :fetcher)

(defmethod melpa-recipe-fetcher 'git [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/vc-props
            :melpa.recipe/git-props)
   [:url]))
(defmethod melpa-recipe-fetcher 'hg [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/vc-props)
   [:url]))
(defmethod melpa-recipe-fetcher 'github [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/forge-props
            :melpa.recipe/git-props)
   [:repo]))
(defmethod melpa-recipe-fetcher 'gitlab [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/forge-props
            :melpa.recipe/git-props)
   [:repo]))

(s/def :melpa/recipe
  (s/cat
   :name (nospec :melpa.recipe/name)
   :props
   (s/&
    (s/* :elisp/form)
    #(even? (count %))
    :elisp/plist->map
    (s/multi-spec melpa-recipe-fetcher :fetcher))))

;; Testing
;; (def test-melpa-recipe '(yasnippet :repo "joaotavora/yasnippet"
;;                                    :fetcher github
;;                                    :files ("yasnippet.el" "snippets")))
;; (s/conform :melpa/recipe test-melpa-recipe)
;; (s/explain-str :melpa/recipe test-melpa-recipe)



(s/def :straight.recipe-repo/name symbol?)

(s/def :straight.recipe/name symbol?) ; Maybe spec this so I can accept the argument to `straight-use-package` (for other users who use straight): doom doesn't take this just the rest of the recipe plist. Update: also need it for :includes.
(s/def :straight.recipe/local-repo string?)
;; TODO maybe some of the sub-stuff in :straight.recipe/files should be `nospec` or have leading keywork underscores.
(s/def :straight.recipe/files
  (s/*
   (s/alt :glob ::glob
          :pair (s/cat :car string?
                       :dot #{.}
                       :cdr string?)
          :sublist (s/nest
                    (s/cat :subdirective ::recipe-subdirective
                           :elements (s/+ :straight.recipe/files)))
          :defaults ::recipe-defaults)))
(s/def :straight.recipe/flavor #{melpa})
(s/def :straight.recipe/build any?) ; TODO. Had #{nil t}, it would be better to use :elisp/t but set specs take literal, not spec, values
(s/def :straight.recipe/pre-build any?) ; TODO
(s/def :straight.recipe/post-build any?) ; TODO
(s/def :straight.recipe/type #{git built-in})
(s/def :straight.recipe/source (s/or :one :straight.recipe-repo/name
                                     :many (s/coll-of :straight.recipe-repo/name)))
(s/def :straight.recipe/includes (s/or :one :straight.recipe/name
                                       :many (s/coll-of :straight.recipe/name)))
(s/def :straight.recipe/inherit :elisp/nil-or-non-nil)
(s/def :straight.recipe.git/host #{nil github gitlab bitbucket})
(s/def :straight.recipe.git/branch string?)
(s/def :straight.recipe.git/remote string?)
(s/def :straight.recipe.git/nonrecursive :elisp/nil-or-non-nil)
(s/def :straight.recipe.git/fork any?) ; TODO
(s/def :straight.recipe.git/depth (s/or :full #{full}
                                        :n integer?))
(s/def :straight.recipe.git/protocol #{https ssh})
(s/def :straight.recipe.git/upstream any?) ; TODO


(s/def :straight.recipe/props
  (s/schema {;; :straight.recipe/name
             :local-repo :straight.recipe/local-repo
             :files :straight.recipe/files
             :flavor :straight.recipe/flavor
             :build :straight.recipe/build
             :pre-build :straight.recipe/pre-build
             :post-build :straight.recipe/post-build
             :type :straight.recipe/type
             :source :straight.recipe/source
             :includes :straight.recipe/includes
             :inherit :straight.recipe/inherit}))

(s/def :straight.recipe/git-props
  (s/schema {;; :repo :straight.recipe.git/repo
             :host :straight.recipe.git/host
             :branch :straight.recipe.git/branch
             :remote :straight.recipe.git/remote
             :nonrecursive :straight.recipe.git/nonrecursive
             :fork :straight.recipe.git/fork
             :depth :straight.recipe.git/depth
             :protocol :straight.recipe.git/protocol
             :upstream :straight.recipe.git/upstream}))


(s/def :straight/repository-url string?)

(defmulti straight-recipe-git-host :host)

(defmethod straight-recipe-git-host nil [_]
  (s/select {:repo :straight/repository-url} [:repo]))
(defmethod straight-recipe-git-host 'github [_]
  (s/select {:repo ::forge-repo} [:repo]))
(defmethod straight-recipe-git-host 'gitlab [_]
  (s/select {:repo ::forge-repo} [:repo]))
(defmethod straight-recipe-git-host 'bitbucket [_]
  (s/select {:repo ::forge-repo} [:repo]))


(def straight-default-vc 'git)

(defmulti straight-recipe-type #(get % :type straight-default-vc))

(defmethod straight-recipe-type 'git [_]
  (s/and
   (s/union :straight.recipe/props
            :straight.recipe/git-props)
   (s/multi-spec straight-recipe-git-host :host)))
(defmethod straight-recipe-type 'built-in [_]
  (s/schema {}))


(s/def :straight.recipe/props-asdf
  (s/&
   (s/* :elisp/form)
   #(even? (count %))
   :elisp/plist->map
   (s/multi-spec straight-recipe-type :type)))

;; TODO I don't think I need this for anything
(s/def :straight/recipe
  (s/cat
   :name (nospec :straight.recipe/name)
   :props :straight.recipe/props-asdf))


(s/def :doom.package/name symbol?)
(s/def :doom.package/type #{core local built-in virtual}) ; Depending on where I'm doing "checking for stuff I explicitly don't support" either remove local/built-in/(maybe)virtual here or check for them elsewhere
(s/def :doom.package/recipe :straight.recipe/props-asdf)
(s/def :doom.package/disable :elisp/t)
(s/def :doom.package/ignore :elisp/t)
(s/def :doom.package/pin :git/sha)
;; TODO nb: not speccing :modules (for now?)

(s/def :doom.package/props
  (s/schema {:type :doom.package/type
             :recipe :doom.package/recipe
             :disable :doom.package/disable
             :ignore :doom.package/ignore
             :pin :doom.package/pin}))

(s/def :doom/package
  (s/cat
   :name :doom.package/name
   :props
   (s/&
    (s/* :elisp/form)
    #(even? (count %))
    :elisp/plist->map
    :doom.package/props)))


#_(defn parse-doom-packages []
  (as-> (slurp "/home/pharcosyle/work/phrenetic/doom-packaging/my-doom-packages.el") $
    (edn/read-string $)
    (map parse-doom-package $)
    ;; TODO later: this is Doom-specific, move it out of the main "guix-emacs-generator"
    (remove #(= (:package/name %) "straight") $)
    (remove :package/deactivated? $)))



(s/def ::todo any?)

;; (s/def :fex.repo/user-name ::todo)
;; (s/def :fex.repo/repo-name ::todo)
;; (s/def :fex/repo
;;   (s/schema [:fex.repo/user-name
;;              :fex.repo/repo-name]))

(s/def :fex.package/url ::todo)
;; (s/def :fex.package/forge #{:forge/github
;;                             :forge/gitlab
;;                             ;; :forge/bitbucket
;;                             })
;; (s/def :fex.package.forge/repo :fex/repo) ; TODO maybe just use :fex/repo or ::forge-repo (and make the current ::forge-repo be ::forge-repo-str or something)
(s/def :fex.package/branch ::todo)
(s/def :fex.package/nonrecursive? #{true})
(s/def :fex.package/files :melpa.recipe/files) ; TODO This is "inheritance", maybe make this a "shared" spec like ::recipe-defaults or just allow :melpa.recipe/files as a key in :fex/package (maybe even rename it to ::melpa-style-files or something)

(s/def :fex/package
  (s/schema [:fex.package/url
             ;; :fex.package/forge
             ;; :fex.package.forge/repo
             :fex.package/branch
             :fex.package/nonrecursive?
             :fex.package/files]))





(def ^:private forge-domains
  {'github "github.com"
   'gitlab "gitlab.com"
   'bitbucket "bitbucket.com"})

(defn forge-repo-url [forge user-name repo-name]
  (str "https://" (get forge-domains forge) "/" user-name "/" repo-name ".git"))


(require '[clojure.set :refer [rename-keys]])
(defn select-and-rename-keys [m kmap]
  (as-> m $
    (select-keys $ (keys kmap))
    (rename-keys $ kmap)))






(defmacro defkmultis [& methods]
  (let [create (fn [name]
                 `(defmulti ~name ~(fn [k & _] k)))]
    `(do
       ~@(map create methods))))

(defmacro defkmethods [k & methods]
  (let [register
        (fn [[name argslist & body]]
          `(defmethod ~name ~k ~(vec (cons '_ argslist)) ~@body))]
    `(do
       ~@(map register methods))))





;; Archives
(defkmultis
  ;; has-recipe
  get-recipe) ; TODO maybe rename this get-package or something, I'm returning fex packages, not straight/melpa recipes


(defn gnu-elpa-mirror-recipe-filename [p]
  (str "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/gnu-elpa-mirror" "/" p))

(defkmethods
  :archive/gnu-elpa-mirror
  (get-recipe [p] (let [f (gnu-elpa-mirror-recipe-filename p)]
                    ;; TODO straight checks against straight-recipes-gnu-elpa-ignored-packages for this archive, I might need to do that too. There are other notes on this already.
                    (when (file-exists? f)
                      {:fex.package/url (forge-repo-url
                                         (symbol :github) "emacs-straight" p)
                       :fex.package/files {:elements [[:glob "*"]]}})))) ; TODO straight also has ~(:exclude ".git")~ here but I don't think I need that.

(defn melpa-recipe-filename [p]
  (str "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/melpa/recipes" "/" p))

(defkmethods
  :archive/melpa
  ;; (has-recipe [p] (file-exists? (melpa-recipe-filename p)))
  (get-recipe [p] (let [f (melpa-recipe-filename p)]
                    (when (file-exists? f)
                      (let [text (slurp f)
                            parsed
                            (s/conform (s/and
                                        ::str->edn
                                        :melpa/recipe
                                        (s/conformer :props))
                                       text)]
                        ;; TODO check that `parsed` is not invalid?
                        ;; TODO "supported"-ness: this might be the place to check that the melpa recipe fetcher isn't 'hg. Alternatively, or perhaps preferably (it would match straight's behavior) just report there's no package if the fetcher is 'hg (or isn't 'git, 'github, or 'gitlab)
                        ;; TODO additional things straight does for this archive: adds -pkg.el to :files and sets flavor to melpa. Donno if I need these. There are other todos/notes on these already
                        (merge
                         {:fex.package/url (let [fetcher (:fetcher parsed)]
                                             (condp some #{fetcher}
                                               #{'git} (:url parsed)
                                               #{'github 'gitlab} (let [repo (:repo parsed)]
                                                                    (forge-repo-url
                                                                     fetcher
                                                                     (:user-name repo)
                                                                     (:repo-name repo)))))}
                         (select-and-rename-keys
                          parsed {:branch :fex.package/branch
                                  :files :fex.package/files})
                         ;; TODO not using, remove
                         ;; (when-let [files (:files parsed)]
                         ;;   {:fex.package/files (s/unform :melpa.recipe/files files)})
                         ))))))

;; Testing
;; (get-recipe :archive/melpa "yasnippet")

;; TODO I don't think the lisp/* bits are necessary since these already have :defaults but for now I've copied the :files over just like they are in straight.
(defkmethods
  :archive/org-elpa
  (get-recipe [p] (case p
                    "org"
                    {:fex.package/url "https://git.savannah.gnu.org/git/emacs/org-mode.git"
                     :fex.package/files {:defaults :defaults
                                         :elements [[:glob "lisp/*.el"]
                                                    [:sublist
                                                     {:subdirective [:subdir "etc/styles/"]
                                                      :elements [[:glob "etc/styles/*"]]}]]}}
                    "org-contrib"
                    {:fex.package/url "https://git.sr.ht/~bzg/org-contrib"
                     :fex.package/files {:defaults :defaults
                                         :elements [[:glob "lisp/*.el"]]}}
                    nil)))


;; TODO make this configurable (of course) and probably not global (pass it as an argument to functions that use it)
(def archives [:archive/org-elpa
               :archive/melpa
               :archive/gnu-elpa-mirror])

;; TODO probably add emacsmirror, etc archives but make all of the methods throw an exception stating that they're not implemented "yet".
;; (def archive-priority [:archive/org-elpa
;;                        :archive/melpa
;;                        :archive/gnu-elpa-mirror])

;; TODO maybe a way to get these from Doom programatically is to advise `straight-use-recipes` but then I'd have to run `doom--ensure-straight` as well
;; (def doom-recipe-repos
;;   '((org-elpa :local-repo nil)
;;     (melpa              :type git :host github
;;                         :repo "melpa/melpa"
;;                         :build nil)
;;     (gnu-elpa-mirror    :type git :host github
;;                         :repo "emacs-straight/gnu-elpa-mirror"
;;                         :build nil)
;;     (el-get             :type git :host github
;;                         :repo "dimitri/el-get"
;;                         :build nil)
;;     (emacsmirror-mirror :type git :host github
;;                         :repo "emacs-straight/emacsmirror-mirror"
;;                         :build nil)))
;; (def doom-straight-recipe-repositories
;;   '(org-elpa melpa gnu-elpa-mirror el-get emacsmirror-mirror))




(require '[clojure.java.shell :refer [sh]])
(def eb-dir "/home/pharcosyle/work/phrenetic/ebullient")
(def guix-repl-cmd ["guix" "repl" "-L" "." "--" "ebullient/home/packaging-runner.scm"])
(defn sh-call [f & args]
  (apply sh (concat guix-repl-cmd
                    [(name f)]
                    (map pr-str args)
                    [:dir eb-dir])))
;; (sh-call :guix/asdf 6)
(def get-origin-data (partial sh-call :guix/get-origin-data))







(defn get-archive-package [archives package-name]
  (first (map #(get-recipe % package-name) archives)))

(defn package-with-inheritance [package-name package]
  (merge
   (get-archive-package package-name)
   package))






(defn convert-straight-recipe-props-to-package [props]
  (let [; parsed (s/conform :straight.recipe/props-asdf props)
        parsed props]
    ;; TODO check that `parsed` is not invalid?
    ;; TODO "supported"-ness: is this the place to check that there aren't unsupported keys and provided keys have supported values (including that the :files is a valid /melpa/ :files)?
    (merge
     {:fex.package/url
      (let [{:keys [host repo]} parsed]
        (if host
          (forge-repo-url
           host
           (:user-name repo)
           (:repo-name repo))
          repo))}
     (select-and-rename-keys
      parsed {:branch :fex.package/branch})
     (when (:nonrecursive parsed)
       {:fex.package/nonrecursive? true})
     (when-let [files (:files parsed)]
       ;; TODO donno why I want to do it this convoluted way, maybe because I don't want to use the "raw" props?
       {:fex.package/files
        ;; (s/conform :melpa.recipe/files props)
        (->> files
             (s/unform :straight.recipe/files)
             (s/conform :melpa.recipe/files))}))))




;; (def my-doom-packages-test "/home/pharcosyle/work/phrenetic/doom-packaging/my-doom-packages.el")
;; (def my-doom-packages-test "/home/pharcosyle/work/phrenetic/doom-packaging/my-doom-packages-edited.el")
(def my-doom-packages-test "/home/pharcosyle/work/phrenetic/doom-packaging/my-doom-packages-small.el")

(defn test-packages []
  (let [data (-> my-doom-packages-test
                 slurp
                 edn/read-string)
        conformed (s/conform (s/coll-of :doom/package) data)]
    ;; (s/explain (s/coll-of :doom/package) data)
    (as-> conformed $
      (map #(get-in % [:props :recipe]) $)
      (map convert-straight-recipe-props-to-package $))))

;; (test-packages)





(def straight-allow-recipe-inheritance? true)

;; TODO Ideally I think I want to grab any pertinent straight settings from Doom Emacs
;; By serializing them "in the same run" as when I grab e.g `doom-packages`. Update: but wait I won't have straight installed when I do this, perhaps scrape the straight code for sexps or maybe it'll be enough to just get the ones that Doom sets itself (see core-packages.el line 78-97)
;; - default protocol, allow inheritance, the recipe repos Doom sets up, etc
;; - straight-default-vc
;; - look through straight's ~defcustom~s
(def defaults {:recipe/protocol "https"})
;; maybe?:
;; :files '("*.el" "*.el.in" "dir"
;;          "*.info" "*.texi" "*.texinfo"
;;          "doc/dir" "doc/*.info" "doc/*.texi" "doc/*.texinfo" "lisp/*.el"
;;          (:exclude ".dir-locals.el" "test.el" "tests.el" "*-test.el" "*-tests.el")

;; TODO regarding :flavor: read `straight-expand-files-directive' and see if I need this / what I should do about :files. Also read the melpa readme about the rules it has for expanding its :files property
;; - :melpa/recipe shouldn't have a flavor, right? Just straight recipes?
;; - new thoughts
;;   - I might need it to make sure template files are copied over "before build", does that make sense I can't be fucked to think through the ordering at present
;;   - If I do need to consider .el.in files perhaps I can prepreocess the :fex.package/files returned from the melpa archive (but that might not be feasable, the .el.in logic is deep in the melpa/straight files expansion logic)
;;   - The Guix elpa importer doesn't even consider .el.in files, maybe they're super rare
;;   - nb: straight recipe inheritance logic includes :flavor and I'm not presently doing that
;;   - reconcile the Guix elpa importer's file expansion logc with melpa's to make sure it's thorough (not straight's, it's different, but do look it over afterwards anyway)
;; TODO downloading to a cache like the elpa importer does would speed up successive/reattempted runs, no?
;; - assuming that is what it's doing (check). Do those repo caches stick around forever though? Will adding my own interfere with anything?
;; - if it's /really/ fast maybe I could get rid of the later-to-come bump "scripts"'s need to read an existing list of generated packges at all! I wouldn't even have to save it to disk, just the lockfile!
;;   - even if the guix git repositories cache thing is untenable maybe there's some other cache I could write the repos or the generated packages-with-hashes to, even just ~./cache. I'd like to not have to manage a generated packages file if I don't have to
;; TODO handle :host: search "bitbucket" in straight to see stuff that affects hosts. If necessary add a check to make sure a supported host is provided.
;; TODO use value of `straight-built-in-pseudo-packages' (let-alist emacs nadvice python) in addition to elpa.scm's `emacs-standard-library?'? What about `straight-recipes-gnu-elpa-ignored-packages'? What about straight--package-built-in-p and package--builtins (read its doc)?
;; - Straight claims to be able to "deal with built-in packages" even without this variable. How? Something like hlissner does when :built-in is set to 'prefer? Use one
;;   of these approaches instead of making a (brittle) list of built-in pseudo packages?
;; - Remember, sometimes even if a package is built-in it should still be installed (like org)
;; - unrelated: are there any built-in dependencies with newer upstream/external versions? Do I want them?
;;   Perhaps not even proper versions just newer commits in a git repo
;; TODO always include *pkg.el like straight.el::3168 says?
;; Is that just about making sure that dependencies get resolved? It says "linked over" though. But then why wouldn't the other `straight-recipes-REPO-retrieve' methods have it? For
;; the elpa one at least it could be because it includes everything (=:files "*"=)
;; - also see the github melpa readme: "For multi-file packages, the file <NAME>-pkg.el is automatically generated..."
;; - update: shit is the /built/ package (after the :files directive has been "applied", among other things) used for determining dependencies? That's the way straight does it, I was just going to use the "raw" cloned repo to find dependencies. Note that e.g. ghub, magit-secion have their -pkg.el files in a subfolder so assuming -pkg.el lives in the root of the unbuilt repo isn't going to work the way I have it now. Conceivably the same could be true of a regular packagename.el file: it could be in a subdirectory.
;;   - I'll probably have to build the package before I get dependencies like straight does. Is there anything else about building the package, besides doing the :files copying/linking, that could affect the packagename.el and packagename-pkg.el files and thus dependency resolution?
;; TODO do I actually need :includes / consider the org-elpa pseudo repository (look at straight-recipes-org-elpa-retrieve in particular)
;; I think the Doom package declarations of org/org-contrib are inheriting from org-elpa and all that stuff it does with :includes and maybe other stuff /does/ matter?
;; - how does Guix handle org? One package, multiple?
;; TODO consider `straight--convert-recipe'
;; TODO consider straight-built-in-pseudo-packages
;; esp. in straight--convert-recipe
;; TODO consider how straight.el recipe inheritance works
;; esp. in straight--convert-recipe

;; TODO hack
;; Wait to do this until the end when I have a concrete idea of all the stuff I'll have to read (doom packages, melpa recipes...) and how I want to do it.
;; Ideas:
;; - hack scm/edn.scm somehow?
;; - convert `doom-packages` (and melpa recipes) package names to strings on the elisp side
;;   Would be messy with melpa recipes since there's no "elisp-reading phase"
;; - elisp "parseclj"/"parseedn" are nice but they don't solve the 0x0 problem
;;   Are they worth the additional overhead of running them on the elisp side? Again, with melpa there might not /be/ an elisp side
;;   - nice to have but maybe not necessary: handling dotted pairs, t/nil become true/nil
;; - don't use the 0x0 package
(defn icky [x]
  (if (= x "0")
    "0x0" x))

;; TODO probably do this with spec, but wait until a bit later / the end
;; (if-let [unsupported (seq (filter (fn [p]
;;                                       (or (let [type (get p :doom.package/type)]
;;                                             (some (hash-set type) (vector :doom.package.type/local :doom.package.type/built-in)))
;;                                           (let [vc (get-in p (vector :package/recipe :recipe/vc))]
;;                                             (and vc (not= vc :vc/git)))
;;                                           (get-in p (vector :package/recipe :straight.recipe/protocol))
;;                                           (get-in p (vector :package/recipe :straight.recipe/source))
;;                                           (get-in p (vector :package/recipe :straight.recipe/fork))
;;                                           (get-in p (vector :package/recipe :straight.recipe/upstream))
;;                                           (get-in p (vector :package/recipe :straight.recipe/includes))))
;;                                   $))]
;;         (throw (ex-info "Package(s) with unsupported configuration" {:packages unsupported}))
;;         $)
;; TODO NEW stuff I've decided I'm /definitely/ not supporting: fork, source
;; - don't support :build. (At leat for values other than 't, which is harmless and which Doom's org package declaration uses. Maybe just override the Doom org package like I'm going to do for its :pre-build)
;; - don't support :pre-build/:post-build (Doom's org and notmuch packages use :pre-build though, so find probably override those recipes to not have :pre-build steps and make sure the Guix packages for them do what the :pre-build steps would have done).
;; - probably not supporting manually-set inherit property (and straight-allow-recipe-inheritance must be true)
;; - list of straight package props Doom actually uses
;;   host
;;   repo
;;   files
;;   nonrecursive
;;   branch
;;   local-repo
;;   - Only straight has this and it doesn't matter for me
;;   build
;;   - only org (:build t)
;;   pre-build
;;   - only org and notmuch
;;   depth
;;   - only org (:depth 1)
;; - spec that both host and repo must be specified so in inheritance one isn't overridden without the other?
#+end_src
******** deps
Had =:tangle ebullient/deps.edn :comments link=
#+begin_src clojure :tangle no
{:paths ["src" "resources"]
 :deps {org.clojure/clojure {:mvn/version "1.11.1"}
        org.clojure/alpha.spec {:git/url "https://github.com/clojure/spec-alpha2.git"
                                :sha "99456b1856a6fd934e2c30b17920bd790dd81775"}
        babashka/fs {:mvn/version "0.1.6"}}
 :aliases
 {:run-m {:main-opts ["-m" "protostar.hickeyland"]}
  :run-x {:ns-default protostar.hickeyland
          :exec-fn greet
          :exec-args {:name "Clojure"}}
  :build {:deps {io.github.seancorfield/build-clj
                 {:git/tag "v0.6.3" :git/sha "9b8e09b"
                  ;; since we're building an app uberjar, we do not
                  ;; need deps-deploy for clojars.org deployment:
                  :deps/root "slim"}}
          :ns-default build}
  :test {:extra-paths ["test"]
         :extra-deps {org.clojure/test.check {:mvn/version "1.1.1"}
                      io.github.cognitect-labs/test-runner
                      {:git/tag "v0.5.0" :git/sha "48c3c67"}}}}}
#+end_src
******* guix part
Had =:tangle ebullient/lokke/ns/ebullient/home/packaging-wip.clj :comments link=
#+begin_src clojure :tangle no
(ns ebullient.home.packaging-wip
  (:require [guile :refer [command-line]]
            [guile.guix.base32 :refer [bytevector->nix-base32-string]]
            [guile.guix.git :refer [latest-repository-commit]]
            [guile.guix.hash :refer [file-hash*]]
            [guile.guix.store :refer [with-store]]
            [guile.srfi.srfi-11 :as srfi-11]

            [guile.guix.build-system.emacs :refer [emacs-build-system]]
            [guile.guix.git-download :refer [git-fetch git-reference git-file-name]]
            [guile.guix.packages :refer [package origin content-hash]]))

(defn- pair [a b]
  (guile/cons a b))

(defmacro let-values [bindings & body]
  (let [bindings*
        (->> bindings
             (partition 2)
             (map (fn [[names expr]]
                    (list
                     (apply list names) expr))))]
    `(srfi-11/let-values ~bindings*
       ~@body)))

(defn- download-git-repo! [url [ref' ref''] recursive?]
  (let-values
   [[dir commit]
    (with-store store
      (latest-repository-commit store url
                                :ref (pair (symbol ref') ref'')
                                :recursive? recursive?))]
   {:dir dir :commit commit}))

;; (println
;;  (download-git-repo! "https://github.com/raxod502/straight.el.git" [:branch "develop"] false))
;; (println
;;  (download-git-repo! "https://github.com/minad/consult.git" '()))

(defn get-origin-data [url ref recursive?]
  (let [{:keys [dir commit]} (download-git-repo! url ref recursive?)]
   {:commit commit
    :hash (bytevector->nix-base32-string
           (file-hash* dir))}))

;; (println
;;  (get-origin-data "https://github.com/raxod502/straight.el.git" [:branch "develop"] false))





(defn fex-package [package-name url commit recursive? hash]
  (package
   (name (str "emacs-" package-name))
   (version "0.0.1")
   (source
    (origin
     (method git-fetch)
     (uri (git-reference
           (url url)
           (commit commit)
           (recursive? recursive?)))
     (file-name (git-file-name name version))
     (hash
      (content-hash hash))))
   (build-system emacs-build-system)
   ;; (arguments
   ;;  `(#:phases
   ;;    (modify-phases %standard-phases
   ;;      (add-after 'unpack 'move-source-files
   ;;        (lambda _
   ;;          (let ((el-files (find-files "./extensions" ".*\\.el$")))
   ;;            (for-each (lambda (f)
   ;;                        (rename-file f (basename f)))
   ;;                      el-files)))))))
   ;; (native-inputs
   ;;  (list texinfo))
   (home-page nil)
   (synopsis nil)
   (description nil)
   (license nil)))

;; (println
;;  (fex-package "tldr"
;;               "https://github.com/kuanyui/tldr.el"
;;               "7203d1be3dcbf12131846ffe06601933fa874d74"
;;               nil
;;               "1bw6la463l2yfm7rp76ga4makfy4kpxgwi7ni5gxk31w11g26ryk"))




;; (defn call [nm & args]
;;   (let [f (ns-resolve *ns* (symbol nm))]
;;     (apply f args)))

(defn asdf [n]
  (+ 1 n))

(when (< (count (command-line)) 1) ; temporarily let me run this file manually
  (let [f (-> (command-line) second)
        args (-> (command-line) next next)]
    (println
     (let [func
           (case f
             "asdf" asdf)]
       (apply func (map read-string args))))))
#+end_src
******* packaging runner
Had =:tangle (meta-in-dir "packaging-runner.scm")=
#+begin_src scheme :tangle no
(use-modules (lokke ns))
(require #(ebullient.home.packaging-wip))
#+end_src
******* test clj
Had =:tangle ebullient/lokke/ns/ebullient/home/test-clj.clj :comments link=
#+begin_src clojure :tangle no
(ns ebullient.home.test-clj
  (:require [guile.guix.gexp :as g]
            [guile.guix.packages :refer [package package-description]]))

(println
 (gexp "asdf"))

;; (println
;;  (p/package (name "asdf")))

;; (println
;;  (package-description
;;   (package
;;     (name "asdf")
;;     (version "0")
;;     (source nil)
;;     (build-system nil)
;;     (synopsis "asdf")
;;     (description "asdf3333")
;;     (home-page nil)
;;     (license nil))))

(+ 1 1)
(println 5)

#+end_src
******* test scm
Had =tangle (meta-in-dir "test-scm.scm")=
#+begin_src scheme :tangle no
(use-modules (lokke ns))
(require #(ebullient.home.test-clj))
#+end_src
******* elisp
Had =:tangle (meta-in-dir "parse-doom-packages.el")=
#+begin_src elisp :tangle no
(defun m-slurp (f)
  (with-temp-buffer
    (insert-file-contents f)
    (buffer-string)))

(defun m-spit (f content)
  (with-temp-file f
    (insert content)))




(defun m-process ()
  (-as-> (m-slurp "~/work/phrenetic/doom-packaging/my-doom-packages.el") $
         (read $)
         (-map #'-first-item $)
         (-map #'symbol-name $)))

(defun write-doom-pkgs-txt ()
  (m-spit "doom-packaging/guix-doom-emacs-packages.txt"
          (pp (m-process))))





(defun repo-commit (r)
  (let ((default-directory (concat "~/.local/var/lib/doom-local/straight/repos/" r)))
    (straight--process-output "git" "rev-parse" "HEAD")))

(defun write-current-commits ()
  (let ((pkgs-to-repos
         (-map
          (lambda (x)
            (cons
             (-first-item x)
             (-as-> x $
                    (-fourth-item $)
                    (plist-get $ :local-repo))))
          (map-into straight--build-cache 'list))))
    (-map (lambda (x)
            (cons (car x)
                  (if-let ((y (cdr x)))
                      (if (not (equal y "/home/pharcosyle/work/dotfiles/donnager"))
                          (repo-commit y)
                        nil)
                    y)))
          pkgs-to-repos)))

;; (write-current-commits)
#+end_src
**** Doom private
:PROPERTIES:
:meta-dir+: /doom-private
:END:

#+name: palette
| Name              | Color   |
|-------------------+---------|
| fg                | #dee2f8 |
| highlight         | #8496ff |
| comments          | #63677f |
| comment-delimiter | #939abd |
| red               | #fb8578 |
| orange            | #fdce5f |
| green             | #9fed9c |
| yellow            | #eddc91 |
| blue              | #7db9fe |
| dark-blue         | #5f68de |
| magenta           | #e29bf7 |
| violet            | #aeb9f3 |
| cyan              | #75e0f9 |
| gold              | #fdd94a |
| pink              | #ff9999 |

***** Init
#+begin_src elisp :tangle (meta-in-dir "init.el")
;;; -*- lexical-binding: t; -*-

(doom! :completion
       (company +childframe)
       (vertico +icons)

       :ui
       doom
       doom-dashboard
       (emoji +unicode)
       hl-todo
       hydra
       indent-guides
       (ligatures +extra)
       modeline
       nav-flash
       ophints
       (popup +defaults +all)
       treemacs
       (vc-gutter +pretty) ; I tried `+diff-hl' but it was kind of buggy so wait on this. See https://github.com/doomemacs/doomemacs/commit/27a448b04b8173038eb2c2592298fb37451eb227
       vi-tilde-fringe
       window-select
       workspaces

       :editor
       (evil +everywhere)
       file-templates
       fold
       format
       lispy
       multiple-cursors
       rotate-text
       snippets
       word-wrap

       :emacs
       (dired +icons)
       electric
       (ibuffer +icons)
       undo
       vc

       :term
       eshell
       vterm

       :checkers
       (syntax +childframe)

       :tools
       direnv ; TODO should be contributed by direnv component
       (eval +overlay)
       lookup
       (magit +forge)
       (pass +auth)
       pdf
       prodigy ; TODO dependency of hyperdrive. Keep it enabled by default too.
       rgb
       taskrunner
       tree-sitter
       ;; upload ; TODO dependency of massrealty/phucnet

       :lang
       clojure ; TODO contribute this with some Clojure module/compnent /if I end up having one/ (maybe along with the WIP clojure manifest)
       common-lisp ; TODO this should be contributed by Nyxt / my eventual nyxt project
       data
       emacs-lisp
       ;; graphql ; TODO dependency of krush/hyperdrive
       (json +tree-sitter)
       (javascript +tree-sitter)
       markdown
       (nix +tree-sitter) ; TODO this should be gated by Nix inclusion like system components do.
       (org +journal)
       (rest +jq)
       (scheme +guile) ; TODO Should be contributed by some Guix component (also the guix-related packages.el entries and stuff in config)
       (sh +tree-sitter)
       (web +tree-sitter)
       yaml ; TODO this should probably be specific to the krush/hyperdrive/afterburner(?) project

       :app
       calendar

       :config
       (default +bindings +smartparens))
#+end_src
***** Config
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "config.el")
:END:
#+begin_src elisp
;;; -*- lexical-binding: t; -*-
#+end_src
****** Doom Guix module params
#+begin_src elisp
(load! "params")
#+end_src
****** Requires
#+begin_src elisp
(use-package! dash)
(use-package! s)
#+end_src
****** Personal Info :user:
#+begin_src elisp
(setq user-mail-address param-email)
#+end_src
****** Locals :path:
#+begin_src elisp
(defconst biome--org-dir (concat org-directory "~/org"))
(defconst biome--org-gcal-dir (concat biome--org-dir "/gcal"))

(defconst biome--very-big 1000000)

(defconst biome--nuclear-theme 'doom-nuclear)
#+end_src
#+begin_src elisp :var palette=palette
(defun biome--color (color)
  (let ((k (-> color symbol-name (substring 1))))
    (cadr (assoc k palette))))
#+end_src
****** General :UI:path:
#+begin_src elisp
;; hlissner says this must be set before org loads. I'm not sure if this is a requirement of org-mode but the Doom org config certainly does a lot of gymnastics with this variable so I'll just set this exactly like the example config does.
(setq org-directory biome--org-dir)

(setq scroll-margin 10
      save-interprogram-paste-before-kill t)

;; I like having line numbers on but hlissner says they're slow so I might want to disable them at some point. Keep in mind I use them to determine what lines are continuation lines so I might have to make the right fringe bigger if I do this and set visual-line-fringe-indicators.
;; (setq display-line-numbers-type nil)
#+end_src
******* Doom resets
#+begin_src elisp
(setq-default indent-tabs-mode t)

;; I'd like to have this on but in the Doom code it says it's more efficient not to.
;; (setq-default cursor-in-non-selected-windows t)
#+end_src
******* Doom
#+begin_src elisp
;; REVIEW Might be useful if there end up being a lot more of these and they have a lot of similarities: https://www.gnu.org/software/emacs/manual/html_node/elisp/Extending-Rx.html
(add-hook! 'doom-real-buffer-functions
  ;; (defun biome-new-buffer-p (buf)
  ;;   (s-matches?
  ;;    (rx bol "*new*"
  ;;        (* "<" (+ digit) ">")
  ;;        eol)
  ;;    (buffer-name buf)))
  ;; TODO This should be in my Org config section / module but wait to move it until I'm confident I'll be continuing with this marking-buffers-as-real approach.
  (defun biome-org-src-edit-buffer-p (buf)
    (s-matches?
     (rx bol "*Org Src " (+ anything) "*"
         (* "<" (+ digit) ">")
         eol)
     (buffer-name buf))))
#+end_src
****** Keybindings :bindings:
#+begin_src elisp
(setq help-char (string-to-char "\C-_"))
#+end_src
******* Translations
#+begin_src elisp
(defun biome--trans (&rest rest)
  (-each (-partition 2 rest)
    (-lambda ((to from))
      (define-key key-translation-map (kbd to) (kbd from)))))

(biome--trans "C-h" "DEL"
              "C-?" "C-h"

              "s-h" "<left>"
              "s-j" "<down>"
              "s-k" "<up>"
              "s-l" "<right>")
#+end_src
******* Leader/localleader
#+begin_src elisp
(setq doom-leader-alt-key "s-SPC"
      doom-localleader-key "s-m"
      doom-localleader-alt-key "s-m")
#+end_src
******* General
#+begin_src elisp
(defalias 'original-yank-pop #'yank-pop)

;; REVIEW Some of these should be in `:after' (or their respective package) sections but I'm not totally certain where I want to put bindings yet and I'm lazy.
(map! "s-V" #'original-yank-pop

      "s-SPC" doom-leader-map

      ;; Adapted from Doom macOS bindings: ~/.config/emacs/modules/config/default/config.el:263
      "s-`" #'other-frame
      "s-n" #'+default/new-buffer
      "s-z" #'undo
      "s-Z" #'redo
      "s-c" (if (featurep 'evil) #'evil-yank #'copy-region-as-kill)
      "s-v" #'yank
      "s-s" #'save-buffer
      "s-x" #'execute-extended-command
      ;; REVIEW I don't think I need this, any time I'm in visual mode I can use `evil-delete` ("d")
      ;; :v "s-x" #'kill-region
      "s-/" (cmd! (save-excursion (comment-line 1)))
      :n "s-/" #'evilnc-comment-or-uncomment-lines
      :v "s-/" #'evilnc-comment-operator

      "s-t" (lookup-key doom-leader-map (kbd "`"))
      "s-f" (lookup-key doom-leader-map (kbd "s b"))
      "s-r" (lookup-key doom-leader-map (kbd "f r"))
      "s-w" (lookup-key doom-leader-map (kbd "b k"))
      "s-d w" (lookup-key doom-leader-map (kbd "w d"))
      "s-d s-w" (cmd! (kill-current-buffer)
                      (+workspace/close-window-or-workspace))
      "s-g" (lookup-key doom-leader-map (kbd "g g"))
      "s-," (lookup-key doom-leader-map (kbd "w w"))
      "s-<" (lookup-key doom-leader-map (kbd "w W"))
      "s-y" (lookup-key doom-leader-map (kbd "i y"))
      "s-{" (lookup-key doom-leader-map (kbd "b p"))
      "s-}" (lookup-key doom-leader-map (kbd "b n"))
      "s-p" (lookup-key global-map (kbd "C-~")) ; TODO if I'm keeping this, improve it to first switch focus to a/the popup window if one isn't focused already

      "s-u" (lookup-key doom-leader-map (kbd "u"))
      "s-U" #'negative-argument         ; Trying this out.
      (:map universal-argument-map
       "s-u" #'universal-argument-more)

      (:after evil-easymotion
       "s-a" (lookup-key evilem-map (kbd "SPC")))

      "s-." #'repeat

      "s-J" #'evil-scroll-down
      "s-K" #'evil-scroll-up

      (:prefix "s-d"
       "." #'repeat-complex-command

       "h" #'git-gutter:popup-hunk
       ;; "o" #'+macos/open-in-default-program ;; TODO consider a Guix alternative? Meh.
       "r" #'projectile-replace
       "t" #'tldr
       "s" #'org-save-all-org-buffers
       "a" #'link-hint-open-multiple-links
       ;; "b" (cmd! (evil-local-mode 'toggle)
       ;;           (when evil-local-mode (evil-normal-state)))
       (:prefix "c"
        "f" #'org-gcal-fetch
        "s" #'org-gcal-sync
        "p" #'org-gcal-post-at-point)))
#+end_src
****** Modules
******* UI
******** Doom
********* doom-themes
- TODO get rid of this if I'm not going to try it out again
#+begin_src elisp
;; (after! doom-themes
;;   (doom-themes-visual-bell-config))
#+end_src
******** Modeline
********* doom-modeline
#+begin_src elisp
(after! doom-modeline
  ;; (setq doom-modeline-checker-simple-format nil)
  (setq doom-modeline-major-mode-icon t)
  (setq doom-modeline-persp-name t))
#+end_src
******** Indent Guides
********* highlight-indent-guides :prog_mode:
#+begin_src elisp
(use-package! highlight-indent-guides
  :defer t
  :init
  ;; I don't want indent guides on by default, remove all the Doom module's hooks.
  (remove-hook! '(prog-mode-hook
                  text-mode-hook
                  conf-mode-hook)
    #'highlight-indent-guides-mode))
#+end_src
******** Ligatures
********* ligature
#+begin_src elisp :tangle (meta-in-dir "init.el")
;; (use-package-hook! ligature
;;   :pre-config
;;   (setq +ligatures-all-modes-list
;;         '("www")
;;         +ligatures-prog-mode-list
;;         '(;; Fira Code (from https://github.com/tonsky/FiraCode/wiki/Emacs-instructions#using-ligatureel)
;;           "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\" "{-" "::"
;;           ":::" ":=" "!!" "!=" "!==" "-}" "----" "-->" "->" "->>"
;;           "-<" "-<<" "-~" "#{" "#[" "##" "###" "####" "#(" "#?" "#_"
;;           "#_(" ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*" "/**"
;;           "/=" "/==" "/>" "//" "///" "&&" "||" "||=" "|=" "|>" "^=" "$>"
;;           "++" "+++" "+>" "=:=" "==" "===" "==>" "=>" "=>>" "<="
;;           "=<<" "=/=" ">-" ">=" ">=>" ">>" ">>-" ">>=" ">>>" "<*"
;;           "<*>" "<|" "<|>" "<$" "<$>" "<!--" "<-" "<--" "<->" "<+"
;;           "<+>" "<=" "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<"
;;           "<~" "<~~" "</" "</>" "~@" "~-" "~>" "~~" "~~>" "%%"
;;           ;; Doom defaults (just the ones not already present in Fira Code)
;;           "|||>" "<|||" "<==>" "||>" "::=" "=!=" "!!." ">->" "---" "<~>"
;;           "<||" "<-<" "_|_" "~=" "|}" "|]" "|-" "{|" "[|" "]#" ":>" ":<"
;;           ">:" "-|" "--" "<:" "#:" "#=" "#!" ".?" "?:" "?." "__" "(*"
;;           "*)" "://"))
;;   t)
#+end_src
******* Editor
******** Evil
********* evil :bindings:theming:
#+begin_src elisp
(after! evil
  (map! :m [C-i] nil) ; Remove Doom's binding for `evil-jump-forward'.

  (when param-console?
    (defun biome--set-theme-cursor-color-symbols ()
      (put 'cursor 'evil-normal-color (biome--color :gold))
      (put 'cursor 'evil-emacs-color  (biome--color :pink)))

    (defadvice! biome-update-cursor-color-a (&rest _)
      :after #'+evil-update-cursor-color-h
      (when (memq biome--nuclear-theme custom-enabled-themes)
        (biome--set-theme-cursor-color-symbols)))))
#+end_src
******** Multiple Cursors
********* evil-multiedit :evil:
#+begin_src elisp
(after! evil-multiedit
  (setq evil-multiedit-follow-matches t))
#+end_src
******** Lisp
********* lispy
#+begin_src elisp
(use-package! lispy
  :defer t
  :init
  ;; Not using lispy, remove all the Doom module's hooks.
  (remove-hook! '(lisp-mode-hook
                  emacs-lisp-mode-hook
                  ielm-mode-hook
                  scheme-mode-hook
                  racket-mode-hook
                  hy-mode-hook
                  lfe-mode-hook
                  dune-mode-hook
                  clojure-mode-hook
                  fennel-mode-hook)
    #'lispy-mode)
  (remove-hook! 'eval-expression-minibuffer-setup-hook #'doom-init-lispy-in-eval-expression-h))
#+end_src
********* lispyville :prog_mode:bindings:
#+begin_src elisp
(use-package! lispyville
  :hook (prog-mode . lispyville-mode)
  :init
  (setq lispyville-key-theme nil) ; Prevent Doom module's invocation of `lispyville-set-key-theme' from doing anything.
  :config
  (lispyville-set-key-theme
   '(operators
     c-w
     c-u
     commentary))
  (map! :map lispyville-mode-map
        "C-s-j" #'lispyville-beginning-of-next-defun
        "C-s-k" #'lispyville-beginning-of-defun
        "C-s-," #'lispyville-end-of-defun
        "C-s-a" #'lispyville-drag-backward
        "C-s-g" #'lispyville-drag-forward
        "C-s-p" #'lispyville-prettify
        (:prefix "C-s-;"
         "R" #'lispyville-raise-list)))
#+end_src
******* Emacs
******** Dired
********* dired-x :UI:hidden:
Don't hide files in dired, remove the Doom module's hook. However, via the Doom config dired-x is only loaded when ~dired-omit-mode~ is triggered so add another hook that mimics this (loads dired-x after the first use of dired). A simple =:after= would probably be fine too (and less odd) but this is lazier.
- TODO dired buffers always marked modified
  *wait to do this until I do my dired project*
  Removing the ~dired-omit-mode~ hook causes dired buffers to start off marked as modified. I don't think this was happening until I upgraded to Emacs 29 so maybe this will resolve itself on a later Emacs upgrade.
  - although even before this started happenning I recall dired buffers being marked modified and annoying to close irritating me. I don't know why I'd want that behavior to begin with but I suspect there are good reasons.
    Some remarks on modified dired buffers: [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Reverting-Dired.html]]
#+begin_src elisp
(use-package! dired-x
  :defer t
  :init
  (remove-hook! 'dired-mode-hook #'dired-omit-mode)
  (add-hook! 'dired-mode-hook
    (defun require-dired-x-h ()
      (require 'dired-x))))
#+end_src
******* Term
******** eshell :persistence:
#+begin_src elisp
(after! eshell
  (setq eshell-history-size biome--very-big)) ; Setting this to `nil' to inherit envvar HISTSIZE is another option.
#+end_src
******* Tools
******** Magit
********* magit :UI:
#+begin_src elisp
(after! magit
  (setq git-commit-style-convention-checks '(non-empty-second-line))
  (setq magit-revision-show-gravatars '("^Author:     " . "^Commit:     ")))
#+end_src
******* Lang
******** Clojure
********* clojure :bindings:theming:
#+begin_src elisp
(use-package! clojure-mode
  :defer t
  :init
  (setq clojure-refactor-map-prefix (kbd "s-M r")) ; Has to be set before clojure-mode loads. ; REVIEW temporary binding
  :config
  (set-ligatures! 'clojure-mode :lambda "fn")
  (when param-console?
    (custom-theme-set-faces! biome--nuclear-theme
      `(clojure-character-face :foreground ,(doom-color 'violet) :weight bold))))
#+end_src
********* cider :persistence:
#+begin_src elisp
(after! cider
  (setq cider-repl-history-size biome--very-big
        cider-print-options '(("length" 100))))

;; REVIEW make sure this is still working after nesting in `after!'
(after! cider-repl
  (add-hook! 'cider-repl-mode-hook
             #'goto-address-prog-mode
             #'highlight-numbers-mode
             #'rainbow-delimiters-mode
             #'yas-minor-mode-on
             #'biome-sp-strict-h))
#+end_src
********* clj-refactor :bindings:
#+begin_src elisp
(after! clj-refactor
  (cljr-add-keybindings-with-prefix "s-M R")) ; REVIEW temporary binding
#+end_src
******** Emacs Lisp
********* emacs-lisp
#+begin_src elisp
(after! elisp-mode
  (setq-hook! 'emacs-lisp-mode-hook indent-tabs-mode nil))
#+end_src
******** Org
********* org :UI:path:theming:
#+begin_src elisp
(after! org
  (setq org-agenda-files `(,biome--org-dir
                           ,biome--org-gcal-dir
                           ,(concat biome--org-dir "/work"))
        org-log-done 'time
        org-priority-lowest ?E
        org-priority-default ?C)

  (when param-console?
    (setq org-priority-faces `((?A . ,(doom-color 'red))
                               (?B . ,(doom-color 'orange))
                               (?C . ,(doom-color 'blue))
                               (?D . ,(doom-color 'yellow))
                               (?E . ,(doom-color 'green))))))
#+end_src
********* ob
#+begin_src elisp
(after! ob
  (setq org-babel-noweb-error-all-langs t))
#+end_src
********* evil-org :evil:bindings:
#+begin_src elisp
(after! evil-org
  (map! :map evil-org-mode-map
        :nv "C-j" #'outline-forward-same-level
        :nv "C-k" #'outline-backward-same-level))
#+end_src
******** Scheme
********* scheme
#+begin_src elisp
(after! scheme
  (setq-hook! 'scheme-mode-hook indent-tabs-mode nil))
#+end_src
********* geiser :persistence:path:guix:
Use ~:init~ to configure variables (as opposed to ~:config~, which seems like it'd be fine) because hlissner does it this way for the Geiser package so I will too.
#+begin_src elisp
(use-package! geiser
  :defer t
  :init
  (setq geiser-repl-current-project-function #'ignore)) ; Reset this back to its default (don't have separate REPLs for projects) because it doesn't play nice with the Guix store.
#+end_src
******* App
******** Calendar
********* org-gcal :org:user:secret:persistence:path:
#+begin_src elisp
(after! org-gcal
  (setq org-gcal-client-id "446729771716-pp79934q99aro2h8v3iki1fejcodbdoo.apps.googleusercontent.com"
        org-gcal-client-secret (-> (auth-source-search :host org-gcal-client-id) car (plist-get :secret) funcall)
        org-gcal-fetch-file-alist `((user-mail-address . ,(concat biome--org-gcal-dir "/" user-mail-address ".org"))
                                    ("addressbook%23contacts@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/contacts.org"))
                                    ("en.usa%23holiday@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/holidays.org")))
        org-gcal-recurring-events-mode 'nested))
#+end_src
******* Config
******** expand-region :bindings:
#+begin_src elisp
(use-package! expand-region
  :defer t
  :init
  (map! :nv "s-e" #'er/expand-region
        :nv "s-E" #'er/contract-region)
  :config
  (setq expand-region-fast-keys-enabled nil) ; My mapping is conventient enough and I don't want the repeat key to conflict with anything.
  ;; Copied from Doom config: ~/.config/emacs/modules/config/default/+emacs.el:12
  (defadvice! biome--quit-expand-region-a (&rest _)
    "Properly abort an expand-region region."
    :before '(evil-escape doom/escape)
    (when (memq last-command '(er/expand-region er/contract-region))
      (er/contract-region 0))))
#+end_src
******* Guix
******** guix.el
********* guix :UI:
#+begin_src elisp
(after! guix
  (set-popup-rules!
    '(("^\\*Guix" :height 0.5))))
#+end_src
********* guix-devel :scheme:
#+begin_src elisp
(use-package! guix-devel
  :hook (scheme-mode . guix-devel-mode))
#+end_src
********* guix-popup :bindings:
#+begin_src elisp
(use-package! guix-popup
  :defer t
  :init
  (map! :leader
        "l" #'guix))  ; REVIEW temporary binding?
#+end_src
********* guix-prettify :UI:
#+begin_src elisp
(use-package! guix-prettify
  :hook (doom-first-buffer . global-guix-prettify-mode))
#+end_src
******** guix-contributing
#+begin_src elisp
;; TODO once I'm done packaging Doom figure out how to enable this
;; (use-package! guix-contributing)
#+end_src
******** guix-packaging :persistence:path:
#+begin_src elisp
(use-package! guix-packaging
  :defer t
  :init
  (setq guix-packaging--data-dir (concat doom-cache-dir "guix-packaging")))
#+end_src
******* ?
******** avy
#+begin_src elisp
;; REVIEW Trying out not having this so I can use avy dispatch commands.
;; (after! avy
;;   (setq avy-single-candidate-jump t))
#+end_src
******** paren :UI:
#+begin_src elisp
(after! paren
  (setq! show-paren-delay 0))
#+end_src
******** prog-mode :prog_mode:
#+begin_src elisp
(add-hook! 'prog-mode-hook #'biome-sp-strict-h)
#+end_src
******** rainbow-delimiters :theming:
#+begin_src elisp
(when param-console?
  (after! rainbow-delimiters
    (let ((default-max rainbow-delimiters-max-face-count))
      (defun biome-set-rainbow-delimiters-max-face-count ()
        (setq rainbow-delimiters-max-face-count
              (if (memq biome--nuclear-theme custom-enabled-themes)
                  8 default-max))))

    (biome-set-rainbow-delimiters-max-face-count)
    (add-hook! 'doom-load-theme-hook #'biome-set-rainbow-delimiters-max-face-count)

    (custom-theme-set-faces! biome--nuclear-theme
      `(rainbow-delimiters-depth-1-face :foreground ,(doom-color 'fg))
      `(rainbow-delimiters-depth-2-face :foreground ,(doom-color 'magenta))
      `(rainbow-delimiters-depth-3-face :foreground ,(doom-color 'blue))
      `(rainbow-delimiters-depth-4-face :foreground ,(doom-color 'cyan))
      `(rainbow-delimiters-depth-5-face :foreground ,(doom-color 'green))
      `(rainbow-delimiters-depth-6-face :foreground ,(doom-color 'yellow))
      `(rainbow-delimiters-depth-7-face :foreground ,(doom-color 'orange))
      `(rainbow-delimiters-depth-8-face :foreground ,(doom-color 'red)))))
#+end_src
******** recentf :persistence:
#+begin_src elisp
(after! recentf
  (setq recentf-max-saved-items 500))
#+end_src
******** smartparens :bindings:
#+begin_src elisp
(after! smartparens
  (map! :map smartparens-mode-map
        "C-s-h" #'sp-backward-sexp
        "C-s-l" #'sp-forward-sexp
        "C-s-u" #'sp-backward-up-sexp
        "C-s-o" #'sp-up-sexp
        :gn "C-s-m" #'sp-backward-down-sexp ; Bind in normal mode explicitly to override the Doom mapping in ~/.config/emacs/modules/config/default/config.el:447
        "C-s-." #'sp-down-sexp
        "C-s-c" #'sp-splice-sexp
        "C-s-s" #'sp-splice-sexp-killing-backward
        "C-s-f" #'sp-splice-sexp-killing-forward
        "C-s-x" #'sp-backward-slurp-sexp
        "C-s-v" #'sp-forward-slurp-sexp
        "C-s-w" #'sp-backward-barf-sexp
        "C-s-r" #'sp-forward-barf-sexp
        (:prefix "C-s-;"
         "(" #'sp-wrap-round
         "[" #'sp-wrap-square
         "{" #'sp-wrap-curly
         "s" #'sp-split-sexp
         "j" #'sp-join-sexp
         "r" #'sp-raise-sexp
         "c" #'sp-convolute-sexp
         "w" #'sp-rewrap-sexp)))
#+end_src
********* Hook :bindings:
#+begin_src elisp
(defun biome-sp-strict-h ()
  (add-hook! 'smartparens-enabled-hook :local
             #'turn-on-smartparens-strict-mode
             (defun biome-modify-sp-strict-mode-map-h ()
               (map! :map smartparens-strict-mode-map
                     :i "DEL" #'sp-backward-delete-char))))
#+end_src
******** transient :persistence:
- TODO Not sure where this should be categorized, it's a helper package required by at least magit, forge, git-timemachine
#+begin_src elisp
(after! transient
  (setq transient-history-limit biome--very-big))
#+end_src
******** undo-fu
#+begin_src elisp
(after! undo-fu
  (setq undo-fu-ignore-keyboard-quit t))
#+end_src
******** undo-tree :UI:
#+begin_src elisp
;; (after! undo-tree
;;   (setq undo-tree-visualizer-timestamps t))
#+end_src
******** emojify :UI:
#+begin_src elisp
(after! emojify
  (setq emojify-display-style 'unicode))
#+end_src
******** asdf :bindings:
- TODO donno where this should go, ~+default-minibuffer-maps~ is a doom thing I guess
#+begin_src elisp
(define-key! :keymaps +default-minibuffer-maps
  "s-J" #'scroll-up-command
  "s-K" #'scroll-down-command)
#+end_src
****** Theming :theming:
#+begin_src elisp
(when param-console?
  (setq doom-theme
        (pcase param-theme
          (:theme/light 'doom-one-light)
          (:theme/dark biome--nuclear-theme)))

  (custom-theme-set-faces! biome--nuclear-theme
    `(font-lock-comment-delimiter-face :foreground ,(biome--color :comment-delimiter))
    `(font-lock-doc-face :foreground ,(doom-color 'cyan))))
#+end_src
******* Font
#+begin_src elisp
(when param-console?
  (defun biome--set-font-safe (sym font)
    (when (find-font font)
      (set sym font)))

  (biome--set-font-safe
   'doom-font
   (font-spec :family param-font-name
              :size param-font-size
              :weight (or param-font-weight 'normal)))

  (biome--set-font-safe
   'doom-variable-pitch-font
   (font-spec :family param-font-variable-pitch-name))

  (biome--set-font-safe
   'doom-unicode-font
   (font-spec :family param-font-unicode-name))

  (biome--set-font-safe
   'doom-serif-font
   (font-spec :family param-font-serif-name)))
#+end_src
******* Nuclear Theme

#+call: gen-doom-theme() :results code :post unescape(*this*) :results_switches ":tangle (meta-in-dir \"themes/doom-nuclear-theme.el\")"

#+RESULTS:
#+begin_src elisp :tangle (meta-in-dir "themes/doom-nuclear-theme.el")
;;; nuclear-theme.el --- inspired by Atom One Dark -*- lexical-binding: t; no-byte-compile: t; -*-
;;
;;
;;
;;; Commentary:
;;
;; This themepack's flagship theme.
;;
;;; Code:

(require 'doom-themes)


;;
;;; Variables

(defgroup nuclear-theme nil
  "Options for the `nuclear' theme."
  :group 'doom-themes)

(defcustom nuclear-brighter-modeline nil
  "If non-nil, more vivid colors will be used to style the mode-line."
  :group 'nuclear-theme
  :type 'boolean)

(defcustom nuclear-brighter-comments nil
  "If non-nil, comments will be highlighted in more vivid colors."
  :group 'nuclear-theme
  :type 'boolean)

(defcustom nuclear-padded-modeline doom-themes-padded-modeline
  "If non-nil, adds a 4px padding to the mode-line.
Can be an integer to determine the exact padding."
  :group 'nuclear-theme
  :type '(choice integer boolean))


;;
;;; Theme definition

(def-doom-theme doom-nuclear
  "A dark theme inspired by Atom One Dark."

  ;; name        default   256           16
  ((bg         '("#282c34" "black"       "black"  ))
   (fg         '("#dee2f8" "#bfbfbf"     "brightwhite"  ))

   ;; These are off-color variants of bg/fg, used primarily for `solaire-mode',
   ;; but can also be useful as a basis for subtle highlights (e.g. for hl-line
   ;; or region), especially when paired with the `doom-darken', `doom-lighten',
   ;; and `doom-blend' helper functions.
   (bg-alt     '("#21242b" "black"       "black"        ))
   (fg-alt     '("#5B6268" "#2d2d2d"     "white"        ))

   ;; These should represent a spectrum from bg to fg, where base0 is a starker
   ;; bg and base8 is a starker fg. For example, if bg is light grey and fg is
   ;; dark grey, base0 should be white and base8 should be black.
   (base0      '("#1B2229" "black"       "black"        ))
   (base1      '("#1c1f24" "#1e1e1e"     "brightblack"  ))
   (base2      '("#202328" "#2e2e2e"     "brightblack"  ))
   (base3      '("#23272e" "#262626"     "brightblack"  ))
   (base4      '("#3f444a" "#3f3f3f"     "brightblack"  ))
   (base5      '("#5B6268" "#525252"     "brightblack"  ))
   (base6      '("#73797e" "#6b6b6b"     "brightblack"  ))
   (base7      '("#9ca0a4" "#979797"     "brightblack"  ))
   (base8      '("#DFDFDF" "#dfdfdf"     "white"        ))

   (grey       base4)
   (red        '("#fb8578" "#ff6655" "red"          ))
   (orange     '("#fdce5f" "#dd8844" "brightred"    ))
   (green      '("#9fed9c" "#99bb66" "green"        ))
   (teal       '("#4db5bd" "#44b9b1" "brightgreen"  ))
   (yellow     '("#eddc91" "#ECBE7B" "yellow"       ))
   (blue       '("#7db9fe" "#51afef" "brightblue"   ))
   (dark-blue  '("#5f68de" "#2257A0" "blue"         ))
   (magenta    '("#e29bf7" "#c678dd" "brightmagenta"))
   (violet     '("#aeb9f3" "#a9a1e1" "magenta"      ))
   (cyan       '("#75e0f9" "#46D9FF" "brightcyan"   ))
   (dark-cyan  '("#5699AF" "#5699AF" "cyan"         ))

   ;; These are the "universal syntax classes" that doom-themes establishes.
   ;; These *must* be included in every doom themes, or your theme will throw an
   ;; error, as they are used in the base theme defined in doom-themes-base.
   (highlight      "#8496ff")
   (vertical-bar   (doom-darken base1 0.1))
   (selection      dark-blue)
   (builtin        blue)
   (comments       "#63677f")
   (doc-comments   (doom-lighten (if nuclear-brighter-comments dark-cyan base5) 0.25))
   (constants      yellow)
   (functions      blue)
   (keywords       magenta)
   (methods        violet)
   (operators      cyan)
   (type           orange)
   (strings        green)
   (variables      red)
   (numbers        violet)
   (region         `(,(doom-lighten (car bg-alt) 0.15) ,@(doom-lighten (cdr base1) 0.35)))
   (error          red)
   (warning        yellow)
   (success        green)
   (vc-modified    orange)
   (vc-added       green)
   (vc-deleted     red)

   ;; These are extra color variables used only in this theme; i.e. they aren't
   ;; mandatory for derived themes.
   (modeline-fg              fg)
   (modeline-fg-alt          base5)
   (modeline-bg              (if nuclear-brighter-modeline
                                 (doom-darken blue 0.45)
                               (doom-darken bg-alt 0.1)))
   (modeline-bg-alt          (if nuclear-brighter-modeline
                                 (doom-darken blue 0.475)
                               `(,(doom-darken (car bg-alt) 0.15) ,@(cdr bg))))
   (modeline-bg-inactive     `(,(car bg-alt) ,@(cdr base1)))
   (modeline-bg-inactive-alt `(,(doom-darken (car bg-alt) 0.1) ,@(cdr bg)))

   (-modeline-pad
    (when nuclear-padded-modeline
      (if (integerp nuclear-padded-modeline) nuclear-padded-modeline 4))))


  ;;;; Base theme face overrides
  (((line-number &override) :foreground base4)
   ((line-number-current-line &override) :foreground violet)
   ((font-lock-comment-face &override)
    :background (if nuclear-brighter-comments (doom-lighten bg 0.05)))
   (mode-line
    :background modeline-bg :foreground modeline-fg
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg)))
   (mode-line-inactive
    :background modeline-bg-inactive :foreground modeline-fg-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-inactive)))
   (mode-line-emphasis :foreground (if nuclear-brighter-modeline base8 highlight))

   ;;;; css-mode <built-in> / scss-mode
   (css-proprietary-property :foreground orange)
   (css-property             :foreground green)
   (css-selector             :foreground blue)
   ;;;; doom-modeline
   (doom-modeline-bar :background (if nuclear-brighter-modeline modeline-bg highlight))
   (doom-modeline-buffer-file :inherit 'mode-line-buffer-id :weight 'bold)
   (doom-modeline-buffer-path :inherit 'mode-line-emphasis :weight 'bold)
   (doom-modeline-buffer-project-root :foreground green :weight 'bold)
   ;;;; elscreen
   (elscreen-tab-other-screen-face :background "#353a42" :foreground "#1e2022")
   ;;;; ivy
   (ivy-current-match :background dark-blue :distant-foreground base0 :weight 'normal)
   ;;;; LaTeX-mode
   (font-latex-math-face :foreground green)
   ;;;; markdown-mode
   (markdown-markup-face :foreground base5)
   (markdown-header-face :inherit 'bold :foreground red)
   ((markdown-code-face &override) :background (doom-lighten base3 0.05))
   ;;;; rjsx-mode
   (rjsx-tag :foreground red)
   (rjsx-attr :foreground orange)
   ;;;; solaire-mode
   (solaire-mode-line-face
    :inherit 'mode-line
    :background modeline-bg-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-alt)))
   (solaire-mode-line-inactive-face
    :inherit 'mode-line-inactive
    :background modeline-bg-inactive-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-inactive-alt))))

  ;;;; Base theme variable overrides-
  ())

;;; nuclear-theme.el ends here
#+end_src
******** Generator
:PROPERTIES:
:header-args+: :tangle no
:END:
#+name: gen-doom-theme
#+begin_src elisp :var palette=palette
(require 'dash)

(defun dt--color (color)
  (let ((k (-> color symbol-name (substring 1))))
    (cadr (assoc k palette))))

(defmacro dt--buffer->string (&rest body)
  `(with-temp-buffer
     ,@body
     (buffer-string)))

(defun dt--slurp (f)
  (dt--buffer->string
   (insert-file-contents f)))

(defun dt--replace (s match replacement)
  (replace-regexp-in-string match replacement s 'fixedcase 'literal))

(defun dt--replace-sexp (s match replacement)
  (dt--buffer->string
   (insert s)
   (goto-char (point-min))
   (re-search-forward match)
   ;; Calling `forward-sexp' and `backward-sexp' here to preserve whitespace.
   (forward-sexp)
   (backward-sexp)
   (kill-sexp)
   (insert (format "%S" replacement))))

(defun dt--gen-doom-theme (f)
  (-as->
   (dt--slurp f) $
   (dt--replace-sexp $ "def-doom-theme" 'doom-nuclear)
   (dt--replace $ "doom-one" "nuclear")
   (-reduce-from
    (-lambda (s (match replacement))
      (dt--replace-sexp s match replacement))
    $
    (-partition
     2
     (let ((match-base-color (lambda (form)
                               (rx-to-string `(seq "(" ,form (+ whitespace) "'("))))
           (match-face (lambda (&rest forms)
                         (rx-to-string `(seq "(" ,@forms)))))
       (list
        (funcall match-base-color "fg") (dt--color :fg)
        (funcall match-base-color "red") (dt--color :red)
        (funcall match-base-color "orange") (dt--color :orange)
        (funcall match-base-color "green") (dt--color :green)
        (funcall match-base-color "yellow") (dt--color :yellow)
        (funcall match-base-color "blue") (dt--color :blue)
        (funcall match-base-color "dark-blue") (dt--color :dark-blue)
        (funcall match-base-color "magenta") (dt--color :magenta)
        (funcall match-base-color "violet") (dt--color :violet)
        (funcall match-base-color "cyan") (dt--color :cyan)
        (funcall match-face "highlight") (dt--color :highlight)
        (funcall match-face "builtin") 'blue
        (funcall match-face "comments") (dt--color :comments)
        (funcall match-face "constants") 'yellow
        (funcall match-face "functions") 'blue
        (funcall match-face "keywords") 'magenta
        (funcall match-face "methods") 'violet
        (funcall match-face "operators") 'cyan
        (funcall match-face "type") 'orange
        (funcall match-face "variables") 'red
        (funcall match-face "numbers") 'violet
        (funcall match-face "line-number-current-line" '(+? anything) ":foreground") 'violet))))
   (dt--replace $ (rx ";; Added" (*? anything) "\n") "")
   (dt--replace $ (rx ";; Author" (*? anything) "\n") "")
   (dt--replace $ (rx ";; Maintainer" (*? anything) "\n") "")
   (dt--replace $ (rx ";; Source" (*? anything) "\n") "")))

;; REVIEW do this better (don't hardcode it?). Add a :path: tag to this org header if necessary. Perhaps it would be best to have the doom-themes repo be an explicit dependency in some way and manage like I do other Guix or Doom/straight dependencies.
(dt--gen-doom-theme "~/.config/emacs/.local/straight/repos/themes/themes/doom-one-theme.el")
#+end_src

#+name: unescape
#+begin_src elisp :var s=""
(-as-> s $
       (substring s 1 -1) ; Remove outer quotes.
       (replace-regexp-in-string (rx "\\n" ) "\n" $) ; Unescape newlines specifically before unescaping everything else (not how this works / why it's necessary).
       (replace-regexp-in-string (rx "\\" (group anything)) "\\1" $))
#+end_src
****** Projects
******* Phrenetic :path:
#+begin_src elisp
(load "~/work/phrenetic/meta" 'noerror 'nomessage)

(pushnew! safe-local-variable-values
          '(eval . (with-eval-after-load 'geiser-guile
                     (let ((root-dir
                            (file-name-directory
                             (locate-dominating-file default-directory ".dir-locals.el"))))
                       (make-local-variable 'geiser-guile-load-path)
                       (add-to-list 'geiser-guile-load-path root-dir)))))
#+end_src
******* Nyxt
- TODO donno if I should keep this section in particular (it's not really impoportant), I'm just thinking I want to start trying out adding safe local variables for other codebases so I can get their advantages. Also the changes it makes persist (modify ~lisp-imenu-generic-expression~), I don't know if that's a good idae.
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(eval . (cl-flet ((enhance-imenu-lisp
                              (&rest keywords)
                              (dolist (keyword keywords)
                                (add-to-list
                                 'lisp-imenu-generic-expression
                                 (list (purecopy (concat (capitalize keyword)
                                                         (if (string= (substring-no-properties keyword -1) "s")
                                                             "es"
                                                           "s")))
                                       (purecopy (concat "^\\s-*("
                                                         (regexp-opt
                                                          (list (concat "define-" keyword))
                                                          t)
                                                         "\\s-+\\(" lisp-mode-symbol-regexp "\\)"))
                                       2)))))
                     ;; This adds the argument to the list of imenu known keywords.
                     (enhance-imenu-lisp
                      "bookmarklet-command"
                      "class"
                      "command"
                      "ffi-method"
                      "function"
                      "mode"
                      "parenscript"
                      "user-class"))))
#+end_src
******* Hyperdrive :path:
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(cider-preferred-build-tool . shadow-cljs)
          '(cider-default-cljs-repl . shadow)
          '(cider-shadow-default-options . ":app")
          '(cider-offer-to-open-cljs-app-in-browser . nil)
          '(cider-clojure-cli-global-options . "-A:dev")
          '(eval . (setenv "DATOMIC_APP_INFO_MAP" "{:app-name \"neutrino\"}"))
          '(eval . (setenv "DATOMIC_ENV_MAP" "{:env :dev}"))
          '(cider-clojure-cli-global-options . nil))

(prodigy-define-service
  :name "Amplify Mock"
  :command "amplify"
  :args '("mock")
  :cwd "~/work/Krush/hyperdrive/apps/singularity"
  :kill-process-buffer-on-stop t)

(prodigy-define-service
  :name "Datomic Access (exogenesis)"
  :command "bash"
  :args '("datomic" "client" "access" "exogenesis")
  :cwd "~/work/Krush/hyperdrive/ion/team"
  :kill-process-buffer-on-stop t)
#+end_src
******* Massrealty :path:
#+begin_src elisp
;; (pushnew! safe-local-variable-values
;;           '(ssh-deploy-root-remote . "/ssh:massrealty@35.196.144.73:/home/massrealty/deploy/homes/public_html/")
;;           '(ssh-deploy-automatically-detect-remote-changes . t))

;; (after! org-gcal
;;   (add-to-list 'org-gcal-fetch-file-alist `("krzysztof@massrealty.com" . ,(concat biome--org-gcal-dir "/krzysztof@massrealty.com.org")) 'append))
#+end_src
****** WIP
#+begin_src elisp
(after! org
  (add-to-list 'org-agenda-files (concat biome--org-dir "/spring_cleaning") 'append))

;; I don't think I'll ever need this with Sway. Is it worth keeping this and having an "I'm not on Sway / some WM" conditional around it?
;; (add-to-list 'initial-frame-alist '(fullscreen . fullboth))

(map! "s-A" #'app-launcher-run-app)

(map! "s-&" (lambda (command)
              (interactive (list (read-shell-command "$ ")))
              (call-process-shell-command command nil 0 nil)))

(map! :leader
      "s-," (lookup-key doom-leader-map (kbd "<")))

(after! company
  (map! :map company-active-map
        "s-[" #'company-show-doc-buffer ; Currently opens Help, it would be better if I made it use Helpful.
        "s-]" #'company-show-location))

(after! evil-org
  (map! :map evil-org-mode-map
        (:prefix "g"
         :nv "{" #'evil-backward-paragraph
         :nv "}" #'evil-forward-paragraph)))

;; TODO Maybe do this if popping to the side is too annoying
;; (after! geiser-repl
;;   (setq geiser-repl-use-other-window nil))

;; Doesn't work yet: you have to switch to the buffer "manually" once before it starts being treated as real
(map! "s-d m" (cmd! (doom-set-buffer-real (current-buffer) t)))

;; `forward-char' in original definition is messing things up, do this for now
;; (defun +eshell/search-history ()
;;   (interactive)
;;   (consult-history))
(after! esh-mode
  (map! :map eshell-mode-map
        "C-s" #'consult-history))

;; Remove the :mode set by the Doom module. It's unnecessary (`guix-drv-mode.el' already does this, and for /nix/store drvs specifically) and it shadows `guix-derivation-mode'.
;; TODO should this go in the Guix or Nix config section?
(use-package! nix-drv-mode
  :defer t
  :init
  (setq auto-mode-alist (delete '("\\.drv\\'" . nix-drv-mode) auto-mode-alist)))

(after! vertico
  (setq vertico-count 20  ; Trying out, maybe too big.
        vertico-scroll-margin 7))
#+end_src
******* keybinding ideas
#+begin_src elisp
;; If I keep this I can get rid of the "C-_" binding I have too. Update: maybe? Some places C-_ works and some s-h does (in vertico)? What about my key translation for C-? ? Straighten all this shit out.
(biome--trans "s-h" "C-h")

(map! "s-o" (lookup-key doom-leader-map (kbd "<")))
;; Get rid of binding for =s-r=?
(map! "s-r" nil)

;; Maybe "C-s-i" but then I'll have to change my sexp-movement command(s). Maybe keep this even if I do that, for consistency.
(biome--trans "C-S-i" "<backtab>")
;; Also messes with my sexp-movement bindings
;; (map! "C-s-j" #'evil-scroll-down
;;       "C-s-k" #'evil-scroll-up)

(after! evil
  (map! :map evil-motion-state-map
        ;; Maybe "C-s-o" but then I'll have to change my sexp-movement command(s). There are other bindings for jump-forward though, maybe I'll just use those.
        "C-S-o" #'evil-jump-forward))

;; Maybe `s-S' to save-and-tangle? If I don't get some sort of auto-tangling thing going
;; - maybe it could be "save and eval defun (C-M-x)" in lisp/programming modes?'
;; Maybe a hotkey that just jumps back and forth between my most recently focused browser window and eemacs?
;; Maybe bind `s-o' in `consult-buffer' to "close consult-buffer and open +vertico/switch-workspace-buffer"
#+end_src
******* phrenetic auto-tangle :path:
- TODO Might be easier to do this with file-local variables.
#+begin_src elisp
;; (setq biome--phrenetic-dir "~/work/phrenetic")

;; (add-hook! 'org-mode-hook
;;   (defun biome-add-org-autotangle-after-save-hook-h ()
;;     (add-hook! 'after-save-hook :local
;;       (defun biome-autotangle-h ()
;;         (when (file-in-directory-p buffer-file-name biome--phrenetic-dir)
;;           ;; TODO ensure there aren't files in the output directory that no longer correspond to the org file. Just wipe it?
;;           (let ((org-confirm-babel-evaluate nil))
;;             (org-babel-tangle)))))))
#+end_src
******* org-tanglesync
#+begin_src elisp
;; (use-package! org-tanglesync
;;   :hook ((org-mode . org-tanglesync-mode)
;;          ((prog-mode text-mode) . org-tanglesync-watch-mode))
;;   :config
;;   (setq org-tanglesync-watch-files '("/home/pharcosyle/work/phrenetic/phrenetic.org")))
#+end_src
******* Temporary copypasta from bloodhound
Copying this here for now, for convenience.
#+begin_src elisp
(setq my-dotfiles-git-dir (concat "--git-dir=" (expand-file-name "~/home-state.git")))
;; (setq my-dotfiles-work-tree (concat "--work-tree=" (expand-file-name "~")))
(map! "s-b" (cmd!
             (pushnew! magit-git-global-arguments my-dotfiles-git-dir)
             (magit-status "~")))
(map! "s-B" (cmd!
             ;; (delq! my-dotfiles-git-dir magit-git-global-arguments)
             ;; Why is the above not working? Doing this for now:
             ;; - Update: because `delq!' tests for equality with `eq'
             (setq magit-git-global-arguments (remove my-dotfiles-git-dir magit-git-global-arguments))))
#+end_src
******* until I get semicolon working
#+begin_src elisp
(map! (:map minibuffer-local-map
       "C-:" #'embark-act
       "C-c C-:" #'embark-export)
      (:leader
       "A" #'embark-dwim)
      ;; Trying out cycling (temp)
      "C-:" #'embark-act
      "s-q" #'embark-cycle)
#+end_src
******* ligatures
Probably move these to ~after!~ blocks
#+begin_src elisp
(set-ligatures! '(html-mode nxml-mode web-mode)
  :font-ligatures '("<!--" "-->" "</>" "</" "/>" ; Fira Code
                    "://"))
#+end_src
****** Out-of-band
Useful for making quick configuration additions if the the active Doomdir isn't writable (for example if it's symlinked to the Guix store).
#+begin_src elisp :var oob-dir=(meta-get-dir)
(let ((oob-dir (concat "~/work/phrenetic/" oob-dir))) ; TODO currently `meta-get-dir' returns a path relative to the phrenetic dir. That might change but regardless don't hardcode the path here eventually.
  (let* ((file "out-of-band"))
    (or (load (concat oob-dir "/" file) 'noerror 'nomessage)
        (load! file nil 'noerror))))
#+end_src
******* File
#+begin_src elisp :tangle (meta-in-dir "out-of-band.el")
#+end_src
***** Packages :version:
#+begin_src elisp :tangle (meta-in-dir "packages.el")
;; -*- no-byte-compile: t; -*-

(package! dash :pin "0ac1ecf6b56eb67bb81a3cf70f8d4354b5782341") ; TODO make this be introduced by my doom config (where I need it)?
(package! expand-region :pin "c5c4362741deebb0985a8a29f9b8b0e25160764a")
(package! tldr :pin "d3fd2a809a266c005915026799121c78e8b358f0")
(package! trashed :pin "ddf5830730544435a068f2dc9ac75a81ea69df1d")

(package! guix :pin "c9aef52121b458297e70bb50f49f7276b4a8d759")
(package! build-farm :pin "5c268a3c235ace0d79ef1ec82c440120317e06f5") ; REVIEW trying out
(package! guix-packaging ; REVIEW trying out
  :recipe (:host github
           :repo "ryanprior/emacs-guix-packaging"
           :files (:defaults "snippets"))
  :pin "5bbd1f1a268b3dfd813a75125ca88cbf0bef6529")

(package! bluetooth :pin "3a3c3c04437518f1ce0e940adf4a5e020b9755c3") ; TODO just maybe make this dependent on my "bluetooth feature"

(package! org-tanglesync :pin "af83a73ae542d5cb3c9d433cbf2ce1d4f4259117")

(package! i3wm-config-mode :pin "3574d88241118ed6cc5a3022b6dde58d6f5af9dd") ; TODO maybe make this part of a Sway / Window Manager feature or introduced by my Dotfiles project

(package! app-launcher
  :recipe (:host github
           :repo "SebastienWae/app-launcher")
  :pin "d5015e394b0a666a8c7c4d4bdf786266e773b145")

(package! 0x0 :pin "63cd5eccc85e527f28e1acc89502a53245000428")

(package! kbd-mode
  :recipe (:host github
           :repo "kmonad/kbd-mode"))
#+end_src
*** Git
#+begin_src scheme
(define* (he-git #:key
                 email
                 sign-commits? ; TODO make this (sign-commits? #t) once I have my gpg stuff set up and I'm passing a gpg-sign-key.
                 gpg-sign-key
                 ;; git-send-email?
                 extra-config)
  (list
   ;; (when git-send-email?
   ;;   (simple-service
   ;;    'git-send-email-package
   ;;    home-profile-service-type
   ;;    (list (list git "send-email"))))
   (service
    home-git-service-type
    (home-git-configuration
     (config
      `((user
         ((email . ,email)
          ,@(if sign-commits?
                `((signingkey . ,gpg-sign-key)) '())))
        ;; TODO stuff from feature-git, figure it out later
        ;; (merge
        ;;  ;; diff3 makes it easier to solve conflicts with smerge, zdiff3
        ;;  ;; should make a conflict scope smaller, but guile-git fails if
        ;;  ;; this option is set.
        ;;  ((conflictStyle . diff3)))
        ;; (diff
        ;;  ;; histogram should be smarter about diff generation.
        ;;  ((algorithm . histogram)))
        (commit
         (,@(if sign-commits?
                '((gpgsign . #t)) '())))
        ;; (sendemail
        ;;  ((annotate . #t)))
        ;;  TODO these two (http and gpg) sections were in the RDE example home environment (but notably not in the rde feature-git). Figure out what they're for after I do gpg.
        ;; (http "https://weak.example.com"
        ;;       ((ssl-verify . #f)))
        ;; (gpg
        ;;  ((program . ,(file-append gnupg "/bin/gpg"))))
        ,@(if extra-config
              extra-config '())))))))
#+end_src
*** SSH
#+begin_src scheme
(define (he-ssh)
  (list
   (service home-openssh-service-type)))
#+end_src
*** Direnv
#+begin_src scheme
(define* (he-direnv #:key
                    stateless?
                    shell)
  (list
   ;; REVIEW This might not be necessary once I integrate emacs-envrc during my Doom/Straight/Guix integration (clarification: the envrc emacs package needs to have direnv on the command line, the emacs-direnv Guix package bakes it in)
   (simple-service
    'direnv-add-package
    home-profile-service-type
    (list direnv))

   (let ((direnv-hook
          (lambda (shell)
            (let ((direnv-bin (file-append direnv "/bin/direnv")))
              (mixed-text-file
               "direnv-hook"
               "command -v " direnv-bin " > /dev/null && eval \"$(" direnv-bin " hook " shell ")\"")))))
     (case shell
       ;; ((#:shell/bash) (simple-service
       ;;                  'direnv-bash-hook
       ;;                  home-bash-service-type
       ;;                  (home-bash-extension
       ;;                   (bashrc
       ;;                    (list (direnv-hook "bash"))))))
       ((#:shell/zsh) (simple-service
                       'direnv-zsh-hook
                       home-zsh-service-type
                       (home-zsh-extension
                        (zshrc
                         (list (direnv-hook "zsh"))))))))

   ;; TODO In the future I may want to have 'allow' folder entries in my configuration, if that's possible.
   (when stateless?
     (simple-service
      'direnv-stateless
      home-stateless-service-type
      `((#:state . (((#:path . ("direnv/allow/" #:xdg-base "XDG_DATA_HOME"))
                     (#:store . #:persist)))))))))
#+end_src
*** Console
**** Fonts
#+begin_src scheme
(define* (he-fonts #:key
                   stateless?
                   fonts
                   (extra-font-packages (list font-noto-color-emoji
                                              font-liberation)))
  (list
   (simple-service
    'fonts-add-packages
    home-profile-service-type
    (append
     (map (lambda (font)
            (assoc-ref font #:font/package))
          fonts)
     extra-font-packages))

   (when stateless?
     (simple-service
      'fonts-stateless
      home-stateless-service-type
      '((#:state . (((#:path . ("fontconfig/" #:xdg-base "XDG_CACHE_HOME"))
                     (#:store . #:machine)))))))))

(define font-size 10)

(define font-mono
  `((#:font/name . "Source Code Pro")
    (#:font/size . ,font-size)
    (#:font/weight . ,'medium)
    (#:font/package . ,font-adobe-source-code-pro)))

(define font-sans
  `((#:font/name . "Iosevka Aile")
    (#:font/size . ,font-size)
    (#:font/package . ,font-iosevka-aile)))

(define font-serif
  `((#:font/name . "Iosevka Etoile")
    (#:font/package . ,font-iosevka-etoile)))

(define font-unicode
  `((#:font/name . "Unifont")
    (#:font/package . ,font-gnu-unifont)))
#+end_src
***** TODO [#D] Alternative fonts
- =font-unifont-gnu= sucks, find a replacement?
- Try out =font-adobe-source-sans-pro= in place of =font-iosevka-aile=?
**** KMonad
#+begin_src scheme
(define* (he-kmonad #:key
                    (device "/dev/input/by-id/usb-Apple_Inc._Apple_Internal_Keyboard___Trackpad-event-kbd")
                    ;; (kbd (local-file "config.kbd"))
                    (kbd (local-file "../../mine.kbd")))
  (list
   (service kmonad-service-type kbd)))

(define (kmonad-shepherd-service kbd)
  (list
   (shepherd-service
    (provision '(kmonad))
    (start #~(make-forkexec-constructor
              (list #$(file-append kmonad "/bin/kmonad") #$kbd)
              #:log-file (string-append
                          (or (getenv "XDG_LOG_HOME")
                              (format #f "~a/.local/var/log"
                                      (getenv "HOME")))
                          "/kmonad.log")))
    (stop #~(make-kill-destructor)))))

(define kmonad-service-type
  (service-type
   (name 'he-kmonad)
   (extensions
    (list (service-extension home-shepherd-service-type
                             kmonad-shepherd-service)))
   (description "Run KMonad.")))
#+end_src
*** Desktop
#+begin_src scheme
(define* (ini-config-file name config
                          #:key (serialize-ini-config serialize-ini-config))
  (apply mixed-text-file name (serialize-ini-config config)))

(define (font-value font)
  (string-join
   (list
    (assoc-ref font #:font/name)
    (number->string
     (assoc-ref font #:font/size)))
   " "))

(define wallpaper (local-file "alucard_bg.png"))
#+end_src
**** Desktop packages
#+begin_src scheme
(define* (he-desktop-packages
          #:key
          (packages (list ;; "protonvpn-cli" ; TODO Appears to be broken after the big Guix frozen-updates upgrade.

                          ;; nyxt
                          ;; gst-libav
                          ;; gst-plugins-bad
                          ;; gst-plugins-base
                          ;; gst-plugins-good
                          ;; gst-plugins-ugly
                          )))
  (list
   (simple-service
    'desktop-packages-add-packages
    home-profile-service-type
    packages)))
#+end_src
**** XDG
#+begin_src scheme
(define* (he-xdg
          #:key
          stateless?
          (desktop "$HOME/desktop")
          (documents "$HOME/docs")
          (download "$HOME/dl")
          (music "$HOME/music")
          (pictures "$HOME/pics")
          (publicshare "$HOME/public")
          (templates "$HOME/templates")
          (videos "$HOME/vids"))
  (list
   (simple-service
    'xdg-add-packages
    home-profile-service-type
    (list xdg-utils
          xdg-user-dirs ; I don't think I need this (the only reason would be if programs ever call the `xdg-user-dir' shell command and this package isn't an input to theirs).
          desktop-file-utils)) ; I don't think I need this at all but it adds elisp code (a mode for editing .desktop files). Andrew Tropin has it, I'll keep it just in case.

   (service
    home-xdg-user-directories-service-type
    (home-xdg-user-directories-configuration
     (desktop desktop)
     (documents documents)
     (download download)
     (music music)
     (pictures pictures)
     (publicshare publicshare)
     (templates templates)
     (videos videos)))

   (when stateless?
     (simple-service
      'xdg-stateless
      home-stateless-service-type
      `((#:state . ,(let ((normalize
                           (lambda (dir)
                             (as-> dir $
                                   (let ((home-prefix "$HOME/"))
                                     (if (string-prefix? home-prefix $)
                                         (string-drop $ (string-length home-prefix))
                                         $))
                                   (string-append $ "/")))))
                      `(,@(map (lambda (dir)
                                 `((#:path . ,(normalize dir))
                                   (#:store . #:persist)))
                               (list desktop
                                     documents
                                     music
                                     pictures
                                     publicshare
                                     templates
                                     videos))
                        ((#:path . ,(normalize download))
                         (#:store . #:machine))))))))))
#+end_src
**** Mesa
#+begin_src scheme
(define* (he-mesa #:key stateless?)
  (list
   (when stateless?
     (simple-service
      'mesa-stateless
      home-stateless-service-type
      '((#:state . (((#:path . ("mesa_shader_cache/" #:xdg-base "XDG_CACHE_HOME"))
                     (#:store . #:machine)))))))))
#+end_src
**** GTK
It's not totally clear what parts of this are Wayland-specific or if it's necessary to put e.g. ~gtk-theme-name~ in =settings.ini= for non-Wayland (see https://github.com/swaywm/sway/wiki/GTK-3-settings-on-Wayland).
#+begin_src scheme
(define* (he-gtk #:key
                 stateless?
                 theme
                 font
                 font-monospace)
  (list
   (simple-service
    'gtk-add-packages
    home-profile-service-type
    (list arc-theme))

   (simple-service
    'gtk-settings-and-dconf
    home-xdg-configuration-files-service-type
    `(("gtk-3.0/settings.ini"
       ,(ini-config-file
         "gtk-3.0-settings.ini"
         `((Settings ((gtk-application-prefer-dark-theme . ,(eq? theme #:theme/dark)))))))
      ("dconf/user"
       ,(computed-file
         "dconf-user"
         #~(system*
            #$(file-append dconf "/bin/dconf")
            "compile"
            #$output
            ;; Target of `compile` must be a directory.
            #$(file-union
               "keyfiledir"
               `(("dconf-keyfile"
                  ,(ini-config-file
                    "dconf-keyfile"
                    `((org/gnome/desktop/interface
                       ((gtk-theme . ,(quoted-symbol
                                       (case theme
                                         ((#:theme/light) "Arc")
                                         ((#:theme/dark) "Arc-Dark"))))
                        (font-name . ,(quoted-symbol
                                       (font-value font)))
                        (monospace-font-name . ,(quoted-symbol
                                                 (font-value font-monospace)))))))))))))))

   (when stateless?
     (simple-service
      'gtk-stateless
      home-stateless-service-type
      '((#:state . (((#:path . ("recently-used.xbel" #:xdg-base "XDG_DATA_HOME"))
                     (#:store . #:persist)))))))))

(define (quoted-symbol s)
  (string->symbol (string-append "'" s "'")))
#+end_src
**** Pipewire
#+begin_src scheme
(define* (he-pipewire #:key
                      stateless?
                      sway?)
  (append
   (pipewire-services #:stateless? stateless?
                      #:sway? sway?)
   (wireplumber-services #:stateless? stateless?
                         #:sway? sway?)))

(define* (pipewire-services #:key
                            stateless?
                            sway?)
  (list
   (simple-service
    'pipewire-add-package
    home-profile-service-type
    (list pipewire-0.3))

   (simple-service
    'pipewire-add-shepherd-daemons
    home-shepherd-service-type
    (list
     (shepherd-service
      (provision '(pipewire))
      (start #~(make-forkexec-constructor
                (list #$(file-append pipewire-0.3 "/bin/pipewire"))
                #:log-file (string-append
                            (or (getenv "XDG_LOG_HOME")
                                (format #f "~a/.local/var/log"
                                        (getenv "HOME")))
                            "/pipewire.log")
                #:environment-variables
                (append (list "DISABLE_RTKIT=1")
                        (default-environment-variables))))
      (stop  #~(make-kill-destructor))
      (auto-start? #f))
     (shepherd-service
      (provision '(pipewire-pulse pulseaudio))
      (requirement '(pipewire pipewire-media-session))
      (start #~(make-forkexec-constructor
                (list #$(file-append pipewire-0.3 "/bin/pipewire-pulse"))
                #:log-file (string-append
                            (or (getenv "XDG_LOG_HOME")
                                (format #f "~a/.local/var/log"
                                        (getenv "HOME")))
                            "/pipewire-pulse.log")
                #:environment-variables
                (append (list "DISABLE_RTKIT=1")
                        (default-environment-variables))))
      (stop  #~(make-kill-destructor))
      (auto-start? #f))))

   (simple-service
    'pipewire-add-alsa-config
    home-xdg-configuration-files-service-type
    `(("alsa/asoundrc"
       ,(mixed-text-file
         "asoundrc"
         "<" (file-append pipewire-0.3 "/share/alsa/alsa.conf.d/50-pipewire.conf") ">" "\n"
         "<" (file-append pipewire-0.3 "/share/alsa/alsa.conf.d/99-pipewire-default.conf") ">" "\n"
         "\n"
         "pcm_type.pipewire {" "\n"
         "  lib " (file-append pipewire-0.3 "/lib/alsa-lib/libasound_module_pcm_pipewire.so") "\n"
         "}" "\n"
         "\n"
         "ctl_type.pipewire {" "\n"
         "  lib " (file-append pipewire-0.3 "/lib/alsa-lib/libasound_module_ctl_pipewire.so") "\n"
         "}" "\n"))))

   (when sway?
     (simple-service
      'pipewire-sway-start
      home-sway-service-type
      '((exec herd start pipewire)
        (exec herd start pipewire-pulse))))

   (when stateless?
     (simple-service
      'pipewire-stateless
      home-stateless-service-type
      '((#:state . (((#:path . ("pulse/cookie" #:xdg-base "XDG_CONFIG_HOME"))
                     (#:store . #:machine)
                     (#:parent-dir-perms . ((#:mode . #o700)))))))))))
#+end_src
***** Wireplumber
#+begin_src scheme
(define* (wireplumber-services #:key
                               stateless?
                               sway?)
  (list
   (simple-service
    'wireplumber-add-package
    home-profile-service-type
    (list wireplumber))

   (simple-service
    'wireplumber-add-shepherd-daemon
    home-shepherd-service-type
    (list
     (shepherd-service
      (provision '(wireplumber pipewire-media-session))
      (requirement '(pipewire))
      (start #~(make-forkexec-constructor
                (list #$(file-append wireplumber "/bin/wireplumber"))
                #:log-file (string-append
                            (or (getenv "XDG_LOG_HOME")
                                (format #f "~a/.local/var/log"
                                        (getenv "HOME")))
                            "/wireplumber.log")
                #:environment-variables
                (append (list "DISABLE_RTKIT=1")
                        (default-environment-variables))))
      (stop  #~(make-kill-destructor))
      (auto-start? #f))))

   (when sway?
     (simple-service
      'wireplumber-sway-start
      home-sway-service-type
      '((exec herd start wireplumber))))

   (when stateless?
     (simple-service
      'wireplumber-stateless
      home-stateless-service-type
      '((#:state . (((#:path . ("wireplumber/" #:xdg-base "XDG_STATE_HOME"))
                     (#:store . #:machine)
                     (#:mode . #o700)))))))))
#+end_src
**** Flatpak
#+begin_src scheme
(define* (he-flatpak #:key
                     stateless?
                     wayland?)
  (list
   (simple-service
    'flatpak-add-packages
    home-profile-service-type
    (append
     (list flatpak)
     (if wayland?
         (list xdg-desktop-portal
               xdg-desktop-portal-wlr)
         '())))

   (when stateless?
     (simple-service
      'flatpak-stateless
      home-stateless-service-type
      '((#:state . (((#:path . ("flatpak/" #:xdg-base "XDG_DATA_HOME"))
                     (#:store . #:machine)
                     (#:mode . #o700)))))))))
#+end_src
***** Make Flatpak apps visible
TODO and remove "tangle no"
#+begin_src sh :tangle no
export XDG_DATA_DIRS=$HOME/.local/share/flatpak/exports/share:$XDG_DATA_DIRS
#+end_src
***** WIP Flatpak
TODO and remove "tangle no"
Ran these manually
#+begin_src sh :tangle no
flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

# flatpak install --user flathub com.spotify.Client
# flatpak install --user flathub us.zoom.Zoom
#+end_src
****** how to pin?
Some cursorily-googled intel:
- [[https://github.com/flatpak/flatpak/issues/3097][flatpak/flatpak#3097 Is there a way to install a specific version?]]
- [[https://discourse.flathub.org/t/install-an-older-version-of-an-app/320/3][Install an older version of an app - #3 by gjanssens - Flathub Discourse]]
**** Display managers
***** GDM
#+begin_src scheme
(define* (he-gdm #:key stateless?)
  (list
   (when stateless?
     (simple-service
      'gdm-stateless
      home-stateless-service-type
      '((#:state . (((#:path . ("gdm/" #:xdg-base "XDG_CACHE_HOME"))
                     (#:store . #:machine)
                     (#:mode . #o700)))))))))
#+end_src
**** Window managers
***** Common
#+begin_src scheme
(define* (he-wm-common #:key sway?)
  (wm-common-applets #:sway? sway?))

(define* (wm-common-applets #:key sway?)
  (list
   ;; The only one I know for sure needs to be installed is gammastep (the applet can't find its icon otherwise) but install the rest too just in case.
   (simple-service
    'wm-common-applet-add-packages
    home-profile-service-type
    (list network-manager-applet
          gammastep
          udiskie))
   (when sway?
     (simple-service
      'sway-start-applets
      home-sway-service-type
      `((exec ,(file-append network-manager-applet "/bin/nm-applet") --indicator)
        ;; (exec ,(file-append gammastep "/bin/gammastep-indicator") -l 44:-123) ; TODO Don't hardcode lat/long (use geoclue?) or make it a parameter.
        (exec ,(file-append udiskie "/bin/udiskie") --tray
              ;; --file-manager ,(file-append xdg-utils "/bin/xdg-open")
              ))))))
#+end_src
***** Sway
#+begin_src scheme
(define* (he-sway #:key
                  pipewire?
                  (sway-mod 'Mod1)
                  kb-layout
                  (kb-repeat-delay 250)
                  (kb-repeat-rate 35)
                  (xwayland? #t)
                  (screen-locker "loginctl lock-session")
                  idle-manager
                  application-launcher
                  default-terminal
                  (backup-terminal default-terminal)
                  (bg-image wallpaper)
                  extra-config)
  (list
   (simple-service
    'packages-for-sway
    home-profile-service-type
    (list qtwayland ; Copied from RDE. I don't know what this is for.
          swayhide ; TODO I'm pretty sure this isn't required for anything. I'm keeping it around for now so I can try it out, though.
          xdg-desktop-portal
          xdg-desktop-portal-wlr
          slurp)) ; This might be necessary to make xdg-desktop-portal-wlr screencasting work. See "xdpw will try to use the first chooser found in the list of hardcoded choosers..." in https://man.archlinux.org/man/xdg-desktop-portal-wlr.5.

   (simple-service
    'set-wayland-specific-env-vars
    home-environment-variables-service-type
    ;; Copied from RDE: I don't know what all of these do.
    (append
     '(("XDG_CURRENT_DESKTOP" . "sway")
       ("XDG_SESSION_TYPE" . "wayland")
       ("SDL_VIDEODRIVER" . "wayland")
       ("MOZ_ENABLE_WAYLAND" . "1")
       ("CLUTTER_BACKEND" . "wayland")
       ("ELM_ENGINE" . "wayland_egl")
       ("ECORE_EVAS_ENGINE" . "wayland-egl")
       ("QT_QPA_PLATFORM" . "wayland-egl")
       ("_JAVA_AWT_WM_NONREPARENTING" . "1"))
     (if pipewire?
         '(("RTC_USE_PIPEWIRE" . "true")) '())))

   (service
    home-sway-service-type
    (home-sway-configuration
     (package sway) ; Remove this when I'm not using `sway-latest` any more.
     (config
      `((xwayland ,(if xwayland? 'enable 'disable))

        (input type:keyboard
               ,(append
                 (if kb-layout
                     (append
                      `((xkb_layout ,(keyboard-layout-name kb-layout)))
                      (if-let ((variant (keyboard-layout-variant kb-layout)))
                              `((xkb_variant ,variant)) '())
                      (if-let ((model (keyboard-layout-model kb-layout)))
                              `((xkb_model ,model)) '())
                      (let ((options (keyboard-layout-options kb-layout)))
                        (if (null? options)
                            '()
                            `((xkb_options ,(string-join
                                             (keyboard-layout-options kb-layout) ","))))))
                     '())
                 `((repeat_delay ,kb-repeat-delay))
                 `((repeat_rate ,kb-repeat-rate))))

        (input type:touchpad
               ((natural_scroll enabled)
                (tap enabled)))

        (set $mod ,sway-mod)
        (set $term ,default-terminal)
        (set $backup-term ,backup-terminal)
        (set $menu ,application-launcher)
        (set $lock ,screen-locker)

        (floating_modifier $mod normal)

        (bindsym --to-code $mod+Shift+r reload)

        ;; Some of these might not be necessary. To be safe I'm using a combination of those in RDE and suggested in the Sway wiki and an RDE mailing list thread:
        ;; - https://github.com/swaywm/sway/wiki#gtk-applications-take-20-seconds-to-start
        ;; - https://lists.sr.ht/~abcdw/rde-discuss/%3C87bku5ozzn.fsf%40bruun.xyz%3E
        (exec ,(file-append dbus "/bin/dbus-update-activation-environment")
              DISPLAY WAYLAND_DISPLAY XDG_CURRENT_DESKTOP SWAYSOCK)

        ;; Launching external applications.
        (bindsym $mod+Control+Shift+Return exec $backup-term)
        (bindsym $mod+Return exec $term)
        (bindsym --to-code $mod+Shift+d exec $menu)
        (bindsym --to-code $mod+Control+Shift+l exec $lock)

        ;; Manipulating windows.
        (bindsym --to-code $mod+Shift+c kill)
        (bindsym --to-code $mod+Shift+f fullscreen)
        (bindsym $mod+Shift+space floating toggle)
        (bindsym $mod+Control+space focus mode_toggle)
        (bindsym $mod+h focus left)
        (bindsym $mod+j focus down)
        (bindsym $mod+k focus up)
        (bindsym $mod+l focus right)
        (bindsym $mod+Shift+h move left)
        (bindsym $mod+Shift+j move down)
        (bindsym $mod+Shift+k move up)
        (bindsym $mod+Shift+l move right)

        ;; Moving around workspaces.
        (bindsym $mod+tab workspace back_and_forth)
        ,@(append-map
           (lambda (x)
             `((bindsym ,(format #f "$mod+~a" (modulo x 10))
                        workspace number ,x)
               (bindsym ,(format #f "$mod+Shift+~a" (modulo x 10))
                        move container to workspace number ,x)))
           (iota 10 1))

        ;; Scratchpad settings.
        (bindsym --to-code $mod+Shift+minus move scratchpad)
        (bindsym --to-code $mod+minus scratchpad show)

        (default_border pixel)
        (default_floating_border pixel)
        (gaps inner 8)

        (exec ,idle-manager)

        ,@(let* ((step 10)
                 (step->symbol (lambda (op)
                                 (symbol-append (string->symbol (number->string step)) '% op)))
                 (brightnessctl (file-append brightnessctl "/bin/brightnessctl")))
            `((bindsym --locked XF86MonBrightnessUp exec ,brightnessctl set ,(step->symbol '+))
              (bindsym --locked XF86MonBrightnessDown exec ,brightnessctl set ,(step->symbol '-))))

        ,@(let* ((step 5)
                 (step->symbol (lambda (op)
                                 (symbol-append op (string->symbol (number->string step)) '%)))
                 (pactl (file-append pulseaudio "/bin/pactl")))
            `((bindsym --locked XF86AudioRaiseVolume "\\\n"
                       exec ,pactl set-sink-mute @DEFAULT_SINK@ "false; \\\n"
                       exec ,pactl set-sink-volume @DEFAULT_SINK@ ,(step->symbol '+))
              (bindsym --locked XF86AudioLowerVolume "\\\n"
                       exec ,pactl set-sink-mute @DEFAULT_SINK@ "false; \\\n"
                       exec ,pactl set-sink-volume @DEFAULT_SINK@ ,(step->symbol '-))
              (bindsym --locked XF86AudioMute
                       exec ,pactl set-sink-mute @DEFAULT_SINK@ toggle)
              (bindsym --locked XF86AudioMicMute
                       exec ,pactl set-source-mute @DEFAULT_SOURCE@ toggle)))

        ,@(let ((playerctl (file-append playerctl "/bin/playerctl")))
            `((bindsym --locked XF86AudioPlay exec ,playerctl play-pause)
              (bindsym --locked XF86AudioPrev exec ,playerctl previous)
              (bindsym --locked XF86AudioNext exec ,playerctl next)))

        ,@(if bg-image
              `((output * bg ,bg-image fill)) '())

        (bindsym $mod+Shift+b splith)
        (bindsym $mod+Shift+v splitv)
        (bindsym $mod+Shift+s layout stacking)
        (bindsym $mod+Shift+w layout tabbed)
        (bindsym $mod+Shift+e layout toggle split)
        (bindsym $mod+Shift+a focus parent)
        (bindsym $mod+Shift+q exec ,(file-append sway "/bin/swaynag")
                 -t warning -m "'You pressed the exit shortcut. Do you really want to exit sway?'"
                 -B "'Yes, exit sway'" ,#~(format #f "'~a exit'" #$(file-append sway "/bin/swaymsg")))
        (gaps left 78) ; To accommodate the crack in my screen.

        ,@(if extra-config
              extra-config '())))))

   (simple-service
    'sway-reload-config-on-change
    home-run-on-change-service-type
    `(("files/.config/sway/config"
       ,#~(system* #$(file-append sway "/bin/swaymsg") "reload"))))

   (sway-screenshot-service)))
#+end_src
****** TODO [#E] Conditionalize Sway environment variables
These should only be set for Sway and might mess up other sessions, like Gnome.
- check for the presence of =DESKTOP_SESSION=sway=?
- some (not particularly helpful) resources:
  - [[https://lists.sr.ht/~abcdw/rde-devel/%3C871qy1vtaz.fsf%40minikn.xyz%3E][{BUG} feature-sway breaks existing GNOME sessions  sourcehut lists]]
  - [[https://www.reddit.com/r/swaywm/comments/sw9lct/whats_the_recommended_way_of_setting_environment/][Whats the recommended way of setting environment variables? .profile doesnt w...]]
****** Sway screenshot
#+begin_src scheme
(define (sway-screenshot-service)
  (simple-service
   'sway-screenshot
   home-sway-service-type
   `((bindsym $mod+grave exec ,shot-output)
     (bindsym $mod+Control+grave exec ,swappy-clipboard)
     (bindsym $mod+Shift+grave exec ,shot-window-or-selection))))

(define subject-output
  #~(format #f "~a -t get_outputs | ~a -r '.[] | select(.focused) | .name'"
            #$(file-append sway "/bin/swaymsg")
            #$(file-append jq "/bin/jq")))

(define subject-window-or-selection
  #~(format #f "~a -t get_tree | ~a -r '.. | select(.pid? and .visible?) \
| .rect | \"\\(.x),\\(.y) \\(.width)x\\(.height)\"' | ~a -b ~a -B ~a"
            #$(file-append sway "/bin/swaymsg")
            #$(file-append jq "/bin/jq")
            #$(file-append slurp "/bin/slurp")
            "303030AA"
            "303030AA"))

(define* (shot-script subject #:key output geom (file "-"))
  (program-file
   (string-append "sway-shot-" subject)
   #~(system
      (format #f "~a ~a~a~a | ~a"
              #$(file-append grim "/bin/grim")
              #$(if output #~(string-append "-o \"$(" #$output ")\" ") "")
              #$(if geom #~(string-append "-g \"$(" #$geom ")\" ") "")
              #$file
              #$(file-append wl-clipboard "/bin/wl-copy")))))

(define shot-output
  (shot-script "output" #:output subject-output))

(define shot-window-or-selection
  (shot-script "window-or-selection" #:geom subject-window-or-selection))

(define swappy-clipboard
  (program-file
   "sway-swappy-clipboard"
   #~(system
      (format #f "~a | ~a -f -"
              #$(file-append wl-clipboard "/bin/wl-paste")
              #$(file-append swappy "/bin/swappy")))))
#+end_src
**** Screen lockers
***** Swaylock
#+begin_src scheme
(define* (he-swaylock #:key
                      font
                      ;; TODO `serialize-swaylock-config` doesn't presently allow gexps.
                      ;; (image "/home/pharcosyle/work/phrenetic/ebullient/home/alucard_bg.png")
                      (image "/.persist/home/pharcosyle/phrenetic_for_now/ebullient/home/alucard_bg.png")
                      ;; (image wallpaper)
                      extra-config)
  (list
   (service
    home-swaylock-service-type
    (home-swaylock-configuration
     (swaylock swaylock-effects)
     (config
      `((daemonize)

        (font . ,(assoc-ref font #:font/name))
        (image . ,image)

        (show-failed-attempts)
        (ignore-empty-password)

        (indicator)
        (indicator-idle-visible)
        (indicator-caps-lock)
        (indicator-radius . "240")
        (indicator-thickness . "20")

        ;; TODO Source colors from color scheme.
        (key-hl-color . "880033")
        (bs-hl-color . "ee2e24FF")
        (separator-color . "00000000")

        (inside-color . "00000099")
        (inside-clear-color . "ffd20400")
        (inside-ver-color . "d9d8d800")
        (inside-wrong-color . "ee2e2400")

        (ring-color . "231f20D9")
        (ring-clear-color . "231f20D9")
        (ring-ver-color . "231f20D9")
        (ring-wrong-color . "231f20D9")

        (line-color . "00000000")
        (line-clear-color . "ffd204FF")
        (line-ver-color . "d9d8d8FF")
        (line-wrong-color . "ee2e24FF")

        (text-clear-color . "ffd20400")
        (text-ver-color . "d9d8d800")
        (text-wrong-color . "ee2e2400")

        ;; Effects

        (grace . "15")
        (effect-blur . 7x5)
        (clock)
        (fade-in . "0.2")

        ,@(if extra-config
              extra-config '())))))))

(define (swaylock-screen-locker)
  "/run/setuid-programs/swaylock") ; According to Andrew Tropin, this can be changed to a store path once https://issues.guix.gnu.org/53468 is resolved (which it is but in core-updates which as of [2022-08-23 Tue] hasn't been merged to master).
#+end_src
**** Idle managers
***** Swayidle
#+begin_src scheme
(define* (he-swayidle #:key
                      sway?
                      screen-locker
                      (lock-timeout 300)
                      extra-config)
  (list
   (service
    home-swayidle-service-type
    (home-swayidle-configuration
     (config
      `(,@(if screen-locker
              (let ((lock-cmd-quoted (format #f "'~a'" screen-locker)))
                `((lock ,lock-cmd-quoted)
                  (before-sleep ,lock-cmd-quoted)
                  (timeout ,lock-timeout ,lock-cmd-quoted)))
              '())
        ,@(if extra-config
              extra-config '())))))

   (when sway?
     (let* ((swaymsg (file-append sway "/bin/swaymsg"))
            (swaymsg-cmd (lambda (cmd)
                           #~(format #f "'~a \"~a\"'" #$swaymsg #$cmd)))
            (idle-timeout (+ lock-timeout 30)))
       (simple-service
        'swayidle-add-sway-dpms
        home-swayidle-service-type
        `((timeout ,idle-timeout ,(swaymsg-cmd "output * dpms off") resume ,(swaymsg-cmd "output * dpms on"))))))))

(define (swayidle-idle-manager)
  (file-append swayidle "/bin/swayidle -w"))
#+end_src
**** Notification daemons
***** Mako
#+begin_src scheme
(define* (he-mako #:key
                  sway?
                  menu
                  theme ; TODO unused. Use it.
                  font)
  (list
   (simple-service
    'mako-add-packages
    home-profile-service-type
    (list mako
          jq)) ; Required to use `makoctl menu'. Ideally this would be part of the Guix package.

   (simple-service
    'mako-config
    home-xdg-configuration-files-service-type
    `(("mako/config"
       ,(ini-config-file
         "mako-config"
         `((global ((font . ,(string->symbol (font-value font)))
                    (max-icon-size . ,(string->symbol "32"))
                    (text-color . ,(string->symbol "#dee2f8"))
                    (background-color . ,(string->symbol (string-append "#282c34" "1A"))) ; TODO why isn't the transparency working right?
                    (border-color . ,(string->symbol "#8496ff"))
                    (border-size . ,(string->symbol "2"))
                    (border-radius . ,(string->symbol "8"))))
           (urgency=low ((border-color . ,(string->symbol "#9fed9c"))))
           (urgency=high ((border-color . ,(string->symbol "#fb8578")))))
         #:serialize-ini-config
         (lambda (config)
           (serialize-ini-config config #:equal-string "="))))))

   (when sway?
     (simple-service
      'mako-add-to-sway
      home-sway-service-type
      `((exec ,(file-append mako "/bin/mako"))
        ,@(let ((makoctl (file-append mako "/bin/makoctl")))
            `((bindsym $mod+m exec ,makoctl dismiss)
              (bindsym $mod+Shift+m exec ,makoctl restore)
              (bindsym $mod+Control+m exec ,makoctl menu ,menu "\"Notification action\""))))))))
#+end_src
**** Status bars
***** Waybar
#+begin_src scheme
(define* (he-waybar #:key
                    sway?
                    (waybar-modules
                     (append
                      (list
                       (waybar-clock))
                      (if sway?
                          (list
                           (waybar-sway-workspaces)
                           (waybar-sway-window))
                          '())
                      (list
                       (waybar-tray)
                       (waybar-idle-inhibitor)
                       (waybar-audio)
                       (waybar-backlight)
                       (waybar-cpu)
                       (waybar-memory)
                       (waybar-battery))))
                    theme ; TODO unused. Use it.
                    (css (local-file "waybar-style.css"))
                    font
                    transitions?)
  (append
   (list
    (service
     home-waybar-service-type
     (home-waybar-configuration
      (config #(((position . top)
                 (name . main))))
      (style-css
       `(,#~(format #f "@import \"~a\";\n" #$css)
            (*
             ((font-family . #(FontAwesome
                               ,@(if font
                                     (list
                                      (-> font (assoc-ref #:font/name) string->symbol))
                                     '())))
              ,@(if transitions? '() '((transition . none)))
              (box-shadow . none)
              (text-shadow . none)
              (min-height . 0)))

            (tooltip
             ((border . (solid @base02))
              (background . @base01)
              (opacity . 0.9)))

            ((tooltip label)
             ((color . @base04)
              (padding . 0)))

            (#{#waybar}#
             ((color . @base04)
              (background . @base01)))

            (#((.modules-right label)
               (.modules-right image))
             ((margin . (0.4em 0.2em))
              (padding . (0 0.4em))
              (background . @base02)
              (border-radius . 0.2em)))

            ;; To accommodate the crack in my screen.
            (.modules-left
             ((margin-left . 82px)))
            ;; (.modules-left
            ;;  ((margin-left . 0.2em)))

            (.modules-right
             ((margin-right . 0.2em))))))))

   waybar-modules

   (list
    (simple-service
     'waybar-add-font-package
     home-profile-service-type
     (list font-awesome))

    (simple-service
     'waybar-reload-config-on-change
     home-run-on-change-service-type
     (let ((reload-cmd #~(system* #$(file-append psmisc "/bin/killall") "-SIGUSR2" "waybar")))
       `(("files/.config/waybar/style.css"
          ,reload-cmd)
         ("files/.config/waybar/config"
          ,reload-cmd))))

    ;; I could pass the waybar command to the sway module (like I do with the screen locker and idle manager) instead of making this module aware of Sway, however the the `bar' command can take other arguments (see https://man.archlinux.org/man/sway-bar.5.en) that I might perhaps need in the future (though I think they only apply to swaybar, not waybar).
    (when sway?
      (simple-service
       'waybar-add-to-sway
       home-sway-service-type
       `((bar swaybar_command ,(file-append waybar "/bin/waybar"))
         (bindsym $mod+backslash exec ,(file-append psmisc "/bin/killall") -SIGUSR1 waybar)))))))
#+end_src
****** CSS
#+begin_src css :tangle (meta-in-dir "waybar-style.css")
@define-color base01 #282c34;
@define-color base02 #3f444a;
@define-color base04 #dee2f8;
@define-color base05 #9fed9c;
@define-color base07 #8496ff;
@define-color base08 #fb8578;
@define-color base09 #fdce5f;
#+end_src
****** Modules
#+begin_src scheme
(define* (waybar-module name
                        #:optional
                        config
                        style
                        #:key
                        (placement 'modules-right)
                        (bar-id 'main))
  (simple-service
   (symbol-append 'waybar-module- name)
   home-waybar-service-type
   (home-waybar-extension
    (config `#(((name . ,bar-id)
                (,placement . #(,name))
                (,name . ,(if config
                              config '())))))
    (style-css (if style
                   style '())))))

(define (waybar-audio)
  (waybar-module
   'pulseaudio
   `((format . "{volume}% {icon} {format_source}")
     (format-muted . " {format_source}")
     (format-bluetooth . "{volume}% {icon} {format_source}")
     (format-bluetooth-muted . " {icon} {format_source}")
     (format-source . "{volume}% ")
     (format-source-muted . "")
     (format-icons . ((headphone . )
                       (hands-free . )
                       (headset . )
                       (phone . )
                       (portable . )
                       (car . )
                       (default . #(  ))))
     (on-click . ,#~(string-append "\"" #$(file-append pavucontrol "/bin/pavucontrol") "\"")))))

(define (waybar-battery)
  (waybar-module
   'battery
   `((format . "{icon} {capacity}%")
     (format-charging . " {icon} {capacity}%")
     (states . ((empty . 10)
                (low . 20)
                (half-low . 40)
                (half . 60)
                (high . 90)
                (full . 100)))
     (format-icons . ((empty . )
                      (low . )
                      (half-low . )
                      (half . )
                      (high . )
                      (full . ))))
   `((#{#battery.discharging.empty}#
      ((color . @base08)))
     (#{#battery.discharging.low}#
      ((color . @base09)))
     (#{#battery.full}#
      ((color . @base05))))))

(define (waybar-backlight)
  (waybar-module
   'backlight
   '((format . " {percent}"))))

(define* (waybar-clock #:key
                       (format "{:%a %b %d %I:%M %p}"))
  (waybar-module
   'clock
   `((tooltip-format . "<big>{:%Y %B}</big>\n<tt><small>{calendar}</small></tt>")
     (format . ,format))
   '()
   #:placement 'modules-left))

(define (waybar-cpu)
  (waybar-module
   'cpu
   '((format . " {usage}%"))))

(define (waybar-idle-inhibitor)
  (waybar-module
   'idle_inhibitor
   '((format . {icon})
     (format-icons . ((activated . )
                      (deactivated . ))))))

(define (waybar-memory)
  (waybar-module
   'memory
   '((format . " {}%"))))

(define (waybar-sway-window)
  (waybar-module
   'sway/window
   `()
   `((#{#window}#
      ((margin-left . 1em)
       (margin-right . 1em))))
   #:placement 'modules-center))

(define* (waybar-sway-workspaces
          #:key
          persistent-workspaces
          (format-icons '(("1" . )
                          ("2" . )
                          ("3" . )
                          ("4" . )
                          ("6" . ) ; 
                          ("7" . ) ; 
                          ("8" . )
                          ("9" . )
                          ("10" . )
                          ("urgent" . )
                          ("focused" . )
                          ("default" . ))))
  (waybar-module
   'sway/workspaces
   `((disable-scroll . #t)
     (format . {icon})
     (format-icons . ,format-icons)
     (persistent_workspaces . ,(if persistent-workspaces
                                   persistent-workspaces '())))
   `(((#{#workspaces}# button)
      ((background . none)
       (border-radius . 0.2em)
       (margin . (0.4em 0.2em))
       (padding . (0.1em 0.2em))
       (color . @base04)))

     ((#{#workspaces}# button:hover)
      ((background . none)
       (border-color . @base07)))

     ((#{#workspaces}# button.focused)
      ((background . @base02)
       (color . @base07)))

     ((#{#workspaces}# button.urgent)
      ((color . @base08))))
   #:placement 'modules-left))

(define (waybar-tray)
  (waybar-module
   'tray
   `()
   `(((#{#tray}# menu)
      ((color . @base04)
       (background . @base01)
       (border . (solid 1px))
       (border-color . @base02)))

     ((#{#tray}# menu menuitem)
      ((padding-top . 0px)
       (padding-bottom . 0px)
       (margin-top . 0.1em)
       (margin-bottom . 0em)))

     ((#{#tray}# menu menuitem:hover)
      ((background . none)))

     ((#{#tray}# menu separator)
      ((background . @base02)
       (padding-top . 1px)
       (margin-top . 0.2em)
       (margin-bottom . 0.2em))))))
#+end_src
******* WAIT [#D] Remove zero-padding from clock hour
Once Waybar is updated in Guix this should be doable (possibly with the format =%-i=). See https://github.com/Alexays/Waybar/issues/1452.
**** Menus and launchers
***** Rofi
#+begin_src scheme
(define* (he-rofi #:key
                  stateless?
                  wayland?
                  theme)
  (list
   (service
    home-rofi-service-type
    (home-rofi-configuration
     (rofi (get-rofi wayland?))
     ;; TODO Trying out Andrew Tropin's confguration as-is for now, revisit later.
     (config-rasi
      `((configuration
         ((modi . "run,ssh,drun")
          (drun-show-actions . #t)
          (show-icons . #t)
          (kb-row-tab . "")
          (kb-row-select . "Tab")
          (kb-secondary-paste . "Control+y")
          (kb-remove-word-forward . "Alt+d")
          (kb-remove-word-back . "Control+w,Control+BackSpace")
          (kb-clear-line . "Control+slash")
          (kb-page-next . "Control+v")
          (kb-page-prev . "Alt+v")))
        ,#~(format #f "@theme \"~a\"" #$(case theme
                                          ((#:theme/light) "Arc")
                                          ((#:theme/dark) "Arc-Dark")))))))

   (when stateless?
     (simple-service
      'rofi-stateless
      home-stateless-service-type
      '((#:state . (((#:path . ("rofi3.druncache" #:xdg-base "XDG_CACHE_HOME"))
                     (#:store . #:persist)))))))))

(define* (rofi-menu #:key wayland?)
  (file-append (get-rofi wayland?) "/bin/rofi -dmenu -p"))

(define* (rofi-application-launcher #:key wayland?)
  (file-append (get-rofi wayland?) "/bin/rofi -show drun"))

(define (get-rofi wayland?)
  (if wayland?
      rofi-wayland
      rofi))
#+end_src
**** Terminals
***** Alacritty
#+begin_src scheme
(define* (he-alacritty #:key font)
  (list
   (service
    home-alacritty-service-type
    (home-alacritty-configuration
     (config
      `((window . ((padding . ((x . 10)
                               (y . 5)))))
        ,@(if font
              `((font . ((normal . ,(append
                                     `((family . ,(assoc-ref font #:font/name)))
                                     (if-let ((weight (assoc-ref font #:font/weight)))
                                             `((style . ,(font-weight->style weight))) '())))
                         (size . ,(assoc-ref font #:font/size)))))
              '())))))))

(define (font-weight->style weight)
  (->> weight
       symbol->string
       (string-delete #\-)
       string-capitalize))

(define (alacritty-terminal)
  (file-append alacritty "/bin/alacritty"))
#+end_src
** Packages
:PROPERTIES:
:meta-dir+: /packages
:END:
*** Fonts :package:version:
#+begin_src scheme :tangle (meta-in-dir "fonts.scm")
(define-module (ebullient home packages fonts)
  #:use-module ((gnu packages fonts) #:select (font-adobe-source-code-pro) #:prefix fonts:)
  #:use-module (ebullient utils))

(define-public font-adobe-source-code-pro
  (with-git-version
   fonts:font-adobe-source-code-pro
   #:version "2.038R-ro-1.058R-it-1.018R-VAR"
   #:commit "2.038R-ro/1.058R-it/1.018R-VAR"
   #:hash "00h4v3rmxyyaxni6nywacxvjnji2g2pi0b4js1yx0g67fvrv2gag"))
#+end_src
* Common
:PROPERTIES:
:meta-dir+: /ebullient
:END:
** Packages
:PROPERTIES:
:meta-dir+: /packages
:END:
*** KMonad :package:version:upstream:
#+begin_src scheme :tangle (meta-in-dir "haskell-apps.scm")
(define-module (ebullient packages haskell-apps)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages haskell-apps) #:select (kmonad) #:prefix haskell-apps:)
  #:use-module ((gnu packages haskell-check) #:select (ghc-hspec hspec-discover))
  #:use-module (ebullient utils))

(define-public kmonad
  (let ((commit "95bb58b7347ebacb4654fb21c798e1cd10331b0d"))
    (with-git-commit
     (package
       (inherit haskell-apps:kmonad)
       (arguments
        (substitute-keyword-arguments (package-arguments haskell-apps:kmonad)
          ((#:phases phases '%standard-phases)
           #~(modify-phases #$phases
               (add-after 'unpack 'patch-git-revision
                 (lambda _
                   (substitute* "src/KMonad/Args/Cmd.hs"
                     (("\\$\\(gitHash\\)") (string-append "\"" #$commit "\"")))))))))
       (inputs
        (modify-inputs (package-inputs haskell-apps:kmonad)
                       (prepend ghc-hspec
                                hspec-discover))))
     #:commit commit
     #:hash "0rprjk2n9ssvfk3hlibgd44zvn2hhxz1wqcrnjbbddvi3br5sv7s")))
#+end_src
*** Swaylock effects :package:version:
#+begin_src scheme :tangle (meta-in-dir "wm.scm")
(define-module (ebullient packages wm)
  #:use-module ((gnu packages wm) #:select (swaylock-effects) #:prefix wm:)
  #:use-module (ebullient utils))

(define-public swaylock-effects
  (with-git-commit
   wm:swaylock-effects
   #:upstream-version "1.6-3"
   #:commit "a8fc557b86e70f2f7a30ca9ff9b3124f89e7f204"
   #:hash "0f9571blnn7lg317js1j1spc5smz69i5aw6zkhskkm5m633rrpqq"))
#+end_src
** Stateless
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "stateless.scm")
:END:
#+begin_src scheme
(define-module (ebullient stateless)
  #:use-module (guix build-system trivial)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module (ebullient utils)
  #:use-module ((srfi srfi-1) #:select (append-map))
  #:export (extend-proc
            activate-gexp
            diff-tool-package))

(define state-dir-lookup
  #~(lambda (persist-dir machine-dir)
      (lambda (k)
        (case k
          ((#:persist) persist-dir)
          ((#:machine) machine-dir)))))

(define symlink-to-state?
  (with-imported-modules '((guix build utils))
    #~(lambda (state-dirs)
        (lambda (file)
          (use-modules ((guix build utils) #:select (symbolic-link?))
                       ((srfi srfi-1) #:select (any)))

          (and (symbolic-link? file)
               (any (lambda (state-dir)
                      (string-prefix? state-dir (readlink file)))
                    state-dirs))))))
#+end_src
*** Extend procedure
#+begin_src scheme
(define (extend-proc config additional)
  (let* ((field (lambda (k)
                  (append-map (lambda (i)
                                (or (assoc-ref i k) '()))
                              additional))))
    (->> config
         (acons #:state (field #:state))
         (acons #:ignore (field #:ignore)))))
#+end_src
*** Activate
#+begin_src scheme
(define (activate-gexp state
                       backup-base-dir
                       persist-dir
                       machine-dir)
  (with-imported-modules '((guix build utils))
    #~(begin
        (use-modules ((guix build utils) #:select (copy-recursively delete-file-recursively find-files mkdir-p)))

        (define (mkdirp-perms dir perms)
          (mkdir-p dir)
          (chown dir
                 (let ((user (assoc-ref perms #:user)))
                   (if user
                       (passwd:uid (getpwnam user)) -1))
                 (let ((group (assoc-ref perms #:group)))
                   (if group
                       (group:gid (getgrnam group)) -1)))
          (let ((mode (assoc-ref perms #:mode)))
            (when mode
              (chmod dir mode))))

        (define (no-follow-file-exists? file)
          (false-if-exception (lstat file)))

        (define timestamp (current-time))

        (define (cleanup-and-migrate target state-file state-dir)
          (let ((migrate-file
                 (lambda (source dest)
                   (copy-recursively source dest)
                   (delete-file-recursively source)))
                (backup-file
                 (lambda (file)
                   (let* ((backup-dir (string-append
                                       state-dir
                                       #$backup-base-dir
                                       "/stateless-backup-" (number->string timestamp)))
                          (backup-file (string-append
                                        backup-dir "/"
                                        (let* ((string-drop-prefix (lambda (s prefix)
                                                                     (string-drop s (string-length prefix))))
                                               (without-state-dir (lambda (file)
                                                                    (string-drop-prefix file state-dir)))
                                               (without-base-dir (lambda (file)
                                                                   (string-drop-prefix file #$backup-base-dir))))
                                          ((compose without-base-dir
                                                    without-state-dir)
                                           file)))))
                     (mkdir-p (dirname backup-file))
                     (rename-file file backup-file)))))
            (when (no-follow-file-exists? target)
              (if ((#$symlink-to-state? (list #$persist-dir
                                              #$machine-dir))
                   target)
                  (delete-file target)
                  (begin
                    (when (no-follow-file-exists? state-file)
                      (if (nil? (find-files state-file))
                          (delete-file-recursively state-file)
                          (backup-file state-file)))
                    (migrate-file target state-file))))))

        (define (process-state-entry i)
          (let* ((path (assoc-ref i #:path))
                 (directory-target? (string-suffix? "/" path))
                 (target (if directory-target?
                             (string-drop-right path 1) path))
                 (state-dir ((#$state-dir-lookup #$persist-dir #$machine-dir)
                             (assoc-ref i #:store))))
            (let ((parent-dir (dirname path))
                  (parent-dir-perms (assoc-ref i #:parent-dir-perms)))
              (mkdirp-perms (string-append state-dir parent-dir) parent-dir-perms)
              (mkdirp-perms parent-dir parent-dir-perms))
            (let ((state-file (string-append state-dir target)))
              (cleanup-and-migrate target state-file state-dir)
              (when directory-target?
                (mkdirp-perms state-file i))
              (when (no-follow-file-exists? state-file)
                (symlink state-file target)))))

        (for-each process-state-entry #$state))))
#+end_src
*** Diff tool
**** Program
#+begin_src scheme
(define* (diff-tool-program state
                            ignore
                            base-dir
                            persist-dir
                            machine-dir
                            #:key
                            additional-known)
  (program-file
   "diff-tool"
   (with-imported-modules '((guix build utils))
     #~(begin
         (use-modules ((guix build utils) #:select (store-file-name? symbolic-link?))
                      ((ice-9 ftw) #:select (file-system-fold))
                      ((srfi srfi-1) #:select (any)))

         (define* (find-diff dir known)
           (let* ((check-path
                   (lambda (path result)
                     (let ((pred (assoc-ref known path)))
                       (if (and pred (pred path))
                           result
                           (cons path result)))))
                  (results
                   (file-system-fold
                    (let ((known-paths (map car known)))
                      (lambda (dir _ _*)
                        (and (not (member (string-append dir "/") known-paths))
                             (any (lambda (known-path)
                                    (string-prefix? dir known-path))
                                  known-paths))))
                    (lambda (file _ result)
                      (check-path file result))
                    (lambda (_ _* result)
                      result)
                    (lambda (_ _* result)
                      result)
                    (lambda (dir _ result)
                      (check-path (string-append dir "/") result))
                    (lambda (path _ errno result)
                      (format (current-error-port) "~a: ~a~%" path (strerror errno))
                      result)
                    '()
                    dir)))
             (sort results string<?)))

         (define (make-known files pred)
           (map (lambda (file)
                  (cons file pred))
                files))

         (define (make-known-files+dirs paths)
           (map (let ((directory?
                       (lambda (path)
                         (eq? (stat:type (lstat path)) 'directory))))
                  (lambda (path)
                    (cons path
                          (if (string-suffix? "/" path)
                              directory?
                              (negate directory?)))))
                paths))

         (define (state->paths state)
           (map (lambda (entry)
                  (assoc-ref entry #:path))
                state))

         (define (symlink-to-store? file)
           (and (symbolic-link? file)
                (store-file-name? (readlink file))))

         (define (diff-live)
           (find-diff
            #$base-dir
            (append
             (make-known (map (lambda (path)
                                (if (string-suffix? "/" path)
                                    (string-drop-right path 1) path))
                              (state->paths #$state))
                         (#$symlink-to-state? (list #$persist-dir
                                                    #$machine-dir)))
             (make-known-files+dirs #$ignore)
             (or #$additional-known '()))))

         (define (diff-state)
           (let ((finder
                  (lambda (store state)
                    (let ((state-dir ((#$state-dir-lookup #$persist-dir #$machine-dir)
                                      store)))
                      (find-diff
                       (string-append state-dir #$base-dir)
                       (make-known-files+dirs
                        (let ((state-in-store
                               (filter (lambda (entry)
                                         (eq? (assoc-ref entry #:store) store))
                                       #$state)))
                          (map (lambda (path)
                                 (string-append state-dir path))
                               (state->paths state-in-store)))))))))
             (append
              (finder #:persist #$state)
              (finder #:machine #$state))))

         (define (run-mode)
           (string->symbol
            (or
             (false-if-exception (cadr (command-line)))
             "active")))

         (for-each
          (lambda (path)
            (display (string-append path "\n")))
          (case (run-mode)
            ((active) (diff-live))
            ((state) (diff-state))))))))
#+end_src
**** Package
#+begin_src scheme
(define* (diff-tool-package bin-name #:rest opts)
  (package
    (inherit blank-package)
    (name "stateless-diff-tool")
    (source (apply diff-tool-program opts))
    (build-system trivial-build-system)
    (arguments
     `(#:builder
       ,#~(begin
            (let* ((bin (string-append #$output "/bin")))
              (mkdir #$output)
              (mkdir bin)
              (symlink #$source (string-append bin "/" #$bin-name))))))))
#+end_src
* Utils
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "ebullient/utils.scm")
:END:
#+begin_src scheme
(define-module (ebullient utils)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module (gnu services)
  #:use-module ((srfi srfi-1) #:select (take drop remove fold))
  #:export (when-let
            if-let
            when-not
            if-not
            ->
            ->>
            as->
            blank-package
            with-git-version
            with-git-commit
            with-git-url))
#+end_src
** Branching
#+begin_src scheme
(define-syntax when-let
  (syntax-rules ()
    ((_ ((var expr)) body ...)
     (let ((var expr))
       (when var body ...)))))

(define-syntax if-let
  (syntax-rules ()
    ((_ ((var expr)) then else)
     (let ((var expr))
       (if var then else)))))

(define-syntax when-not
  (syntax-rules ()
    ((_ test body ...)
     (when (not test) body ...))))

(define-syntax if-not
  (syntax-rules ()
    ((_ test then else)
     (if (not test) then else))))
#+end_src
** Functions
#+begin_src scheme
(define-syntax ->
  (syntax-rules ()
    ((_ x) x)
    ((_ x (f args ...) expr ...) (-> (f x args ...) expr ...))
    ((_ x f expr ...) (-> (f x) expr ...))))

(define-syntax ->>
  (syntax-rules ()
    ((_ x) x)
    ((_ x (f args ...) expr ...) (->> (f args ... x) expr ...))
    ((_ x f expr ...) (->> (f x) expr ...))))

(define-syntax as->
  (lambda (x)
    (syntax-case x ()
      ((_ exp name) #'exp)
      ((_ exp name form form* ...)
       (with-syntax ((x (datum->syntax #'form (syntax->datum #'name))))
         #'(let ((x exp))
             (as-> form name form* ...)))))))
#+end_src
** Guix
#+begin_src scheme
(define blank-package
  (package
    (name #f)
    (version "0")
    (source #f)
    (build-system #f)
    (synopsis #f)
    (description #f)
    (home-page #f)
    (license #f)))

(define* (with-git pkg
                   #:key
                   upstream-version
                   revision
                   commit
                   hash)
  (package
    (inherit pkg)
    (version (if revision
                 (git-version upstream-version revision commit)
                 upstream-version))
    (source
     (origin
       (inherit (package-source pkg))
       (uri (git-reference
             (inherit (-> pkg package-source origin-uri))
             (commit commit)))
       (sha256
        (base32
         hash))
       (file-name (git-file-name (package-name pkg) version))))))

(define* (with-git-version pkg #:key version commit hash)
  (with-git pkg
            #:upstream-version version
            #:commit commit
            #:hash hash))

(define* (with-git-commit pkg
                          #:key
                          (upstream-version (package-version pkg))
                          (revision "0")
                          commit
                          hash)
  (with-git pkg
            #:upstream-version upstream-version
            #:revision revision
            #:commit commit
            #:hash hash))

(define (with-git-url pkg url)
  (package
    (inherit pkg)
    (source
     (origin
       (inherit (package-source pkg))
       (uri (git-reference
             (inherit (-> pkg package-source origin-uri))
             (url url)))))))
#+end_src
* Auxillary
:PROPERTIES:
:meta-dir+: /penitent
:END:
** Packages
:PROPERTIES:
:meta-dir+: /packages
:END:
*** AWS CLI :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "aws.scm")
:END:
- TODO
  - generate the autocompletion index
    As described here:
    [[https://github.com/aws/aws-cli/tree/v2#cli-dev-version][GitHub - aws/aws-cli at v2 (cli dev version)]]
    [[https://github.com/NixOS/nixpkgs/blob/nixos-unstable/pkgs/tools/admin/awscli2/default.nix#L95][nixpkgs/default.nix at nixos-unstable  NixOS/nixpkgs  GitHub]]
  - set up command completion
    [[https://github.com/aws/aws-cli/tree/v2#command-completion][GitHub - aws/aws-cli at v2 (command completion)]]
  - [2022-04-13 Wed] dependencies don't need to be propagated?
    [[https://github.com/guix-mirror/guix/commit/fc89b50b7bb2edbc38b20adf8c899934dedcb6c3][gnu: awscli: Do not propagate inputs.  guix-mirror/guix@fc89b50  GitHub]]
    This is for v1, might not apply here. At the time of this writing, this commit is only two hours old, see if there's any follow-up.
#+begin_src scheme
(define-module (penitent packages aws)
  #:use-module (guix build-system python)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages check) #:select (python-mock python-pytest python-coverage python-pytest-cov python-pytest-xdist))
  #:use-module ((gnu packages cmake) #:select (cmake))
  #:use-module ((gnu packages groff) #:select (groff))
  #:use-module ((gnu packages python-web) #:select (awscli) #:prefix python-web:)
  #:use-module ((gnu packages python-web) #:select (python-urllib3))
  #:use-module ((gnu packages python-xyz) #:select (python-prompt-toolkit) #:prefix python:)
  #:use-module ((gnu packages python-xyz) #:select (python-colorama-for-awscli python-docutils-0.15 python-wcwidth python-distro python-jmespath python-boto3 python-botocore python-six python-jsonschema))
  #:use-module ((gnu packages python-crypto) #:select (python-cryptography) #:prefix python-crypto:)
  #:use-module ((gnu packages serialization) #:select (python-ruamel.yaml))
  #:use-module ((gnu packages time) #:select (python-dateutil)))

(define-public awscli
  (package
    (inherit python-web:awscli)
    (version "2.4.23")
    (source
     (origin
       (method git-fetch)
       (uri (git-reference
             (url "https://github.com/aws/aws-cli")
             (commit version)))
       (sha256
        (base32
         "1xdgj6w6ibfiwpzd85g9lhk106nxrw06c9bdcrmfr68zaa32k6ff"))
       (file-name (git-file-name (package-name python-web:awscli) version))))
    (arguments
     (substitute-keyword-arguments (package-arguments python-web:awscli)
       ;; A few tests fail at present but I'm not gonna sweat it. A number more error but I think that's mostly due to the lack of network access. The vast majority pass:
       ;; Total tests ~7000 (failures=3, errors=222, skipped=6)
       ((#:tests? _) #f)))
    (propagated-inputs
     (list python-colorama-for-awscli
           python-docutils-0.15
           python-cryptography
           python-ruamel.yaml-0.15
           python-wcwidth
           python-prompt-toolkit
           python-distro-1.5
           python-awscrt
           python-dateutil
           python-jmespath
           python-urllib3))
    (native-inputs
     (list groff
           ;; For tests.
           python-jsonschema
           python-mock
           python-pytest
           python-coverage
           python-pytest-cov
           python-pytest-xdist))))
#+end_src
**** Deps :package:version:
#+begin_src scheme
(define python-awscrt
  (package
    (name "python-awscrt")
    (version "0.12.4")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "awscrt" version))
       (sha256
        (base32 "1cmfkcv2zzirxsb989vx1hvna9nv24pghcvypl0zaxsjphv97mka"))))
    (build-system python-build-system)
    (native-inputs
     (list
      cmake
      ;; For tests.
      python-boto3))
    (home-page "https://github.com/awslabs/aws-crt-python")
    (synopsis "A common runtime for AWS Python projects")
    (description "This package provides a common runtime for AWS Python projects")
    (license license:asl2.0)))

(define python-cryptography
  (package
    (inherit python-crypto:python-cryptography)
    (version "3.3.2")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "cryptography" version))
       (sha256
        (base32
         "1vcvw4lkw1spiq322pm1256kail8nck6bbgpdxx3pqa905wd6q2s"))))))

(define python-ruamel.yaml-0.15
  (package
    (inherit python-ruamel.yaml)
    (version "0.15.100")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "ruamel.yaml" version))
       (sha256
        (base32
         "1r5j9n2jdq48z0k4bdia1f7krn8f2x3y49i9ba9iks2rg83g6hlf"))))))

(define python-prompt-toolkit
  (package
    (inherit python:python-prompt-toolkit)
    (version "3.0.28")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "prompt_toolkit" version))
       (sha256
        (base32
         "0l0nnm9fvs8lklk2qq8mylb9jrlxvlqzpmqr4n7rdhl63rmx274z"))))))

(define python-distro-1.5
  (package
    (inherit python-distro)
    (version "1.5.0")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "distro" version))
       (sha256
        (base32
         "14nz51cqlnxmgfqqilxyvjwwa5xfivdvlm0d0b1qzgcgwdm7an0f"))))))
#+end_src
*** Datomic CLI tools :package:version:
- TODO =bin/datomic= introduces a dependency (~com.datomic/tools.ops~)
  Is that something I'd want to include in the package or whatever?
#+begin_src scheme :tangle (meta-in-dir "datomic.scm")
(define-module (penitent packages datomic)
  #:use-module (guix build-system copy)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((gnu packages compression) #:select (unzip))
  #:use-module ((nonguix licenses) #:prefix license:))

(define-public datomic-cli-tools
  (package
    (name "datomic-cli-tools")
    (version "1.0.91")
    (source
     (origin
       (method url-fetch)
       (uri (string-append "https://datomic-releases-1fc2183a.s3.amazonaws.com/tools/datomic-cli/datomic-cli-" version ".zip"))
       (sha256
        (base32
         "1xicmbsig8f1p5r9rxkhndi0f9l9w421zf49rbx44yc6v0db523b"))))
    (build-system copy-build-system)
    (arguments
     `(#:install-plan
       '(("." "bin" #:include-regexp ("^\\./datomic")) ; Files that start with "datomic" are the scripts. Restrict to this subset to automatically pick up any added in the future without being too inclusive about what we add to bin.
         ("README.txt" "share/doc/datomic/"))
       #:phases
       ,#~(modify-phases %standard-phases
            (add-after 'install 'make-scripts-executable
              (lambda _
                (for-each (lambda (f) (chmod f #o555))
                          (find-files (string-append #$output "/bin"))))))))
    (native-inputs
     (list unzip))
    (home-page "https://docs.datomic.com/cloud/index.html")
    (synopsis "CLI tools for Datomic")
    (description synopsis)
    (license (license:nonfree "https://www.datomic.com/cloud-eula.html"))))
#+end_src
*** Clojure
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "clojure.scm")
:END:
**** =man= pages :upstream:
#+begin_src scheme
(define-module (penitent packages clojure)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages clojure) #:select (clojure-tools) #:prefix clojure:))

(define (with-man-pages clojure-tools)
  (package
    (inherit clojure-tools)
    (arguments
     (substitute-keyword-arguments (package-arguments clojure-tools)
       ((#:install-plan install-plan)
        #~(append #$install-plan '(("clojure.1" "/share/man/man1/")
                                   ("clj.1" "/share/man/man1/"))))))))

(define-public clojure-tools-with-man-pages
  (with-man-pages clojure:clojure-tools))
#+end_src
* Configurations
:PROPERTIES:
:meta-dir+: /exuberant
:END:
** Frostfire
#+begin_src scheme :tangle (meta-in-dir "frostfire.scm") :noweb yes
(define-module (exuberant frostfire)
  #:use-module ((ebullient home) #:prefix home:)
  #:use-module (ebullient install)
  #:use-module ((ebullient system) #:prefix system:)
  #:use-module (ebullient utils)
  #:use-module ((exuberant he) #:prefix he:)
  #:use-module ((exuberant os) #:prefix os:)
  #:export (frostfire
            installer
            primary
            aux
            guest))

(define* (os-base #:key
                  primary-name
                  aux-name
                  guest-name
                  bluetooth?)
  (apply
   os:os-base
   system:blank-os
   #:source? #t
   #:source-path "/.persist/home/pharcosyle/phrenetic_for_now"
   #:users-info `(((#:name . ,primary-name)
                   (#:comment . "Krzysztof Baranowski")
                   (#:admin? . #t)
                   (#:password . "mellon")) ; TODO remove this
                  ((#:name . ,aux-name)
                   (#:comment . "Phil Coulson")
                   (#:admin? . #t)
                   (#:password . "mellon")) ; TODO remove this
                  ((#:name . ,guest-name)
                   (#:comment . "Speak Friend and Enter")
                   (#:password . "mellon")
                   (#:admin? . #t))) ; TODO remove this
   #:kmonad? #t
   #:kmonad-users (list primary-name
                        aux-name)
   #:bluetooth? bluetooth?
   #:bluetooth-users (list primary-name
                           aux-name
                           guest-name)
   ;; #:gdm-auto-login primary-name ; REVIEW Enable this later.
   #:sessions '(#:session/gnome
                #:session/sway)
   os+he-shared-opts))


(define* (primary-he)
  (home:create-he
   (apply
    he:he-base
    #:email "pharcosyle@gmail.com"
    #:developer? #t
    #:kmonad? #t
    #:sessions '(#:session/sway)
    he-shared-opts)))

(define aux-he primary-he)

(define (guest-he)
  (home:create-he
   (apply he:he-base he-shared-opts)))


(define nix? #t)
(define stateless? #t)
(define stateless-persist-dir os:stateless-persist-dir)
(define stateless-machine-dir os:stateless-machine-dir)

(define os+he-shared-opts
  `(#:stateless? ,stateless?
    #:nix? ,nix?
    #:console? #t
    #:desktop? #t
    #:pipewire? #t
    #:gdm? #t))

(define he-shared-opts
  (append
   os+he-shared-opts
   `(#:stateless-persist-dir ,stateless-persist-dir
     #:stateless-machine-dir ,stateless-machine-dir)))


(define efi? #t)
(define boot-label os:boot-label)
(define boot-target os:efi-boot-target)
(define filesystem #:filesystem/btrfs)
(define root-label os:root-label)
(define mountables (os:stateless-mountables
                    #:persist-dir stateless-persist-dir
                    #:machine-dir stateless-machine-dir
                    #:nix? nix?))
(define btrfs-mount-flags os:btrfs-mount-flags)
(define btrfs-mount-options os:btrfs-mount-options)
(define disk-encryption? #t)
(define luks-label os:luks-label)


(define frostfire
  (let ((primary-name "pharcosyle")
        (aux-name "pcoulson")
        (guest-name "gandalf")
        (bluetooth? #t))
    (-> (os-base #:primary-name primary-name
                 #:aux-name aux-name
                 #:guest-name guest-name
                 #:bluetooth? bluetooth?)
        (os:with-host-info #:host-name "frostfire"
                           #:timezone "America/Los_Angeles")
        (os:with-bootloader #:efi? efi?
                            #:boot-label boot-label
                            #:boot-target boot-target)
        (os:with-filesystems #:filesystem filesystem
                             #:root-label root-label
                             #:mountables mountables
                             #:btrfs-mount-flags btrfs-mount-flags
                             #:btrfs-mount-options btrfs-mount-options
                             #:disk-encryption? disk-encryption?
                             #:luks-label luks-label
                             #:luks-uuid "<<frostfire-luks-uuid>>"
                             #:stateless? stateless?
                             #:stateless-persist-dir stateless-persist-dir
                             #:stateless-machine-dir stateless-machine-dir
                             #:stateless-users `((,primary-name . ,(primary-he))
                                                 (,aux-name . ,(aux-he))
                                                 (,guest-name . ,(guest-he))))
        (os:with-macbook-hardware #:bluetooth? bluetooth?))))

(define installer
  (installer-package #:os-name "frostfire"
                     #:efi? efi?
                     #:boot-label boot-label
                     #:boot-target boot-target
                     #:root-label root-label
                     #:disk-encryption? disk-encryption?
                     #:luks-label luks-label
                     #:filesystem filesystem
                     #:mountables mountables
                     #:btrfs-mount-flags btrfs-mount-flags
                     #:btrfs-mount-options btrfs-mount-options))

(define primary (primary-he))
(define aux (aux-he))
(define guest (guest-he))

frostfire
#+end_src
*** LUKS UUID :external_state:
#+name: frostfire-luks-uuid
#+begin_src org
bdda56af-6ca0-4953-bc13-d5af8715e0e5
#+end_src
*** Channels
#+begin_src scheme :tangle (meta-in-dir "channels")
(cons* (channel
        (name 'flat)
        (url "https://github.com/flatwhatson/guix-channel.git")
        (introduction
         (make-channel-introduction
          "33f86a4b48205c0dc19d7c036c85393f0766f806"
          (openpgp-fingerprint
           "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490"))))
       (channel
        (name 'rde)
        (url "https://git.sr.ht/~abcdw/rde")
        (introduction
         (make-channel-introduction
          "257cebd587b66e4d865b3537a9a88cccd7107c95"
          (openpgp-fingerprint
           "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
       (channel
        (name 'nonguix)
        (url "https://gitlab.com/nonguix/nonguix")
        (introduction
         (make-channel-introduction
          "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
          (openpgp-fingerprint
           "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
       %default-channels)
#+end_src
**** COMMENT From project channel
#+begin_src scheme :tangle (meta-in-dir "channels")
(cons* (channel
        (name 'phrenetic)
        (url "https://github.com/pharcosyle/phrenetic")
        (branch "tangled"))
       %default-channels)
#+end_src
**** COMMENT From project channel (local)
#+begin_src scheme :tangle (meta-in-dir "channels")
(cons* (channel
        (name 'phrenetic)
        (url "file:///home/pharcosyle/work/phrenetic")
        (branch "tangled"))
       %default-channels)
#+end_src
*** Channels lock :version:
#+begin_src scheme :tangle (meta-in-dir "channels-lock")
(list (channel
       (name 'guix)
       (url "https://git.savannah.gnu.org/git/guix.git")
       (branch "master")
       (commit
        "4c03f62ad04c2cbbfc7ed61c97b0ecf897383706")
       (introduction
        (make-channel-introduction
         "9edb3f66fd807b096b48283debdcddccfea34bad"
         (openpgp-fingerprint
          "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA"))))
      (channel
       (name 'flat)
       (url "https://github.com/flatwhatson/guix-channel.git")
       (branch "master")
       (commit
        "bfc961929e93114bcbc230edca3a771070efad3e")
       (introduction
        (make-channel-introduction
         "33f86a4b48205c0dc19d7c036c85393f0766f806"
         (openpgp-fingerprint
          "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490"))))
      (channel
       (name 'rde)
       (url "https://git.sr.ht/~abcdw/rde")
       (branch "master")
       (commit
        "8c40c5d37fc007bdfc012722324303b7c9120a5a")
       (introduction
        (make-channel-introduction
         "257cebd587b66e4d865b3537a9a88cccd7107c95"
         (openpgp-fingerprint
          "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
      (channel
       (name 'nonguix)
       (url "https://gitlab.com/nonguix/nonguix")
       (branch "master")
       (commit
        "9cf71573089c878d553314a3a5e51dc7487db449")
       (introduction
        (make-channel-introduction
         "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
         (openpgp-fingerprint
          "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5")))))
#+end_src
**** COMMENT From project channel
#+begin_src scheme :tangle (meta-in-dir "channels-lock")
(list (channel
       (name 'guix)
       (url "https://git.savannah.gnu.org/git/guix.git")
       (branch "master")
       (commit
        "4c03f62ad04c2cbbfc7ed61c97b0ecf897383706")
       (introduction
        (make-channel-introduction
         "9edb3f66fd807b096b48283debdcddccfea34bad"
         (openpgp-fingerprint
          "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA"))))
      (channel
       (name 'phrenetic)
       (url "https://github.com/pharcosyle/phrenetic")
       (branch "tangled")
       (commit
        "bbc78abdfee8daf0e43b4348b7452ffe9340fb5c")))
#+end_src
**** COMMENT From project channel (local)
#+begin_src scheme :tangle (meta-in-dir "channels-lock")
(list (channel
       (name 'guix)
       (url "https://git.savannah.gnu.org/git/guix.git")
       (branch "master")
       (commit
        "4c03f62ad04c2cbbfc7ed61c97b0ecf897383706")
       (introduction
        (make-channel-introduction
         "9edb3f66fd807b096b48283debdcddccfea34bad"
         (openpgp-fingerprint
          "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA"))))
      (channel
       (name 'phrenetic)
       (url "file:///home/pharcosyle/work/phrenetic")
       (branch "tangled")
       (commit
        "bbc78abdfee8daf0e43b4348b7452ffe9340fb5c")))
#+end_src
** Operating systems
#+begin_src scheme :tangle (meta-in-dir "os.scm")
(define-module (exuberant os)
  #:use-module (ebullient system components)
  #:use-module (ebullient utils)
  #:export (os-base
            with-host-info
            with-bootloader
            with-filesystems
            with-macbook-hardware
            boot-label
            efi-boot-target
            root-label
            btrfs-mount-flags
            btrfs-mount-options
            luks-label
            stateless-mountables
            stateless-persist-dir
            stateless-machine-dir))

(define* (os-base os
                  #:key
                  stateless?
                  source?
                  source-path
                  users-info
                  nix?
                  console?
                  kmonad?
                  kmonad-users
                  desktop?
                  pipewire?
                  bluetooth?
                  bluetooth-users
                  gdm?
                  gdm-auto-login
                  sessions)
  (-> os
      (as-> $
        (if source?
            (source $ #:path source-path) $))
      base-services
      nss
      (accounts #:users-info users-info)
      nonguix-substitutes
      linux-nonfree
      (as-> $
        (if nix?
            (nix $) $)
        (if console?
            (-> $
                hidpi-console-font
                (as-> $
                  (if kmonad?
                      (kmonad-tool $ #:who kmonad-users) $)))
            $)
        (if desktop?
            (-> $
                desktop-services
                (as-> $
                  (if pipewire?
                      (pipewire-multimedia $) $)
                  (network-manager $ #:stateless? stateless?)
                  (if bluetooth?
                      (bluetooth $ #:who bluetooth-users
                                 #:stateless? stateless?)
                      $)
                  (if gdm?
                      (gdm $ #:auto-login gdm-auto-login))
                  (if (member #:session/gnome (or sessions '()))
                      (gnome-desktop $) $)
                  (if (member #:session/sway (or sessions '()))
                      (sway-wm $) $)))
            $))))

(define with-host-info host-info)

(define* (with-bootloader os
                          #:key
                          efi?
                          boot-label
                          boot-target)
  ((if efi?
       grub-efi
       ;; grub
       )
   os
   #:label boot-label
   #:target boot-target))

(define* (with-filesystems os
                           #:key
                           filesystem
                           root-label
                           mountables
                           btrfs-mount-flags
                           btrfs-mount-options
                           disk-encryption?
                           luks-label
                           luks-uuid
                           stateless?
                           stateless-persist-dir
                           stateless-machine-dir
                           stateless-users)
  (as-> os $
    (case filesystem
      ;; ((#:filesystem/ext4)
      ;;  (ext4 $ #:label root-label))
      ((#:filesystem/btrfs)
       (btrfs $ #:label root-label
              #:subvols mountables
              #:flags btrfs-mount-flags
              #:options btrfs-mount-options)))
    (if disk-encryption?
        (disk-encryption $ #:label luks-label
                         #:source-uuid luks-uuid
                         #:encrypted-mount-points (case filesystem
                                                    ;; ((#:filesystem/ext4)
                                                    ;;  ...)
                                                    ((#:filesystem/btrfs)
                                                     (map cdr mountables))))
        $)
    (if stateless?
        (stateless $ #:persist-dir stateless-persist-dir
                   #:machine-dir stateless-machine-dir
                   #:who stateless-users)
        $)))

(define* (with-macbook-hardware os #:key bluetooth?)
  (-> os
      (console-keyboard-layouts #:kb-layout macbook-kb-layout)
      (macbook #:bluetooth? bluetooth?)))


(define boot-label "genesis")
(define efi-boot-target "/boot/efi")
(define root-label "firmament")
(define btrfs-mount-flags '(no-atime))
(define btrfs-mount-options '("compress=zstd" "autodefrag"))
(define luks-label "ciphered")
(define* (stateless-mountables #:key persist-dir machine-dir nix?)
  (append
   `(("boot" . "/boot")
     ("guix-store" . "/gnu/store")
     ("guix-var" . "/var/guix")
     ("persist" . ,persist-dir)
     ("machine" . ,machine-dir))
   (if nix?
       '(("nix" . "/nix")) '())))
(define stateless-persist-dir "/.persist")
(define stateless-machine-dir "/.machine")
#+end_src
** Home environments
#+begin_src scheme :tangle (meta-in-dir "he.scm")
(define-module (exuberant he)
  #:use-module (ebullient home components)
  #:export (he-base))

(define* (he-base #:key
                  email
                  stateless?
                  stateless-persist-dir
                  stateless-machine-dir
                  (login-shell #:shell/bash)
                  developer?
                  (interactive-shell (if developer?
                                         #:shell/zsh login-shell))
                  nix?
                  console?
                  kmonad?
                  desktop?
                  pipewire?
                  gdm?
                  sessions)
  (let ((theme #:theme/dark)
        (font-mono font-mono)
        (font-sans font-sans)
        (font-serif font-serif)
        (font-unicode font-unicode)
        (font-variable-pitch font-sans))
    (append
     (he-packages)
     (if stateless?
         (he-stateless #:persist-dir stateless-persist-dir
                       #:machine-dir stateless-machine-dir)
         '())
     (he-shells #:stateless? stateless?
                #:login-shell login-shell
                #:interactive-shell interactive-shell)
     (if nix?
         (he-nix #:stateless? stateless?) '())
     (if developer?
         (append
          (he-emacs #:zsh-vterm? (eq? interactive-shell #:shell/zsh))
          (he-doom #:stateless? stateless?
                   #:console? console?
                   #:email email
                   #:theme theme
                   #:font font-mono
                   #:font-variable-pitch font-variable-pitch
                   #:font-unicode font-unicode
                   #:font-serif font-serif)
          (he-git #:email email)
          (he-ssh)
          (he-direnv #:stateless? stateless?
                     #:shell interactive-shell))
         '())
     (if console?
         (append
          (he-fonts #:stateless? stateless?
                    #:fonts (list font-mono
                                  font-sans
                                  font-serif
                                  font-unicode))
          (if kmonad?
              (he-kmonad) '()))
         '())
     (if desktop?
         (append
          (he-mesa #:stateless? stateless?)
          (if gdm?
              (he-gdm #:stateless? stateless?) '())
          (let ((wayland? #t)
                (sway? (member #:session/sway (or sessions '()))))
            (append
             (he-desktop-packages)
             (he-xdg #:stateless? stateless?)
             (he-gtk #:stateless? stateless?
                     #:theme theme
                     #:font font-variable-pitch
                     #:font-monospace font-mono)
             (if pipewire?
                 (he-pipewire #:stateless? stateless?
                              #:sway? sway?)
                 '())
             (he-flatpak #:stateless? stateless?
                         #:wayland? wayland?)
             (if sway?
                 (let ((screen-locker (swaylock-screen-locker)))
                   (append
                    (he-wm-common #:sway? #t)
                    (he-sway #:pipewire? pipewire?
                             #:kb-layout ((@ (gnu system keyboard) keyboard-layout) "us" #:model "macbook78")
                             #:screen-locker screen-locker
                             #:idle-manager (swayidle-idle-manager)
                             #:application-launcher (rofi-application-launcher #:wayland? #t)
                             #:default-terminal (alacritty-terminal))
                    (he-swaylock #:font font-variable-pitch)
                    (he-swayidle #:sway? #t
                                 #:screen-locker screen-locker)
                    (he-mako #:sway? #t
                             #:menu (rofi-menu #:wayland? #t)
                             #:theme theme
                             #:font font-variable-pitch)
                    (he-waybar #:sway? #t
                               #:theme theme
                               #:font font-variable-pitch)
                    (he-rofi #:stateless? stateless?
                             #:wayland? #t
                             #:theme theme)
                    (he-alacritty #:font font-mono)))
                 '()))))
         '()))))
#+end_src
* Channel
#+begin_src scheme :tangle (meta-in-dir ".guix-channel")
(channel
 (version 0)
 (dependencies
  (channel
   (name flat)
   (url "https://github.com/flatwhatson/guix-channel.git")
   (introduction
    (make-channel-introduction
     "33f86a4b48205c0dc19d7c036c85393f0766f806"
     (openpgp-fingerprint
      "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490"))))
  (channel
   (name rde)
   (url "https://git.sr.ht/~abcdw/rde")
   (introduction
    (make-channel-introduction
     "257cebd587b66e4d865b3537a9a88cccd7107c95"
     (openpgp-fingerprint
      "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
  (channel
   (name nonguix)
   (url "https://gitlab.com/nonguix/nonguix")
   (introduction
    (make-channel-introduction
     "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
     (openpgp-fingerprint
      "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))))
#+end_src
* Dev
** Git config
#+begin_src gitconfig :tangle (meta-in-dir ".git/config")
[branch "master"]
	remote = origin
	merge = refs/heads/master

[branch "tangled"]
	remote = origin
	merge = refs/heads/tangled
#+end_src
** Git ignore
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
/*

!/ebullient/
/ebullient/*
!/ebullient/home/
/ebullient/home/*
!ebullient/home/alucard_bg.png
#+end_src
** Github
*** Git config
#+begin_src gitconfig :tangle (meta-in-dir ".git/config")
[remote "origin"]
	url = https://github.com/pharcosyle/phrenetic.git
	fetch = +refs/heads/*:refs/remotes/origin/*
#+end_src
*** Readme
#+begin_src org :tangle (meta-in-dir "README.org")
,* Phrenetic
A configuration framework and collection of useful packages/services for [[https://guix.gnu.org/][GNU Guix]].

It's decent.
,* [[file:phrenetic.org][Browse the full source]]
,* Usage
Install as a [[https://guix.gnu.org/manual/devel/en/guix.html#Channels][Guix channel]] with the following declaration:
,#+begin_src scheme
(channel
 (name 'phrenetic)
 (url "https://github.com/pharcosyle/phrenetic")
 (branch "tangled"))
,#+end_src
,* Noteworthy features
Some stuff I haven't seen elsewhere folks might be interested in:
- Stateless service :: Configure your Guix to run with an ephemeral, in-memory root directory. Kind of like [[https://grahamc.com/blog/erase-your-darlings][Erase your darlings: immutable infrastructure for mutable systems]] but using Guix/Btrfs instead of NixOS/ZFS.
- Doom package and module :: [[https://github.com/doomemacs/doomemacs][Doom Emacs]] packaged for Guix and with patches to better organize Emacs state, a service to set up symlinks, etc.
- Guix integration for [[https://github.com/radian-software/straight.el][Straight.el]] :: Your Straight or Doom-based Emacs configuration can use Guix Emacs packages under hood (but with the revisions you, or Doom, specify). Get the best of both worlds! Still WIP.
- Miscellaneous packages :: Guix packages for stuff not upstream yet: Datomic CLI tools, the AWS CLI v2, etc.
,* A word about literate programming
I use Emacs' =org-mode= to structure my code as a single file that I can export ("tangle") into numerous source files. This allows me to annotate and organize related code in potentially different languages with different output paths together in a way that easy for humans to read and reason about. This does necessitate maintaining a separate =tangled= branch (set as the Github default) so others can use it easily, though.
,* Contributing
Pull requests welcome! Targeting =master= is ideal but if you aren't familiar with literate programming / Emacs / =org=mode= then making your changes on the =tangled= branch is also fine (I'll reverse-tangle it for you).
,* Acknowledgements
This project incorporates code from Andrew Tropin's excellent [[https://github.com/abcdw/rde][RDE]], many thanks to him.
#+end_src
*** License
#+begin_src fundamental :tangle (meta-in-dir "LICENSE")
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
#+end_src
* Dev local
** Git config
The default git config on my Guix system.
#+begin_src gitconfig :tangle (meta-in-dir ".git/config")
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
#+end_src
** Emacs directory-local variables
- TODO Causes gesier to fail to load outside of this directory
  *don't do this until I figure out how I'm doing per-project Emcas config* I might not end up doing Geiser setup this way at all.
  Since the ~with-eval-after-load~ body will get called wherever geiser-guile is first loaded, if the geiser library isn't loaded yet and I e.g. visit a file in this directory, then leave, then try to =M-x guix p e= while I'm viewing a file elsewhere it'll fail to run since it loads geiser internally and can't find a dominating .dir-locals.
  - an alternative approach to setting up geiser for a project: [[https://github.com/guix-mirror/guix/blob/master/.dir-locals.el#L21][guix/.dir-locals.el at master  guix-mirror/guix  GitHub]]
    Maybe try that or something like it.
    - here's where I got the original approach, for reference: [[https://github.com/flatwhatson/flycheck-guile#troubleshooting][GitHub - flatwhatson/flycheck-guile: A Flycheck checker for GNU Guile]]
      - update [2022-08-31 Wed]: the .dir-locals approach isn't recommended any more?: https://github.com/flatwhatson/flycheck-guile/commit/e58ceb8b511cd395b9be69f4a1ff85305fbb51c3
  - update [2022-03-26 Sat]: this won't work as-is any more
    I have multiple directories to load (ebullient, exuberant...)
#+begin_src elisp :tangle (meta-in-dir ".dir-locals.el")
((nil
  (eval . (with-eval-after-load 'geiser-guile
            (let ((root-dir
                   (file-name-directory
                    (locate-dominating-file default-directory ".dir-locals.el"))))
              (make-local-variable 'geiser-guile-load-path)
              (add-to-list 'geiser-guile-load-path root-dir))))))
#+end_src
