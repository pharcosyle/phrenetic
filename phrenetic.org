#+TITLE: Phrenetic
#+PROPERTY: header-args :mkdirp yes

* Table of Contents :TOC:
- [[#install][Install]]
  - [[#program][Program]]
  - [[#package][Package]]
- [[#system][System]]
  - [[#create][Create]]
  - [[#components][Components]]
  - [[#templates][Templates]]
- [[#home][Home]]
  - [[#create-1][Create]]
  - [[#components-1][Components]]
  - [[#templates-1][Templates]]
- [[#common][Common]]
  - [[#packages][Packages]]
  - [[#stateless][Stateless]]
- [[#utils][Utils]]
  - [[#branching][Branching]]
  - [[#threading][Threading]]
  - [[#alists][Alists]]
  - [[#guix][Guix]]
- [[#configurations][Configurations]]
  - [[#frostfire][Frostfire]]
- [[#guix-channel][Guix channel]]
- [[#github][Github]]
  - [[#readme][Readme]]
  - [[#license][License]]
- [[#dev][Dev]]
  - [[#git-ignore][Git ignore]]

* Install
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "phrenetic/install.scm")
:END:
Run with ~sudo~.
#+begin_src scheme
(define-module (phrenetic install)
  #:use-module (guix build-system trivial)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((gnu packages cryptsetup) #:select (cryptsetup))
  #:use-module ((gnu packages disk) #:select (dosfstools parted))
  #:use-module ((gnu packages linux) #:select (btrfs-progs util-linux+udev))
  #:use-module ((gnu packages package-management) #:select (guix))
  #:use-module (phrenetic utils)
  #:export (installer-package))
#+end_src
** Program
#+begin_src scheme
(define* (installer-program #:key
                            os-name
                            efi?
                            boot-label
                            boot-target
                            root-label
                            disk-encryption?
                            luks-label
                            filesystem
                            mountables
                            btrfs-mount-flags
                            btrfs-mount-options)
  (program-file
   "installer"
   (with-imported-modules '((guix build utils))
     #~(begin
         (use-modules ((guix build utils) #:select (invoke mkdir-p))
                      ((ice-9 match) #:select (match-lambda))
                      ((ice-9 readline) #:select (readline))
                      ((ice-9 string-fun) #:select (string-replace-substring)))

         (define* (cmd command #:rest args)
           (display (string-join (cons (basename command) args) " "))
           (newline)
           (apply invoke (cons command args)))

         (define* (read-user-input prompt #:key default)
           (let ((input (readline (string-append prompt
                                                 (if default
                                                     (string-append " (default " default ")") "")
                                                 ": "))))
             (if (string-null? input)
                 (or default (exit))
                 input)))

         (define (user-pause text)
           (readline (string-append text " Press enter to continue.")))

         (define (display-block-devices)
           (display "Block devices:")
           (newline)
           (invoke #$(file-append util-linux+udev "/bin/lsblk"))
           (newline))

         (display-block-devices)
         (define device
           (read-user-input "Enter device (for exmple, /dev/sda)"))

         (let ((parted-bin #$(file-append parted "/sbin/parted"))
               (align "optimal")
               (boot-size "1GB"))
           (cmd parted-bin device "mklabel" "gpt")
           (for-each (match-lambda
                       ((label start end)
                        (cmd parted-bin "--align" align device "mkpart" label start end)))
                     `(("sky" "0%" ,boot-size)
                       ("earth" ,boot-size "100%")))
           (cmd parted-bin device "set" "1" (if #$efi? "esp" "bios_grub") "on")
           (for-each (lambda (n)
                       (cmd parted-bin device "align-check" align n))
                     '("1" "2")))
         (user-pause "Check that disks are aligned.")

         (display-block-devices)
         (define boot-partition
           (read-user-input (string-append "Boot partition")
                            #:default (string-append device "1")))
         (define root-partition
           (read-user-input (string-append "Root partition")
                            #:default (string-append device "2")))

         (cmd #$(file-append dosfstools "/sbin/mkfs.fat") "-F" "32" "-n" #$boot-label boot-partition)

         (define system-root
           (if #$disk-encryption?
               (let* ((crypt-name "deciphered-new")
                      (crypt-mapping (string-append "/dev/mapper/" crypt-name))
                      (cryptsetup-bin #$(file-append cryptsetup "/bin/cryptsetup")))
                 (cmd cryptsetup-bin "luksFormat" "--type" "luks2" "--pbkdf" "pbkdf2" "--label" #$luks-label root-partition)
                 (cmd cryptsetup-bin "open" root-partition crypt-name)
                 crypt-mapping)
               root-partition))

         (case #$filesystem
           ;; ((#:filesystem/ext4)
           ;;  (cmd #$(file-append e2fsprogs "/sbin/mkfs.ext4") "-L" #$root-label system-root))
           ((#:filesystem/btrfs)
            (cmd #$(file-append btrfs-progs "/bin/mkfs.btrfs") "--label" #$root-label system-root)))

         (define mount-dir
           (read-user-input (string-append "Mount directory")
                            #:default "/mnt"))

         (define mount-bin "/run/setuid-programs/mount")
         (define umount-bin "/run/setuid-programs/umount")

         (when (equal? #$filesystem #:filesystem/btrfs)
           (let ((btrfs-bin #$(file-append btrfs-progs "/bin/btrfs")))
             (cmd mount-bin system-root mount-dir)
             (for-each (lambda (subvol)
                         (cmd btrfs-bin "subvolume" "create" (string-append mount-dir "/" subvol)))
                       (map car '#$mountables))
             (cmd umount-bin mount-dir)))

         (case #$filesystem
           ;; ((#:filesystem/ext4)
           ;;  (cmd mount-bin system-root mount-dir))
           ((#:filesystem/btrfs)
            (for-each
             (match-lambda
               ((subvol . mount-point)
                (let ((path-on-mount (string-append mount-dir mount-point)))
                  (mkdir-p path-on-mount)
                  (cmd mount-bin "-o"
                       (string-append
                        "subvol=" subvol
                        (let ((opts (append
                                     (or '#$btrfs-mount-options '())
                                     (map (lambda (flag)
                                            (string-replace-substring (symbol->string flag) "-" ""))
                                          (or '#$btrfs-mount-flags '())))))
                          (if (null? opts)
                              ""
                              (string-append "," (string-join opts ",")))))
                       system-root path-on-mount))))
             '#$mountables)))
         (let ((boot-target-on-mount (string-append mount-dir #$boot-target)))
           (mkdir-p boot-target-on-mount)
           (cmd mount-bin boot-partition boot-target-on-mount))

         (let ((source-dir "/etc/config-source")
               (configs-dir "phrenetic/configs"))
           (cmd #$(file-append guix "/bin/guix") "time-machine"
                (string-append "--channels=" source-dir "/" configs-dir "/" os-name "-channels-lock")
                "--"
                "system"
                (string-append "--load-path=" source-dir)
                "init"
                (string-append source-dir "/" configs-dir "/" #$os-name)
                mount-dir))

         (cmd umount-bin (string-append mount-dir #$boot-target))
         (case #$filesystem
           ;; ((#:filesystem/ext4)
           ;;  (cmd umount-bin mount-dir))
           ((#:filesystem/btrfs)
            (for-each
             (lambda (mount-point)
               (cmd umount-bin (string-append mount-dir mount-point)))
             (map cdr '#$mountables))))))))
#+end_src
** Package
#+begin_src scheme
(define* (installer-package #:rest opts)
  (package
    (inherit blank-package)
    (name "installer")
    (source (apply installer-program opts))
    (build-system trivial-build-system)
    (arguments
     `(#:builder
       ,#~(begin
            (let* ((bin (string-append #$output "/bin")))
              (mkdir #$output)
              (mkdir bin)
              (symlink #$source (string-append bin "/install"))))))))
#+end_src
* System
:PROPERTIES:
:meta-dir+: /phrenetic
:header-args+: :tangle (meta-in-dir "system.scm")
:END:
#+begin_src scheme
(define-module (phrenetic system)
  #:use-module ((guix hash) #:select (vcs-file?))
  #:use-module ((guix modules) #:select (source-module-closure))
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((guix store) #:select (%default-substitute-urls))
  #:use-module (gnu bootloader)
  #:use-module (gnu bootloader grub)
  #:use-module ((gnu packages base) #:select (coreutils))
  #:use-module ((gnu packages certs) #:select (nss-certs))
  #:use-module ((gnu packages fonts) #:select (font-terminus))
  #:use-module ((gnu packages gnome) #:select (network-manager-applet))
  #:use-module ((gnu packages gnupg) #:select (guile-gcrypt))
  #:use-module ((gnu packages linux) #:select (brightnessctl e2fsprogs kbd pipewire-0.3 util-linux+udev))
  #:use-module ((gnu packages wm) #:select (swaylock-effects))
  #:use-module (gnu services)
  #:use-module (gnu services base)
  #:use-module (gnu services desktop)
  #:use-module ((gnu services linux) #:select (kernel-module-loader-service-type))
  #:use-module ((gnu services networking) #:select (network-manager-service-type wpa-supplicant-service-type))
  #:use-module ((gnu services nix) #:select (nix-service-type))
  #:use-module (gnu services shepherd)
  #:use-module ((gnu services sound) #:select (alsa-service-type pulseaudio-service-type))
  #:use-module ((gnu services xorg) #:select (gdm-service-type screen-locker-service screen-locker-service-type))
  #:use-module (gnu system)
  #:use-module (gnu system accounts)
  #:use-module (gnu system file-systems)
  #:use-module (gnu system keyboard)
  #:use-module (gnu system mapped-devices)
  #:use-module ((nongnu packages linux) #:select (linux linux-firmware broadcom-sta broadcom-bt-firmware))
  #:use-module ((nongnu system linux-initrd) #:select (microcode-initrd))
  #:use-module ((phrenetic packages facetimehd) #:select (facetimehd))
  #:use-module ((phrenetic packages facetimehd-firmware) #:select (facetimehd-firmware))
  #:use-module ((phrenetic packages haskell-apps) #:select (kmonad))
  #:use-module ((phrenetic stateless) #:prefix stateless:)
  #:use-module (phrenetic utils)
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:use-module ((ice-9 rdelim) #:select (read-string))
  #:use-module ((srfi srfi-1) #:select (any remove iota))
  #:export (blank-os
            source
            base-services
            nss
            linux-nonfree
            accounts
            guix-pm
            nix-pm
            console-fonts
            kmonad-tool
            desktop-services
            pipewire-multimedia
            network-manager
            bluetooth
            gdm
            desktop-tty
            gnome-desktop
            sway-wm
            host-info
            boot-label
            grub-efi
            efi-boot-target
            root-label
            ;; ext4
            btrfs
            btrfs-mount-flags
            btrfs-mount-options
            disk-encryption
            luks-label
            swap
            stateless
            stateless-persist-dir
            stateless-machine-dir
            stateless-mountables
            console-keyboard-layouts
            macbook
            macbook-kb-layout
            os-base
            with-host-info
            with-bootloader
            with-filesystems
            with-macbook-hardware))

;; Not exported. Probably an oversight that'll get fixed at some point.
(define greetd-terminals (@@ (gnu services base) greetd-terminals))
(define greetd-terminal-vt (@@ (gnu services base) greetd-terminal-vt))
#+end_src
** Create
#+begin_src scheme
(define blank-os
  (operating-system
    (host-name #f)
    (timezone #f)
    (bootloader #f)
    (services '())
    (file-systems %base-file-systems)))
#+end_src
** Components
#+begin_src scheme
(define-syntax-rule (system-comp os field ...)
  (operating-system
    (inherit os)
    field ...))

(define-syntax define-system-comp
  (lambda (x)
    (syntax-case x ()
      ((_ (name arg ...) field ...)
       (with-syntax ((os (datum->syntax x 'os)))
         #'(define* (name os arg ...)
             (system-comp os field ...)))))))

(define (remove-services services kinds)
  (remove (lambda (s)
            (member (service-kind s) kinds))
          services))
#+end_src
*** Source
#+begin_src scheme
(define-system-comp (source #:key path)
  (services
   (append
    (operating-system-user-services os)
    (list
     (simple-service
      'config-source
      etc-service-type
      `(("config-source" ,(local-file
                           path
                           #:recursive? #t
                           #:select? (negate vcs-file?)))))))))
#+end_src
*** Base services
#+begin_src scheme
(define-system-comp (base-services #:key number-of-ttys)
  (services
   (append
    (operating-system-user-services os)
    (as-> %base-services $
      (remove-services $ (list login-service-type
                               agetty-service-type
                               mingetty-service-type
                               console-font-service-type))
      (cons* (service greetd-service-type
                      (greetd-configuration
                       (terminals
                        (map (lambda (n)
                               (greetd-terminal-configuration
                                (terminal-vt (number->string n))))
                             (iota number-of-ttys 1)))))
             $)))))
#+end_src
*** NSS
#+begin_src scheme
(define-system-comp (nss)
  (packages
   (cons* nss-certs
          (operating-system-packages os))))
#+end_src
*** Linux nonfree
#+begin_src scheme
(define-system-comp (linux-nonfree)
  (kernel linux)
  (initrd microcode-initrd)
  (firmware (cons* linux-firmware
                   (operating-system-firmware os))))
#+end_src
*** Accounts
#+begin_src scheme
(define-system-comp (accounts #:key users-info)
  (users
   (append
    (operating-system-users os)
    (map (lambda (user-info)
           (apply account (alist->list user-info)))
         users-info))))

(define* (account #:key
                  name
                  comment
                  ;; shell
                  admin?
                  password
                  salt)
  (user-account
   (name name)
   (comment (or comment ""))
   (group "users")
   (supplementary-groups (append '("netdev" "audio" "video")
                                 (if admin? '("wheel") '())))
   ;; (shell (case shell
   ;;          ((#:shell/bash) ...)
   ;;          ((#:shell/zsh) ...)))
   (password (if password
                 (crypt password (or salt "toosimple"))
                 #f))))
#+end_src
*** Package management
**** Guix
#+begin_src scheme
(define-system-comp (guix-pm #:key stateless?)
  (services
   (append
    (operating-system-user-services os)
    (if stateless?
        (list
         (stateless-service
          'guix
          #:state '(((#:path . "/etc/guix/signing-key.pub")
                     (#:store . #:machine)
                     (#:parent-dir-perms . ((#:mode . #o111))))
                    ((#:path . "/etc/guix/signing-key.sec")
                     (#:store . #:machine)
                     (#:parent-dir-perms . ((#:mode . #o111)))))))
        '())
    (list (nonguix-substitutes)))))
#+end_src
***** Nonguix substitutes
#+begin_src scheme
(define (nonguix-substitutes)
  (simple-service
   'nonguix-substitutes
   guix-service-type
   (guix-extension
    (authorized-keys
     (list (local-file "substitutes.nonguix.org.pub")))
    (substitute-urls
     (list "https://substitutes.nonguix.org")))))
#+end_src
****** Signing key
#+begin_src scheme :tangle (meta-in-dir "substitutes.nonguix.org.pub")
(public-key
 (ecc
  (curve Ed25519)
  (q #C1FD53E5D4CE971933EC50C9F307AE2171A2D3B52C804642A7A35F84F3A4EA98#)))
#+end_src
**** Nix
#+begin_src scheme
(define-system-comp (nix-pm)
  (services
   (cons* (service nix-service-type)
          (operating-system-user-services os))))
#+end_src
*** Console
**** Fonts
#+begin_src scheme
(define-system-comp (console-fonts #:key
                                   number-of-ttys
                                   (hidpi? #t))
  (services
   (cons* (service console-font-service-type
                   (map (lambda (n)
                          (cons (string-append "tty" (number->string n))
                                (if hidpi?
                                    (file-append font-terminus "/share/consolefonts/ter-132n")
                                    %default-console-font)))
                        (iota number-of-ttys 1)))
          (operating-system-user-services os))))
#+end_src
**** KMonad
Must succeed [[*Accounts][Accounts]] component.
#+begin_src scheme
(define-system-comp (kmonad-tool #:key who)
  (packages
   (cons* kmonad
          (operating-system-packages os)))
  (users
   (map (lambda (account)
          (if (member (user-account-name account) who)
              (user-account
               (inherit account)
               (supplementary-groups (append (user-account-supplementary-groups account)
                                             '("input"))))
              account))
        (operating-system-users os)))
  (services
   (cons* (udev-rules-service 'kmonad-add-udev-rules kmonad)
          (operating-system-user-services os))))
#+end_src
*** Desktop
**** Desktop services
#+begin_src scheme
(define-system-comp (desktop-services)
  (services
   (append
    (operating-system-user-services os)
    (remove-services
     %desktop-services
     (append
      (map service-kind %base-services)
      (list screen-locker-service-type
            network-manager-service-type
            wpa-supplicant-service-type
            (service-kind
             (simple-service 'network-manager-applet
                             profile-service-type
                             (list network-manager-applet)))
            gdm-service-type
            (service-kind gdm-file-system-service)
            pulseaudio-service-type
            alsa-service-type))))))
#+end_src
**** Multimedia
***** PulseAudio and ALSA
#+begin_src scheme
(define-system-comp (pulseaudio+alsa)
  (services
   (append
    (operating-system-user-services os)
    (list pulseaudio-service-type
          alsa-service-type))))
#+end_src
***** Pipewire
#+begin_src scheme
(define-system-comp (pipewire-multimedia)
  (services
   (cons* (udev-rules-service 'pipewire-add-udev-rules
                              pipewire-0.3)
          (operating-system-user-services os))))
#+end_src
**** Network
***** Network manager
#+begin_src scheme
(define-system-comp (network-manager #:key stateless?)
  (services
   (append
    (operating-system-user-services os)
    (list
     (service network-manager-service-type)
     (service wpa-supplicant-service-type))
    (if stateless?
        (list
         (stateless-service
          'network-manager
          #:state '(((#:path . "/etc/NetworkManager/system-connections/")
                     (#:store . #:machine))
                    ((#:path . "/var/lib/NetworkManager/secret_key")
                     (#:store . #:machine)
                     (#:parent-dir-perms . ((#:mode . #o700)))))))
        '()))))
#+end_src
**** Bluetooth
#+begin_src scheme
(define-system-comp (bluetooth #:key
                               who
                               stateless?)
  (users
   (map (lambda (account)
          (if (member (user-account-name account) who)
              (user-account
               (inherit account)
               (supplementary-groups (append (user-account-supplementary-groups account)
                                             '("lp"))))
              account))
        (operating-system-users os)))
  (services
   (append
    (operating-system-user-services os)
    (list
     (bluetooth-service #:auto-enable? #t))
    (if stateless?
        (list
         (stateless-service
          'bluetooth
          #:state '(((#:path . "/var/lib/bluetooth/")
                     (#:store . #:machine)
                     (#:mode . #o700)))))
        '()))))
#+end_src
**** Login management
***** Login managers
****** GDM
#+begin_src scheme
(define-system-comp (gdm #:key
                         (wayland? #t)
                         auto-login?
                         auto-login-user)
  (services
   (append
    (operating-system-user-services os)
    (list
     (service gdm-service-type
              (gdm-configuration
               (auto-login? auto-login?)
               (default-user auto-login-user)
               (wayland? wayland?)))
     gdm-file-system-service))))
#+end_src
***** Desktop TTY
#+begin_src scheme
(define-system-comp (desktop-tty #:key
                                 (tty-number 2)
                                 auto-login?
                                 auto-login-user)
  (services
   (cons* (switch-to-tty-service #:tty-number tty-number)
          (let ((services (operating-system-user-services os)))
            (if auto-login?
                (with-auto-login-to-tty services
                                        #:tty-number tty-number
                                        #:user auto-login-user)
                services)))))

(define* (switch-to-tty-service #:key tty-number)
  (simple-service
   'switch-to-tty
   shepherd-root-service-type
   (list
    (shepherd-service
     (provision '(switch-to-tty))
     (requirement '(virtual-terminal))
     (one-shot? #t)
     (start #~(lambda ()
                (invoke #$(file-append kbd "/bin/chvt")
                        #$(number->string tty-number))))))))

(define* (with-auto-login-to-tty services #:key tty-number user)
  (modify-services services
    (greetd-service-type
     config =>
     (greetd-configuration
      (inherit config)
      (terminals
       (map (lambda (terminal-config)
              (if (equal? (greetd-terminal-vt terminal-config)
                          (number->string tty-number))
                  ;; It'd be better to set user/command for initial-session rather than default-session (auto-login would only occur on the first start) but the Guix configuration doesn't have that option (yet?).
                  (greetd-terminal-configuration
                   (inherit terminal-config)
                   (default-session-user user)
                   (default-session-command "default-session-start"))
                  terminal-config))
            (greetd-terminals config)))))))
#+end_src
**** Sessions
***** Desktop environments
****** GNOME
#+begin_src scheme
(define-system-comp (gnome-desktop)
  (services
   (cons* (service gnome-desktop-without-package-service-type)
          (operating-system-user-services os))))

(define gnome-desktop-without-package-service-type
  (let ((base gnome-desktop-service-type))
    (service-type
     (inherit base)
     (extensions
      (remove (lambda (ext)
                (equal? (service-extension-target ext) profile-service-type))
              (service-type-extensions base))))))
#+end_src
***** Window managers
****** Sway
#+begin_src scheme
(define-system-comp (sway-wm)
  (services
   (append (operating-system-user-services os)
           (list swaylock-service
                 brightnessctl-udev-rules))))
#+end_src
***** Screen lockers
****** Swaylock
#+begin_src scheme
(define swaylock-service
  (screen-locker-service swaylock-effects "swaylock"))
#+end_src
***** Backlight
****** Brightnessctl
#+begin_src scheme
(define brightnessctl-udev-rules
  (udev-rules-service 'brightnessctl-add-udev-rules brightnessctl))
#+end_src
*** Device-specific
**** Host
#+begin_src scheme
(define-system-comp (host-info #:key
                               host-name
                               timezone
                               locale)
  (host-name host-name)
  (timezone timezone)
  (locale (or locale "en_US.utf8")))
#+end_src
**** File systems and boot
***** Bootloader
#+begin_src scheme
(define boot-label "genesis")
#+end_src
****** Grub
#+begin_src scheme
;; ...
#+end_src
****** Grub EFI
#+begin_src scheme
(define-system-comp (grub-efi #:key
                              label
                              target)
  (bootloader (bootloader-configuration
               (bootloader grub-efi-bootloader)
               (targets (list target))
               (timeout 1)))
  (file-systems
   (cons* (file-system
            (device (file-system-label label))
            (mount-point target)
            (type "vfat"))
          (operating-system-file-systems os))))

(define efi-boot-target "/boot/efi")
#+end_src
***** File systems
#+begin_src scheme
(define root-label "firmament")
#+end_src
****** Ext4
#+begin_src scheme
;; (define-system-comp (ext4 #:key label)
;;   (file-systems
;;    (cons* (file-system
;;             (device (file-system-label label))
;;             (mount-point "/")
;;             (type "ext4"))
;;           (operating-system-file-systems os))))
#+end_src
****** Btrfs
#+begin_src scheme
(define-system-comp (btrfs #:key
                           label
                           subvols
                           flags
                           options)
  (file-systems
   (append
    (map (match-lambda
           ((subvol . mount-point)
            (file-system
              (device (file-system-label label))
              (mount-point mount-point)
              (type "btrfs")
              (flags (or flags '()))
              (options (string-append
                        "subvol=" subvol
                        (if options
                            (string-append "," (string-join options ","))
                            ""))))))
         subvols)
    (operating-system-file-systems os))))

(define btrfs-mount-flags '(no-atime))
(define btrfs-mount-options '("compress=zstd" "autodefrag"))
#+end_src
***** Disk encryption
Must succeed [[*File systems][File systems]] component.
#+begin_src scheme
(define* (disk-encryption os
                          #:key
                          label
                          (target "deciphered")
                          mount-points)
  (let ((encrypted-device (mapped-device
                           ;; (source label)
                           (source (uuid "bdda56af-6ca0-4953-bc13-d5af8715e0e5"))
                           (targets (list target))
                           (type luks-device-mapping))))
    (system-comp
     os
     (mapped-devices
      (cons* encrypted-device
             (operating-system-mapped-devices os)))
     (file-systems
      (map (lambda (fs)
             (if (member (file-system-mount-point fs) mount-points)
                 (file-system
                   (inherit fs)
                   (dependencies (cons* encrypted-device
                                        (file-system-dependencies fs))))
                 fs))
           (operating-system-file-systems os))))))

(define luks-label "ciphered")
#+end_src
***** Swap
No ~swap-space-dependencies~ are required as long as the file system on which the swap file resides is ~needed-for-boot?~ (indeed, adding them triggers a build error since no Shepherd service is created for such file systems).
#+begin_src scheme
(define* (swap os
               #:key
               stateless?
               stateless-machine-dir
               no-cow?)
  (let ((swapfile (string-append
                   (if stateless?
                       (string-append stateless-machine-dir "/")
                       "/")
                   ".swap")))
    (system-comp
     os
     (swap-devices
      (list
       (swap-space
        (target swapfile))))
     (services
      (append
       (operating-system-user-services os)
       (list
        (simple-service 'create-swapfile
                        activation-service-type
                        (create-swapfile-gexp swapfile no-cow?)))
       (if stateless?
           (list
            (stateless-service
             'swapfile
             #:ignore (list swapfile)))
           '()))))))

(define (create-swapfile-gexp swapfile no-cow?)
  (with-imported-modules '((guix build utils))
    #~(begin
        (use-modules ((guix build utils) #:select (invoke)))
        (when (not (file-exists? #$swapfile))
          (invoke #$(file-append coreutils "/bin/truncate") "--size" "0" #$swapfile)
          (when #$no-cow?
            (invoke #$(file-append e2fsprogs "/bin/chattr") "+C" #$swapfile))
          (invoke #$(file-append util-linux+udev "/bin/fallocate") "--length" "8G" #$swapfile)
          (chmod #$swapfile #o600)
          (invoke #$(file-append util-linux+udev "/sbin/mkswap") #$swapfile)))))
#+end_src
****** TODO [#E] Dynamically-determined swapfile size
/Otherwise/ make it an argument.
- At the very least I'll need it to be bigger if I want to try to get hibernation working again but not so big that I can't install to a USB stick.
- Make it 1.5x memory size if disk size allows.
***** Stateless
Must succeed [[*File systems][File systems]] and [[*Accounts][Accounts]] components. To be useful, the stateless service's activation must come before that of other services that create state (to this end the ~stateless-service-type~ is appended, not prepended, to operating system services) and including this component after /all/ others is the safest play.
#+begin_src scheme
(define* (stateless os
                    #:key
                    persist-dir
                    machine-dir
                    who
                    nix?)
  (as-> os $
    (system-comp
     $
     (file-systems
      (->> (operating-system-file-systems os)
           (cons* (file-system
                    (device ":/root") ; HACK Guix boot will hang forever waiting for a device to appear even though this is a tmpfs. Fake it out by using a name that looks like an NFS device (see `canonicalize-device-spec'). Thus the ":/" is necessary but the name is otherwise arbitrary.
                    (mount-point "/")
                    (type "tmpfs")
                    (check? #f)))
           (map (lambda (fs)
                  (if (member (file-system-mount-point fs)
                              `("/var/guix"
                                ,persist-dir
                                ,machine-dir))
                      (file-system
                        (inherit fs)
                        (needed-for-boot? #t))
                      fs)))))
     (users
      (map (lambda (account)
             (if (member (user-account-name account) (map car who))
                 (user-account
                  (inherit account)
                  (create-home-directory? #f))
                 account))
           (operating-system-users os)))
     (services
      (append
       (operating-system-user-services os)
       (list
        (service stateless-service-type
                 `(#:persist-dir ,persist-dir
                   #:machine-dir ,machine-dir
                   #:homes ,(->> users
                                 (filter (lambda (account)
                                           (member (user-account-name account) (map car who))))
                                 (map (lambda (account)
                                        `(,(user-account-name account) . ,(user-account-home-directory account)))))
                   #:hes ,who))
        (stateless-service
         'system
         #:state '(((#:path . "/etc/machine-id")
                    (#:store . #:machine))
                   ((#:path . "/var/lib/random-seed")
                    (#:store . #:machine)))
         #:ignore '("/var/log/"))))))

    (if nix?
        (stateless-nix $ #:machine-dir machine-dir) $)))

(define stateless-persist-dir "/.persist")
(define stateless-machine-dir "/.machine")

(define* (stateless-mountables #:key persist-dir machine-dir)
  `(("boot" . "/boot")
    ("guix-store" . "/gnu/store")
    ("guix-var" . "/var/guix")
    ("persist" . ,persist-dir)
    ("machine" . ,machine-dir)))
#+end_src
****** Service
******* Service type
#+begin_src scheme
(define stateless-service-type
  (service-type
   (name 'stateless)
   (extensions
    (list (service-extension boot-service-type
                             (lambda (config)
                               (populate-gexp (assoc-ref config #:machine-dir))))
          (service-extension activation-service-type
                             (lambda (config)
                               (stateless:activate-gexp
                                `',(assoc-ref config #:state)
                                ""
                                (assoc-ref config #:persist-dir)
                                (assoc-ref config #:machine-dir))))
          (service-extension shepherd-root-service-type
                             (lambda (config)
                               (cons* (user-homes-shepherd-service
                                       (assoc-ref config #:homes)
                                       (list
                                        (assoc-ref config #:persist-dir)
                                        (assoc-ref config #:machine-dir)))
                                      (activate-home-shepherd-services
                                       (assoc-ref config #:hes)))))
          (service-extension profile-service-type
                             (lambda (config)
                               (list (stateless:diff-tool-package
                                      "stateless-diff"
                                      `',(assoc-ref config #:state)
                                      `',(assoc-ref config #:ignore)
                                      "/"
                                      (assoc-ref config #:persist-dir)
                                      (assoc-ref config #:machine-dir)))))))
   (compose identity)
   (extend stateless:extend-proc)
   (description "Initialize a stateless system.")))
#+end_src
******** Populate
#+begin_src scheme
(define (populate-gexp log-state-dir)
  (with-extensions (list guile-gcrypt)
    (with-imported-modules (source-module-closure
                            '((guix build utils)
                              (gnu build install)))
      #~(begin
          (use-modules ((guix build utils) #:select (mkdir-p))
                       ((gnu build install) #:select (populate-root-file-system)))

          (let* ((system-path "/var/guix/profiles/system")
                 (system-1-path "/var/guix/profiles/system-1-link")
                 (system-1-exists? (file-exists? system-1-path))
                 (system-link (readlink system-path))
                 (system-1-link (if system-1-exists?
                                    (readlink system-1-path)
                                    system-link)))
            (populate-root-file-system system-1-link ""
                                       #:extras `((,system-path -> ,system-link)))
            (unless system-1-exists?
              (delete-file system-1-path)))

          (let* ((dir "/var/log")
                 (state-dir (string-append #$log-state-dir dir)))
            (rmdir dir) ; It already exists, created by `populate-root-file-system'.
            (mkdir-p state-dir)
            (symlink state-dir dir))))))
#+end_src
******** Users
#+begin_src scheme
(define (user-homes-shepherd-service user-homes state-dirs)
  (shepherd-service
   (provision '(stateless-user-homes))
   (requirement '(file-systems))
   (one-shot? #t)
   (start (with-imported-modules '((guix build utils))
            #~(lambda ()
                (let ((mkdirp-user-home
                       (lambda (dir uid gid)
                         (mkdir-p dir)
                         (chmod dir #o700)
                         (chown dir uid gid))))
                  (for-each
                   (lambda (user-home)
                     (let* ((pw (getpwnam (car user-home)))
                            (uid (passwd:uid pw))
                            (gid (passwd:gid pw))
                            (home (cdr user-home)))
                       (mkdirp-user-home home uid gid)
                       (for-each
                        (lambda (state-dir)
                          (mkdirp-user-home (string-append state-dir home) uid gid))
                        '#$state-dirs)))
                   '#$user-homes))
                #t)))))

(define (activate-home-shepherd-services hes)
  (let ((svc
         (lambda (user he)
           (shepherd-service
            (provision (list (symbol-append 'stateless-home- (string->symbol user))))
            (requirement '(stateless-user-homes))
            (one-shot? #t)
            (start #~(make-forkexec-constructor
                      '(#$(file-append he "/activate"))
                      #:user #$user
                      #:group (group:name (getgrgid (passwd:gid (getpw #$user))))
                      #:log-file (string-append "/var/log/stateless-home-" #$user ".log")
                      #:environment-variables
                      (list (string-append "HOME=" (passwd:dir (getpw #$user))))))
            (stop #~(make-kill-destructor))))))
    (map (match-lambda
           ((user . he)
            (svc user he)))
         hes)))
#+end_src
******* Extension helper
#+begin_src scheme
(define stateless-service
  (stateless:service-fn stateless-service-type))
#+end_src
****** Nix
#+begin_src scheme
(define* (stateless-nix os #:key machine-dir)
  (let* ((nix-dir "/nix")
         (nix-machine-dir (string-append machine-dir nix-dir)))
    (system-comp
     os
     (file-systems
      (cons* (file-system
               (device nix-machine-dir)
               (mount-point nix-dir)
               (type "none")
               (flags '(bind-mount))
               (check? #f))
             (operating-system-file-systems os)))
     (services
      (append
       (operating-system-user-services os)
       (list
        (simple-service 'create-nix-dir
                        activation-service-type
                        (create-nix-dir-gexp nix-machine-dir))
        (stateless-service
         'nix
         #:ignore (list nix-dir))))))))

(define (create-nix-dir-gexp nix-dir)
  #~(begin
      (when (not (file-exists? #$nix-dir))
        (mkdir #$nix-dir))))
#+end_src
*** Hardware-specific
**** Console
***** Console keyboard layouts
Must succeed [[*Bootloader][Bootloader]] component.
#+begin_src scheme
(define-system-comp (console-keyboard-layouts #:key kb-layout)
  (keyboard-layout kb-layout)
  (bootloader (bootloader-configuration
               (inherit (operating-system-bootloader os))
               (keyboard-layout kb-layout))))
#+end_src
**** Macbook
#+begin_src scheme
(define* (macbook os #:key bluetooth?)
  (-> os
      (macbook-wireless #:bluetooth? bluetooth?)
      macbook-camera
      macbook-power-key))

(define (with-blacklist kernel-args new-kernel-args)
  (let* ((blacklist-param "modprobe.blacklist")
         (blacklist? (lambda (arg)
                       (string-prefix? blacklist-param arg))))
    (if (any blacklist? kernel-args)
        (map (lambda (arg)
               (if (blacklist? arg)
                   (string-append arg "," new-kernel-args)
                   arg))
             kernel-args)
        (cons* (string-append blacklist-param "=" new-kernel-args) kernel-args))))
#+end_src
***** Wireless
I'm not sure if this requires the nonfree linux kernel and/or if the blacklist refers to kernel modules not present in =linux-libre=.
#+begin_src scheme
(define-system-comp (macbook-wireless #:key bluetooth?)
  (kernel-loadable-modules (cons* (broadcom-with-patch-updates broadcom-sta)
                                  (operating-system-kernel-loadable-modules os)))
  (kernel-arguments (with-blacklist (operating-system-user-kernel-arguments os)
                                    "b43,b43legacy,ssb,bcm43xx,brcm80211,brcmfmac,brcmsmac,bcma"))
  (firmware (append
             (operating-system-firmware os)
             (if bluetooth?
                 (list broadcom-bt-firmware) '()))))
#+end_src
****** Broadcom STA :upstream:
#+begin_src scheme
(define-public (broadcom-with-patch-updates broadcom)
  (package
    (inherit broadcom)
    (source
     (origin
       (inherit (package-source broadcom))
       (patches
        (append
         (-> broadcom package-source origin-patches)
         (list
          (local-file "packages/patches/broadcom-sta-linux-5.17.patch")
          (local-file "packages/patches/broadcom-sta-linux-5.18.patch")
          (local-file "packages/patches/broadcom-sta-pedantic-fix.patch"))))))))
#+end_src
******* Patches
:PROPERTIES:
:meta-dir+: /packages/patches
:VISIBILITY: content
:END:
******** Linux 5.17
#+begin_src diff :tangle (meta-in-dir "broadcom-sta-linux-5.17.patch")
From 31b7849092c43805c7fbaf7518b99874aa1b310c Mon Sep 17 00:00:00 2001
From: Joan Bruguera <joanbrugueram@gmail.com>
Date: Wed, 12 Jan 2022 20:49:20 +0100
Subject: [PATCH] Tentative fix for broadcom-wl 6.30.223.271 driver for Linux 5.17-rc1

Set netdev->dev_addr through dev_addr_mod + PDE_DATA fix

Since Linux 5.17 netdev->dev_addr is const and must be changed through
dev_addr_mod, otherwise a warning is logged in dmesg and bad things may happen.

NB: The #if is not wrong, dev_addr_mod is defined since Linux 5.15-rc1

Plus a trivial fix for PDE_DATA.

Applies on top of all the patches applied to broadcom-wl-dkms 6.30.223.271-28 on Arch Linux.

See also: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=adeef3e32146a8d2a73c399dc6f5d76a449131b1
          https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=359745d78351c6f5442435f81549f0207ece28aa
---
 src/wl/sys/wl_linux.c | 16 +++++++++++++---
 1 file changed, 13 insertions(+), 3 deletions(-)

diff --git a/src/wl/sys/wl_linux.c b/src/wl/sys/wl_linux.c
index e491df7..e4614fb 100644
--- a/src/wl/sys/wl_linux.c
+++ b/src/wl/sys/wl_linux.c
@@ -93,6 +93,10 @@ struct iw_statistics *wl_get_wireless_stats(struct net_device *dev);
 
 #include <wlc_wowl.h>
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0))
+#define PDE_DATA pde_data
+#endif
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
 static void wl_timer(struct timer_list *tl);
 #else
@@ -490,6 +494,12 @@ wl_if_setup(struct net_device *dev)
 #endif
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0)
+static inline void eth_hw_addr_set(struct net_device *dev, const void *addr) {
+	memcpy(dev->dev_addr, addr, ETHER_ADDR_LEN);
+}
+#endif
+
 static wl_info_t *
 wl_attach(uint16 vendor, uint16 device, ulong regs,
 	uint bustype, void *btparam, uint irq, uchar* bar1_addr, uint32 bar1_size)
@@ -634,7 +644,7 @@ wl_attach(uint16 vendor, uint16 device, ulong regs,
 			WL_ERROR(("wl%d: Error setting MAC ADDRESS\n", unit));
 	}
 #endif 
-	bcopy(&wl->pub->cur_etheraddr, dev->dev_addr, ETHER_ADDR_LEN);
+	eth_hw_addr_set(dev, wl->pub->cur_etheraddr.octet);
 
 	online_cpus = 1;
 
@@ -1835,7 +1845,7 @@ wl_set_mac_address(struct net_device *dev, void *addr)
 
 	WL_LOCK(wl);
 
-	bcopy(sa->sa_data, dev->dev_addr, ETHER_ADDR_LEN);
+	eth_hw_addr_set(dev, sa->sa_data);
 	err = wlc_iovar_op(wl->wlc, "cur_etheraddr", NULL, 0, sa->sa_data, ETHER_ADDR_LEN,
 		IOV_SET, (WL_DEV_IF(dev))->wlcif);
 	WL_UNLOCK(wl);
@@ -3010,7 +3020,7 @@ _wl_add_monitor_if(wl_task_t *task)
 	else
 		dev->type = ARPHRD_IEEE80211_RADIOTAP;
 
-	bcopy(wl->dev->dev_addr, dev->dev_addr, ETHER_ADDR_LEN);
+	eth_hw_addr_set(dev, wl->dev->dev_addr);
 
 #if defined(WL_USE_NETDEV_OPS)
 	dev->netdev_ops = &wl_netdev_monitor_ops;
-- 
2.35.1

#+end_src
******** Linux 5.18
#+begin_src diff :tangle (meta-in-dir "broadcom-sta-linux-5.18.patch")
diff -u -r a/src/shared/linux_osl.c b/src/shared/linux_osl.c
--- a/src/shared/linux_osl.c	2022-05-24 20:51:15.662604980 +0000
+++ b/src/shared/linux_osl.c	2022-05-24 21:13:38.264472425 +0000
@@ -599,6 +599,8 @@
 	va = kmalloc(size, GFP_ATOMIC | __GFP_ZERO);
 	if (va)
 		,*pap = (ulong)__virt_to_phys(va);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	va = dma_alloc_coherent(&((struct pci_dev *)osh->pdev)->dev, size, (dma_addr_t*)pap, GFP_ATOMIC);
 #else
 	va = pci_alloc_consistent(osh->pdev, size, (dma_addr_t*)pap);
 #endif
@@ -612,6 +614,8 @@
 
 #ifdef __ARM_ARCH_7A__
 	kfree(va);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	dma_free_coherent(&((struct pci_dev *)osh->pdev)->dev, size, va, (dma_addr_t)pa);
 #else
 	pci_free_consistent(osh->pdev, size, va, (dma_addr_t)pa);
 #endif
@@ -623,7 +627,11 @@
 	int dir;
 
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	dir = (direction == DMA_TX)? DMA_TO_DEVICE: DMA_FROM_DEVICE;
+#else
 	dir = (direction == DMA_TX)? PCI_DMA_TODEVICE: PCI_DMA_FROMDEVICE;
+#endif
 
 #if defined(__ARM_ARCH_7A__) && defined(BCMDMASGLISTOSL)
 	if (dmah != NULL) {
@@ -641,7 +649,11 @@
 				ASSERT(totsegs + nsegs <= MAX_DMA_SEGS);
 				sg->page_link = 0;
 				sg_set_buf(sg, PKTDATA(osh, skb), PKTLEN(osh, skb));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+				dma_map_single(&((struct pci_dev *)osh->pdev)->dev, PKTDATA(osh, skb), PKTLEN(osh, skb), dir);
+#else
 				pci_map_single(osh->pdev, PKTDATA(osh, skb), PKTLEN(osh, skb), dir);
+#endif
 			}
 			totsegs += nsegs;
 			totlen += PKTLEN(osh, skb);
@@ -656,7 +668,11 @@
 	}
 #endif 
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	return (dma_map_single(&((struct pci_dev *)osh->pdev)->dev, va, size, dir));
+#else
 	return (pci_map_single(osh->pdev, va, size, dir));
+#endif
 }
 
 void BCMFASTPATH
@@ -665,8 +681,13 @@
 	int dir;
 
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	dir = (direction == DMA_TX)? DMA_TO_DEVICE: DMA_FROM_DEVICE;
+	dma_unmap_single(&((struct pci_dev *)osh->pdev)->dev, (uint32)pa, size, dir);
+#else
 	dir = (direction == DMA_TX)? PCI_DMA_TODEVICE: PCI_DMA_FROMDEVICE;
 	pci_unmap_single(osh->pdev, (uint32)pa, size, dir);
+#endif
 }
 
 #if defined(BCMDBG_ASSERT)
#+end_src
******** Pedantic fix
#+begin_src diff :tangle (meta-in-dir "broadcom-sta-pedantic-fix.patch")
diff --git a/src/shared/linux_osl.c b/shared/linux_osl.c
index 711b771..5a2636a 100644
--- a/src/shared/linux_osl.c
+++ b/src/shared/linux_osl.c
@@ -1105,7 +1105,7 @@ osl_os_get_image_block(char *buf, int len, void *image)
 	if (!image)
 		return 0;
 
-	rdlen = kernel_read(fp, fp->f_pos, buf, len);
+	rdlen = kernel_read(fp, (void *)fp->f_pos, (size_t)len, (loff_t *)buf);
 	if (rdlen > 0)
 		fp->f_pos += rdlen;
 
diff --git a/src/wl/sys/wl_cfg80211_hybrid.c b/wl/sys/wl_cfg80211_hybrid.c
index 41c16d8..d39d9de 100644
--- a/src/wl/sys/wl_cfg80211_hybrid.c
+++ b/src/wl/sys/wl_cfg80211_hybrid.c
@@ -790,6 +790,7 @@ wl_set_auth_type(struct net_device *dev, struct cfg80211_connect_params *sme)
 		break;
 	case NL80211_AUTHTYPE_NETWORK_EAP:
 		WL_DBG(("network eap\n"));
+		break;
 	default:
 		val = 2;
 		WL_ERR(("invalid auth type (%d)\n", sme->auth_type));
@@ -2347,21 +2348,20 @@ wl_bss_roaming_done(struct wl_cfg80211_priv *wl, struct net_device *ndev,
                     const wl_event_msg_t *e, void *data)
 {
 	struct wl_cfg80211_connect_info *conn_info = wl_to_conn(wl);
+	s32 err = 0;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
 	struct cfg80211_bss *bss;
 	struct wlc_ssid *ssid;
+	struct cfg80211_roam_info roam_info;
 	ssid = &wl->profile->ssid;
 	bss = cfg80211_get_bss(wl_to_wiphy(wl), NULL, (s8 *)&wl->bssid,
 	ssid->SSID, ssid->SSID_len, WLAN_CAPABILITY_ESS, WLAN_CAPABILITY_ESS);
-	struct cfg80211_roam_info roam_info = {
-		.bss = bss,
-		.req_ie = conn_info->req_ie,
-		.req_ie_len = conn_info->req_ie_len,
-		.resp_ie = conn_info->resp_ie,
-		.resp_ie_len = conn_info->resp_ie_len,
-	};
+	roam_info.bss = bss;
+	roam_info.req_ie = conn_info->req_ie;
+	roam_info.req_ie_len = conn_info->req_ie_len;
+	roam_info.resp_ie = conn_info->resp_ie;
+	roam_info.resp_ie_len = conn_info->resp_ie_len;
 #endif
-	s32 err = 0;
 
 	wl_get_assoc_ies(wl);
 	memcpy(wl->profile->bssid, &e->addr, ETHER_ADDR_LEN);
diff --git a/src/wl/sys/wl_iw.h b/wl/sys/wl_iw.h
index 3ab084f..471d11f 100644
--- a/src/wl/sys/wl_iw.h
+++ b/src/wl/sys/wl_iw.h
@@ -70,7 +70,6 @@ struct cntry_locales_custom {
 #define	WL_IW_RSSI_EXCELLENT	-57	
 #define	WL_IW_RSSI_INVALID	 0	
 #define MAX_WX_STRING 80
-#define isprint(c) bcm_isprint(c)
 #define WL_IW_SET_ACTIVE_SCAN	(SIOCIWFIRSTPRIV+1)
 #define WL_IW_GET_RSSI			(SIOCIWFIRSTPRIV+3)
 #define WL_IW_SET_PASSIVE_SCAN	(SIOCIWFIRSTPRIV+5)
diff --git a/src/wl/sys/wl_linux.c b/wl/sys/wl_linux.c
index d13fb98..97ae2a6 100644
--- a/src/wl/sys/wl_linux.c
+++ b/src/wl/sys/wl_linux.c
@@ -797,14 +797,15 @@ wl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	pci_read_config_dword(pdev, 0x40, &val);
 	if ((val & 0x0000ff00) != 0)
 		pci_write_config_dword(pdev, 0x40, val & 0xffff00ff);
-		bar1_size = pci_resource_len(pdev, 2);
-		#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
-		bar1_addr = (uchar *)ioremap(pci_resource_start(pdev, 2),
-			bar1_size);
-		#else
-		bar1_addr = (uchar *)ioremap_nocache(pci_resource_start(pdev, 2),
-			bar1_size);
-		#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0) */
+
+	bar1_size = pci_resource_len(pdev, 2);
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+	bar1_addr = (uchar *)ioremap(pci_resource_start(pdev, 2),
+		bar1_size);
+	#else
+	bar1_addr = (uchar *)ioremap_nocache(pci_resource_start(pdev, 2),
+		bar1_size);
+	#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0) */
 	wl = wl_attach(pdev->vendor, pdev->device, pci_resource_start(pdev, 0), PCI_BUS, pdev,
 		pdev->irq, bar1_addr, bar1_size);
 
#+end_src
***** Camera :upstream:
Colors could probably be improved by adding sensor calibration files, as described on the wiki: [[https://github.com/patjak/facetimehd/wiki/Extracting-the-sensor-calibration-files][Extracting the sensor calibration files  patjak/facetimehd Wiki  GitHub]]
Adapt the Nix module like I did for the kernel module and firmware:
- [[https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/hardware/video/webcam/facetimehd.nix][nixpkgs/facetimehd.nix at master  NixOS/nixpkgs  GitHub]]
- [[https://github.com/NixOS/nixpkgs/blob/master/pkgs/os-specific/linux/firmware/facetimehd-calibration/default.nix][nixpkgs/default.nix at master  NixOS/nixpkgs  GitHub]]
#+begin_src scheme
(define-system-comp (macbook-camera)
  (kernel-loadable-modules (cons* facetimehd
                                  (operating-system-kernel-loadable-modules os)))
  (kernel-arguments (with-blacklist (operating-system-user-kernel-arguments os)
                                    "bdc_pci"))
  (firmware (cons* facetimehd-firmware
                   (operating-system-firmware os)))
  (services
   (cons* (simple-service 'facetimehd
                          kernel-module-loader-service-type
                          '("facetimehd"))
          (operating-system-user-services os))))
#+end_src
****** Linux module :package:version:
#+begin_src scheme :tangle (meta-in-dir "packages/facetimehd.scm")
(define-module (phrenetic packages facetimehd)
  #:use-module (guix build-system linux-module)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:))

(define-public facetimehd
  (package
    (name "facetimehd")
    (version "0.5.18")
    (source
     (origin
       (method git-fetch)
       (uri (git-reference
             (url "https://github.com/patjak/facetimehd")
             (commit version)))
       (sha256
        (base32
         "1598pzjnbij3knvqmk2yslj26wmqiqjqgqgcw9p9jx6z7bdjvvsh"))))
    (build-system linux-module-build-system)
    (arguments
     '(#:tests? #f))
    (synopsis "Linux driver for the FacetimeHD (Broadcom 1570) PCIe webcam")
    (description synopsis)
    (home-page "https://github.com/patjak/facetimehd")
    (license license:gpl2)
    (supported-systems '("i686-linux" "x86_64-linux"))))
#+end_src
****** Firmware :package:version:
#+begin_src scheme :tangle (meta-in-dir "packages/facetimehd-firmware.scm")
(define-module (phrenetic packages facetimehd-firmware)
  #:use-module (guix build-system trivial)
  #:use-module (guix gexp)
  #:use-module (guix download)
  #:use-module (guix packages)
  #:use-module ((gnu packages base) #:select (coreutils))
  #:use-module ((gnu packages compression) #:select (gzip xz))
  #:use-module ((gnu packages cpio) #:select (cpio))
  #:use-module ((gnu packages curl) #:select (curl))
  #:use-module ((nonguix licenses) #:prefix license:))

(define-public facetimehd-firmware
  (package
    (name "facetimehd-firmware")
    (version "1.43")
    (source
     (origin
       (method url-fetch)
       (uri "https://updates.cdn-apple.com/2019/cert/041-88431-20191011-e7ee7d98-2878-4cd9-bc0a-d98b3a1e24b1/OSXUpd10.11.5.dmg")
       (sha256
        (base32
         "009kfk1nrrialgp69c5smzgbmd5xpvk35xmqr2fzb15h6pp33ka6"))))
    (build-system trivial-build-system)
    (arguments
     `(#:builder
       ,(with-imported-modules '((guix build utils))
          #~(begin
              (use-modules ((guix build utils) #:select (invoke mkdir-p search-input-file)))

              (define (exe name)
                (search-input-file %build-inputs (string-append "/bin/" name)))

              (let ((source "source")
                    (firmware-in "./System/Library/Extensions/AppleCameraInterface.kext/Contents/MacOS/AppleCameraInterface")
                    (firmware-out "firmware.bin"))
                (let ((offset 204909802)
                      (size 207733123))
                  (invoke (exe "curl")
                          "--range" (string-append
                                     (number->string offset) "-" (number->string size))
                          "--output" source
                          (string-append "file://" #$source)))
                (system
                 (string-join
                  (list (exe "xz") "--decompress" "--stdout" source
                        "|"
                        (exe "cpio") "--format=odc" "--extract" "--make-directories" firmware-in)))
                (let ((offset 81920)
                      (size 603715))
                  (invoke (exe "dd")
                          (string-append "if=" firmware-in)
                          (string-append "of=" firmware-out ".gz")
                          (string-append "skip=" (number->string offset))
                          (string-append "count=" (number->string size))
                          "bs=1"))
                (let ((firmware-dir (string-append #$output "/lib/firmware/facetimehd")))
                  (mkdir-p firmware-dir)
                  (system
                   (string-join
                    (list (exe "gunzip") "--stdout" (string-append firmware-out ".gz")
                          ">"
                          (string-append firmware-dir "/" firmware-out))))))))))
    (native-inputs
     (list coreutils
           cpio
           curl
           gzip
           xz))
    (synopsis "FacetimeHD firmware")
    (description synopsis)
    (home-page "https://github.com/patjak/facetimehd-firmware")
    (license license:nonfree)
    (supported-systems '("i686-linux" "x86_64-linux"))))
#+end_src
***** Power key
Make the power key suspend instead of power off. It's part of the keyboard on MacBooks and too easy to press by accident. This is also the behavior on macOS.
#+begin_src scheme
(define-system-comp (macbook-power-key)
  (services
   (modify-services (operating-system-user-services os)
     (elogind-service-type
      config =>
      (elogind-configuration
       (inherit config)
       (handle-power-key 'suspend))))))
#+end_src
***** Keyboard layout
#+begin_src scheme
(define macbook-kb-layout
  (keyboard-layout "us" #:model "macbook78"))
#+end_src
** Templates
#+begin_src scheme
(define* (os-base os
                  #:key
                  stateless?
                  source?
                  source-path
                  users-info
                  nix?
                  console?
                  kmonad?
                  kmonad-users
                  desktop?
                  pipewire?
                  bluetooth?
                  bluetooth-users
                  login-manager
                  auto-login?
                  auto-login-user
                  sessions)
  (let ((number-of-ttys 6))
    (as-> os $
      (if source?
          (source $ #:path source-path) $)
      (base-services $ #:number-of-ttys number-of-ttys)
      (nss $)
      (accounts $ #:users-info users-info)
      (linux-nonfree $)
      (guix-pm $ #:stateless? stateless?)
      (if nix?
          (nix-pm $) $)
      (if console?
          (as-> $ $
            (console-fonts $ #:number-of-ttys number-of-ttys)
            (if kmonad?
                (kmonad-tool $ #:who kmonad-users) $))
          $)
      (if desktop?
          (as-> $ $
            (desktop-services $)
            (if pipewire?
                (pipewire-multimedia $)
                (pulseaudio+alsa $))
            (network-manager $ #:stateless? stateless?)
            ;; (if bluetooth?
            ;;     (bluetooth $ #:who bluetooth-users
            ;;                #:stateless? stateless?)
            ;;     $)
            (if login-manager
                (case login-manager
                  ((#:lm/gdm) (gdm $ #:auto-login? auto-login?
                                   #:auto-login-user auto-login-user)))
                (desktop-tty $ #:auto-login? auto-login?
                             #:auto-login-user auto-login-user))
            (if (member #:session/gnome (or sessions '()))
                (gnome-desktop $) $)
            (if (member #:session/sway (or sessions '()))
                (sway-wm $) $))
          $))))

(define with-host-info host-info)

(define* (with-bootloader os
                          #:key
                          efi?
                          boot-label
                          boot-target)
  ((if efi?
       grub-efi
       ;; grub
       )
   os
   #:label boot-label
   #:target boot-target))

(define* (with-filesystems os
                           #:key
                           filesystem
                           root-label
                           mountables
                           btrfs-mount-flags
                           btrfs-mount-options
                           disk-encryption?
                           luks-label
                           stateless?
                           stateless-persist-dir
                           stateless-machine-dir
                           stateless-users
                           nix?)
  (as-> os $
    (case filesystem
      ;; ((#:filesystem/ext4)
      ;;  (ext4 $ #:label root-label))
      ((#:filesystem/btrfs)
       (btrfs $ #:label root-label
              #:subvols mountables
              #:flags btrfs-mount-flags
              #:options btrfs-mount-options)))
    (if disk-encryption?
        (disk-encryption $ #:label luks-label
                         #:mount-points (case filesystem
                                          ;; ((#:filesystem/ext4)
                                          ;;  ...)
                                          ((#:filesystem/btrfs)
                                           (map cdr mountables))))
        $)
    (swap $ #:stateless? stateless?
          #:stateless-machine-dir stateless-machine-dir
          #:no-cow? (equal? filesystem #:filesystem/btrfs))
    (if stateless?
        (stateless $ #:persist-dir stateless-persist-dir
                   #:machine-dir stateless-machine-dir
                   #:who stateless-users
                   #:nix? nix?)
        $)))

(define* (with-macbook-hardware os #:key bluetooth?)
  (as-> os $
    (console-keyboard-layouts $ #:kb-layout macbook-kb-layout)
    (macbook $ #:bluetooth? bluetooth?)))
#+end_src
* Home
:PROPERTIES:
:meta-dir+: /phrenetic
:header-args+: :tangle (meta-in-dir "home.scm")
:END:
#+begin_src scheme
(define-module (phrenetic home)
  #:use-module (guix build-system trivial)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module (gnu home)
  #:use-module (gnu home services)
  #:use-module (gnu home services shells)
  #:use-module (gnu home services shepherd)
  #:use-module (gnu home services ssh)
  #:use-module (gnu home services xdg)
  #:use-module (gnu home-services terminals)
  #:use-module (gnu home-services version-control)
  #:use-module ((gnu packages browser-extensions) #:select (ublock-origin/chromium))
  #:use-module ((gnu packages chromium) #:select (ungoogled-chromium ungoogled-chromium/wayland))
  #:use-module ((gnu packages compression) #:select (zip unzip zstd))
  #:use-module ((gnu packages curl) #:select (curl))
  #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages fonts) #:select (font-iosevka-aile font-iosevka-etoile font-liberation font-gnu-unifont font-awesome))
  #:use-module ((gnu packages freedesktop) #:select (elogind udiskie xdg-utils xdg-user-dirs desktop-file-utils xdg-desktop-portal xdg-desktop-portal-wlr))
  #:use-module ((gnu packages gimp) #:select (gimp))
  #:use-module ((gnu packages glib) #:select (dbus))
  #:use-module ((gnu packages gnome) #:select (adwaita-icon-theme dconf gnome gnome-session gnome-themes-extra hicolor-icon-theme network-manager-applet))
  #:use-module ((gnu packages gnome-xyz) #:select (arc-theme papirus-icon-theme))
  #:use-module ((gnu packages image) #:select (grim slurp swappy))
  #:use-module ((gnu packages java) #:select (openjdk17))
  #:use-module ((gnu packages linux) #:select (brightnessctl psmisc pipewire-0.3 wireplumber))
  #:use-module ((gnu packages music) #:select (playerctl))
  #:use-module ((gnu packages node) #:select ((node-lts . node)))
  #:use-module ((gnu packages package-management) #:select (flatpak))
  #:use-module ((gnu packages pulseaudio) #:select (pulseaudio pavucontrol))
  #:use-module ((gnu packages qt) #:select (qtwayland))
  #:use-module ((gnu packages rust-apps) #:select (swayhide))
  #:use-module ((gnu packages shells) #:select (zsh))
  #:use-module ((gnu packages shellutils) #:select (direnv))
  #:use-module ((gnu packages terminals) #:select (alacritty))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module ((gnu packages video) #:select (vlc))
  #:use-module ((gnu packages vpn) #:select (protonvpn-cli))
  #:use-module ((gnu packages web) #:select (jq))
  #:use-module ((gnu packages web-browsers) #:select (nyxt))
  #:use-module ((gnu packages wm) #:select (mako swayidle swaylock-effects waybar))
  #:use-module ((gnu packages xdisorg) #:select (gammastep rofi wl-clipboard))
  #:use-module (gnu services)
  #:use-module ((gnu services configuration) #:select (interpose))
  #:use-module (gnu services shepherd)
  #:use-module (gnu system keyboard)
  #:use-module ((nongnu packages clojure) #:select (clj-kondo))
  #:use-module ((nongnu packages mozilla) #:select (firefox firefox/wayland))
  #:use-module (rde home services wm)
  #:use-module (rde home services xdisorg)
  #:use-module ((rde packages) #:select (rofi-wayland (sway-latest . sway)))
  #:use-module ((rde packages fonts) #:select (font-noto-color-emoji))
  #:use-module ((rde serializers elisp) #:select (elisp-serialize))
  #:use-module ((rde serializers ini) #:select (ini-serialize))
  #:use-module ((chromium chromium) #:select (chromium+drm))
  #:use-module ((phrenetic packages aws) #:select (awscli-2))
  #:use-module ((phrenetic packages clojure) #:select (clojure-tools))
  #:use-module ((phrenetic packages datomic) #:select (datomic-cli-tools))
  #:use-module ((phrenetic packages doom-emacs) #:select (doom-emacs))
  #:use-module ((phrenetic packages emacs) #:select (emacs-fully-loaded))
  #:use-module ((phrenetic packages fonts) #:select (font-adobe-source-code-pro))
  #:use-module ((phrenetic packages haskell-apps) #:select (kmonad))
  #:use-module ((phrenetic stateless) #:prefix stateless:)
  #:use-module (phrenetic utils)
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:use-module ((srfi srfi-1) #:select (append-map concatenate delete-duplicates list-index remove))
  #:export (create-he
            he-stateless
            he-shells
            he-emacs
            he-doom
            doom-service
            doom-web
            he-guix
            he-nix
            he-flatpak
            he-kmonad
            he-pipewire
            light-colors
            dark-colors
            he-fonts
            font-mono
            font-sans
            font-serif
            font-unicode
            useful-font-packages
            date-format
            time-format
            he-xdg
            he-mesa
            he-doom-themes+fonts
            he-dbus
            he-gdm
            he-desktop-tty
            he-gnome
            gnome-start
            he-wm-common
            he-sway
            sway-start
            he-swaylock
            swaylock-screen-locker
            swaylock-screen-locker-immediate
            he-swayidle
            swayidle-idle-manager
            he-mako
            he-waybar
            waybar-modules
            he-kanshi
            he-aws
            he-clojure
            he-datomic
            he-doom-calendar
            he-doom-org
            he-direnv
            direnv-service-type
            ;; he-nano
            he-node
            he-protonvpn
            he-ssh
            he-doom-dired
            he-doom-app-launcher
            he-rofi
            rofi-menu
            rofi-application-launcher
            he-doom-trash
            he-git
            he-miscellaneous
            he-pavucontrol
            he-gimp
            he-alacritty
            alacritty-terminal
            he-doom-vterm
            he-chromium
            chromium-flavors
            he-firefox
            he-nyxt
            he-vlc
            he-projects
            services-only-packages
            services-sans-packages
            he-base))
#+end_src
** Create
#+begin_src scheme
(define (create-he services)
  (home-environment
   (services
    (filter service? services))))
#+end_src
** Components
#+begin_src scheme
(define* (skeleton-file file)
  (string-append "/etc/skel/" file))

(define very-big-history 1000000)
#+end_src
*** Stateless
#+begin_src scheme
(define* (he-stateless #:key
                       persist-dir
                       machine-dir
                       extra-state)
  (append
   (list
    (service home-stateless-service-type
             `(#:persist-dir ,persist-dir
               #:machine-dir ,machine-dir)))

   (list
    (home-stateless-service
     'home
     #:state (or extra-state '())
     #:ignore '(".guix-home")))))
#+end_src
**** Service
***** Service type
#+begin_src scheme
(define home-stateless-service-type
  (service-type
   (name 'home-stateless)
   (extensions
    (list (service-extension home-activation-service-type
                             (lambda (config)
                               (stateless:activate-gexp
                                #~(#$state-with-home-expansions '#$(assoc-ref config #:state))
                                homedir-gexp
                                (assoc-ref config #:persist-dir)
                                (assoc-ref config #:machine-dir))))
          (service-extension home-profile-service-type
                             (lambda (config)
                               (list (stateless:diff-tool-package
                                      "home-stateless-diff"
                                      #~(#$state-with-home-expansions '#$(assoc-ref config #:state))
                                      #~(#$ignore-with-home-expansions '#$(assoc-ref config #:ignore))
                                      homedir-gexp
                                      (assoc-ref config #:persist-dir)
                                      (assoc-ref config #:machine-dir)
                                      #:additional-known
                                      guix-home-files))))))
   (compose identity)
   (extend stateless:extend-proc)
   (description "Initialize a stateless home.")))

(define homedir-gexp #~(getenv "HOME"))

(define path-with-home-expansion
  #~(lambda (path)
      (cond
       ((string? path) (string-append (getenv "HOME") "/" path))
       ((list? path)
        (apply
         (lambda* (#:optional tail #:key xdg-base)
           (string-append (getenv xdg-base) "/" (or tail "")))
         path)))))

(define state-with-home-expansions
  #~(lambda (state)
      (map (lambda (i)
             (acons #:path (#$path-with-home-expansion (assoc-ref i #:path)) i))
           state)))

(define ignore-with-home-expansions
  #~(lambda (ignore)
      (map #$path-with-home-expansion ignore)))
#+end_src
****** Diff tool
#+begin_src scheme
(define guix-home-files
  (with-imported-modules '((guix build utils))
    #~(begin
        (use-modules ((guix build utils) #:select (find-files)))

        (let ((home-files
               (let* ((home-dir (getenv "HOME"))
                      (guix-home-dir (string-append
                                      home-dir "/.guix-home/" #$home-files-directory "/")))
                 (map (lambda (file)
                        (string-append
                         home-dir
                         (string-drop file (string-length guix-home-dir))))
                      (find-files guix-home-dir)))))
          (make-known home-files symlink-to-store?)))))
#+end_src
***** Extension helper
#+begin_src scheme
(define home-stateless-service
  (stateless:service-fn home-stateless-service-type))
#+end_src
*** Shells
#+begin_src scheme
(define* (he-shells #:key
                    stateless?
                    doom?
                    doom-tree-sitter?
                    login-shell
                    interactive-shells
                    (bashrc (local-file "bashrc"))
                    (zshrc (local-file "zshrc")))
  (append
   (append-map
    (lambda (shell)
      (case shell
        ((#:shell/bash)
         (list
          (service home-bash-service-type
                   (home-bash-configuration
                    (bashrc
                     (list bashrc))))
          (when stateless?
            (home-stateless-service
             'bash
             #:state '(((#:path . ("bash/" #:xdg-base "XDG_STATE_HOME"))
                        (#:store . #:persist)))))))
        ((#:shell/zsh)
         (list
          (service home-zsh-service-type
                   (home-zsh-configuration
                    (zshrc
                     (list zshrc))))
          (when stateless?
            (home-stateless-service
             'zsh
             #:state '(((#:path . ("zsh/" #:xdg-base "XDG_STATE_HOME"))
                        (#:store . #:persist))
                       ((#:path . ("zsh/" #:xdg-base "XDG_CACHE_HOME"))
                        (#:store . #:machine)))))))))
    (cons login-shell interactive-shells))

   (list
    (let ((default-interactive-shell (car interactive-shells)))
      (when-not (equal? login-shell default-interactive-shell)
                (simple-service
                 'set-shell-env-var
                 home-environment-variables-service-type
                 `(("SHELL" . ,(case default-interactive-shell
                                 ;; ((#:shell/bash) (file-append bash "/bin/bash"))
                                 ((#:shell/zsh) (file-append zsh "/bin/zsh")))))))))

   (if doom?
       (doom-shells #:stateless? stateless?
                    #:tree-sitter? doom-tree-sitter?)
       '())))
#+end_src
**** Bash
***** Bashrc
#+begin_src sh :tangle (meta-in-dir "bashrc")
HISTFILE=${XDG_STATE_HOME:-$HOME/.local/var/lib}/bash/.bash_history
#+end_src
**** Zsh
***** Zshrc
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "zshrc")
:END:
****** Andrew Tropin's zshrc
- TODO trying out Andrew Tropin's zsh configuration verbatim for now. Should I also try out vanilla zshell?
#+begin_src sh
# Prevent freezing output on ^s, needed for various isearches
hash stty 2> /dev/null && stty -ixon

# Completions and other stuff
autoload -U compinit
compinit -d ${XDG_CACHE_HOME:-$HOME/.cache}/zsh/.zcompdump

# Enable bash completion, requires to source them from somewhere
# autoload -U bashcompinit && bashcompinit

zstyle ':completion:*' menu select
zstyle ':completion:*' insert-tab false

# Automatically update cache of binaries avaliable in $PATH
zstyle ':completion:*' rehash true # Can have a performance penalty

# Approximate completion
# zstyle ':completion:::::' completer _complete _approximate
# zstyle ':completion:*:approximate:*' max-errors 2

# Fuzzy completion
# https://superuser.com/questions/415650/does-a-fuzzy-matching-mode-exist-for-the-zsh-shell
zstyle ':completion:*' matcher-list '' \
  'm:{a-z\-}={A-Z\_}' \
  'r:[^[:alpha:]]||[[:alpha:]]=** r:|=* m:{a-z\-}={A-Z\_}' \
  'r:|?=** m:{a-z\-}={A-Z\_}'

# Make kill completion smart
zstyle ':completion:*:*:*:*:processes' command "ps -u $USER -o pid,user,args -w -w"

# Colored completion for files and dirs according to LS_COLORS

hash dircolors 2> /dev/null && eval $(dircolors --sh) && \
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

# Prompt theme setup
clear_fn() {
#  zle reset-prompt
  zle kill-buffer
}

prompt_rde_precmd() {
  # Prevent killing prompt on ^C
  trap 'clear_fn' SIGINT
}

prompt_rde_setup() {
  if [[ $UID -eq 0 ]]; then
    user_part='%F{red}>%f'
  else
    user_part='%F{green}>%f'
  fi
  if [ -n "$GUIX_ENVIRONMENT" ]; then
    genv_part='%F{blue}>%f'
  fi
  # exit_code_part='%(?..[%?])'

  PS1="$user_part$genv_part "
  # RPS1="$exit_code_part"

  # Fish-like C-c behavior
  # add-zsh-hook precmd prompt_rde_precmd
}

# Load promptinit and set rde theme
autoload -Uz promptinit && promptinit
prompt_themes+=( rde )
prompt rde

setopt printexitvalue # Instead of using RPS1 for status code

echo -en "\033[6 q" # Make a cursor to be a vertical bar

# Remove slashes and dashes from wordchars to make M-b, M-f work
# correctly
WORDCHARS=""

# Configure history
# HISTSIZE=5000
# SAVEHIST=$HISTSIZE
HISTFILE=${XDG_STATE_HOME:-$HOME/.local/var/lib}/zsh/.zhistory

#setopt incappendhistory # Save history to shared file, but not read
setopt sharehistory     # Share history across shell sessions
setopt histignorespace  # Ignore commands that start with space

# Configuring help (M-h to call it on current command/function)
autoload -Uz run-help
(( ${+aliases[run-help]} )) && unalias run-help
autoload -Uz run-help-git

# Delete, home, end buttons
bindkey  "^[[3~"  delete-char
bindkey  "^[[H"   beginning-of-line
bindkey  "^[[F"   end-of-line

# Launch $VISUAL or $EDITOR, for emacsclient if there is no server
# avaliable $ALTERNATE_EDITOR will be used.
autoload -z edit-command-line
zle -N edit-command-line
bindkey "^X^E" edit-command-line

alias help=run-help
alias try='guix shell man-db coreutils'
alias ls='ls -p --color=auto'
alias ll='ls -l'
alias grep='grep --color=auto'
#+end_src
****** History
- TODO use ~very-big-history~
#+begin_src sh
HISTSIZE=1000000
SAVEHIST=$HISTSIZE
#+end_src
**** Doom shells
#+begin_src scheme
(define* (doom-shells #:key
                      stateless?
                      tree-sitter?)
  (append
   (doom-ts-lang 'sh #:tree-sitter? tree-sitter?)
   (doom-eshell #:stateless? stateless?)))
#+end_src
***** Doom eshell
#+begin_src scheme
(define* (doom-eshell #:key stateless?)
  (let ((name 'eshell))
    (list
     (doom-service
      name
      #:modules '((#:term
                   eshell))
      #:config `((after! eshell
                         (setq eshell-history-size ,very-big-history)))) ; Setting this to `nil' to inherit envvar HISTSIZE is another option.

     (when stateless?
       (doom-stateless-service
        name
        #:state '(((#:path . ("eshell/history" #:doom-base #:data))
                   (#:store . #:persist))
                  ((#:path . ("eshell/lastdir" #:doom-base #:data))
                   (#:store . #:persist))
                  ((#:path . ("eshell/z" #:doom-base #:data))
                   (#:store . #:persist))))))))
#+end_src
*** Emacs
#+begin_src scheme
(define* (he-emacs #:key (emacs emacs-fully-loaded))
  (list
   (simple-service
    'emacs-add-package
    home-profile-service-type
    (list emacs))

   (simple-service
    'emacs-set-editor-env-vars
    home-environment-variables-service-type
    `(("VISUAL" . ,(file-append emacs "/bin/emacsclient"))
      ("EDITOR" . "$VISUAL")))))
#+end_src
**** Emacs packages
:PROPERTIES:
:meta-dir+: /packages
:header-args+: :tangle (meta-in-dir "emacs.scm")
:END:
#+begin_src scheme
(define-module (phrenetic packages emacs)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages emacs) #:select (emacs emacs-next-pgtk))
  #:use-module ((gnu packages gcc) #:select (libgccjit-12))
  #:use-module (phrenetic utils)
  #:use-module ((srfi srfi-1) #:select (remove))
  #:export (emacs-fully-loaded))
#+end_src
***** Emacs PGTK :version:
#+begin_src scheme
(define-public emacs-pgtk
  (as-> emacs-next-pgtk $
    (with-git-url $ "https://github.com/flatwhatson/emacs")
    (with-git-commit $ #:upstream-version "28.1.91"
                     #:commit "031a3a803b1658c2ea2ccda76d46a99dc810eec2"
                     #:hash "1vhycsbvmfzihk84xjkcm7psyhw0ir64p4vh0hfmhxvw1xy0sbqs")
    (let ((emacs $))
      (package
        (inherit emacs)
        (source
         (origin
           (inherit (package-source emacs))
           (patches
            (remove (lambda (patch)
                      (string-suffix? "emacs-pgtk-super-key-fix.patch" patch))
                    (-> emacs package-source origin-patches)))))))))
#+end_src
***** HOLD Libgccjit latest
This isn't working, at least not with ~doom sync~. Revisit after I finish my Guix-straight integration since I probably won't be using ~doom sync~ afterward anyway. Just hold off in general too, I only just switched to Guix's version of Emacs native compilation, I may learn more.
#+begin_src scheme
(define (with-libgccjit-latest emacs)
  (package
    (inherit emacs)
    (inputs
     (modify-inputs (package-inputs emacs)
       (replace "libgccjit" libgccjit-12)))))
#+end_src
***** Findable C source
#+begin_src scheme
(define-public (with-findable-C-source emacs)
  (package
    (inherit emacs)
    (arguments
     (substitute-keyword-arguments (package-arguments emacs)
       ((#:phases phases '%standard-phases)
        #~(modify-phases #$phases
            (add-after 'unpack 'patch-C-source-directory
              (lambda _
                (substitute* "lisp/emacs-lisp/find-func.el"
                  (("\\(expand-file-name \"src\" source-directory\\)")
                   (string-append "\"" #$(file-append (package-source emacs) "/src") "\"")))))))))))
#+end_src
***** Path integration improvements
#+begin_src scheme
(define-public (with-path-integration-improvements emacs)
  (package
    (inherit emacs)
    (source
     (origin
       (inherit (package-source emacs))
       (snippet
        `(begin
           ,(origin-snippet (package-source emacs))
           (let ((wrap-in-quotes (lambda (s)
                                   (string-append "\"" s "\""))))
             (with-directory-excursion "lisp"
               (substitute* "net/tramp.el"
                 (("\\(tramp-default-remote-path" start-of-list)
                  (string-join
                   (cons start-of-list
                         (map wrap-in-quotes
                              (list "~/.config/guix/current/bin"
                                    "~/.guix-home/profile/bin")))
                   " ")))
               (substitute* "man.el"
                 (("\"/usr/local/include\"" last-item)
                  (string-join
                   (list last-item
                         (wrap-in-quotes "~/.guix-home/profile/include"))
                   " ")))))))))))
#+end_src
***** Emacs fully loaded :package:
#+begin_src scheme
;; TODO Delete this on next Emacs rebuild.
(define (with-zstd emacs)
  (package
    (inherit emacs)
    (propagated-inputs
     (modify-inputs (package-propagated-inputs emacs)
       (prepend (@ (gnu packages compression) zstd))))))

(define* (emacs-fully-loaded* #:key pgtk?)
  (-> (if pgtk?
          emacs-pgtk emacs)
      ;; with-libgccjit-latest
      with-findable-C-source
      with-path-integration-improvements
      with-zstd))

(define emacs-fully-loaded (emacs-fully-loaded* #:pgtk? #t))
#+end_src
*** Doom
#+begin_src scheme
(define* (he-doom #:key
                  stateless?
                  services)
  (append
   (list
    (service doom-service-type)

    (simple-service
     'doom-set-paths
     home-environment-variables-service-type
     (let ((doom-local "$XDG_STATE_HOME/doom"))
       `(("DOOMLOCALDIR" . ,doom-local)
         ("DOOMPROFILELOADFILE" . ,(string-append doom-local "/profile-load.el"))))))

   (if services
       services '())

   (if stateless?
     (list
      (home-stateless-service
       'doom
       #:state '(((#:path . ("doom/straight/" #:xdg-base "XDG_STATE_HOME"))
                  (#:store . #:machine))
                 ((#:path . ("doom/logs/" #:xdg-base "XDG_STATE_HOME"))
                  (#:store . #:machine))
                 ((#:path . ("doom/profile-load.el" #:xdg-base "XDG_STATE_HOME"))
                  (#:store . #:machine))
                 ((#:path . ("doom/profile-load.28.elc" #:xdg-base "XDG_STATE_HOME"))
                  (#:store . #:machine))))
      (doom-stateless-service
       'doom
       #:state '(((#:path . ("eln/" #:doom-base #:cache))
                  (#:store . #:machine))
                 ((#:path . ("profiles.@.el" #:doom-base #:cache))
                  (#:store . #:machine))
                 ((#:path . ("@/" #:doom-base #:data))
                  (#:store . #:machine)))))
     '())))
#+end_src
**** Service
***** Service type
#+begin_src scheme
(define doom-service-type
  (service-type
   (name 'home-doom)
   (extensions
    (list (service-extension home-profile-service-type
                             (const
                              (list `(,doom-emacs "bin"))))
          (service-extension home-xdg-configuration-files-service-type
                             (lambda (config)
                               `(("emacs" ,doom-emacs)
                                 ("doom" ,(doom-private config)))))))
   (compose identity)
   (extend (lambda (_ additional)
             (doom-extend additional)))
   (default-value #f)
   (description "Install and configure Doom.")))
#+end_src
****** Extend procedure
#+begin_src scheme
(define (doom-extend additional)
  (let ((field (lambda (k)
                 (map (lambda (i)
                        (or (assoc-ref i k) '()))
                      additional))))
    `((#:init-file . ,(init-file (field #:modules)))
      (#:config-file . ,(config-file (field #:config)))
      (#:packages-file . ,(packages-file (field #:packages)))
      (#:theme-files . ,(theme-files (field #:themes))))))

(define (init-file exts)
  (as-> exts $
    (map (lambda (i)
           (update-vals i (lambda (modules)
                            (map (lambda (m)
                                   (cond
                                    ((symbol? m) (list m))
                                    ((list? m) m)))
                                 modules))))
         $)
    (apply merge-with
           (lambda (ms ms*)
             (merge-with
              (lambda (flags flags*)
                (delete-duplicates (append flags flags*)))
              ms ms*))
           $)
    (sort $ (lambda (a b)
              (let ((idx (lambda (entry)
                           (list-index
                            (lambda (category)
                              (equal? (car entry) category))
                            '(#:completion #:ui #:editor #:emacs #:term #:checkers #:tools #:lang #:app #:config)))))
                (< (idx a) (idx b)))))
    (update-vals $ (lambda (modules)
                     (let ((name (lambda (m)
                                   (symbol->string (car m)))))
                       (sort modules (lambda (a b)
                                       (string<? (name a) (name b)))))))
    (update-keys $ (lambda (category)
                     (symbol-append ': (keyword->symbol category))))
    (update-vals $ (lambda (modules)
                     (map (lambda (m)
                            (if (= (length m) 1)
                                (car m) m))
                          modules)))
    (apply append $)
    (elisp-serialize
     `(,#~";;; -*- lexical-binding: t; -*-"
          (doom! ,@$)))))

(define (config-file exts)
  (as-> exts $
    (delete-duplicates $)
    (apply append $)
    (elisp-serialize*
     (append
      `(,#~";;; -*- lexical-binding: t; -*-")
      $))))

(define (packages-file exts)
  (as-> exts $
    (delete-duplicates $)
    (apply append $)
    (elisp-serialize*
     (append
      `(,#~";; -*- no-byte-compile: t; -*-")
      $))))

(define (theme-files exts)
  (as-> exts $
    (apply append $)
    (map (lambda (theme)
           (list
            (car theme)
            (->> theme
                 (apply (lambda (name defs extra-faces)
                          `(,#~";;; -*- lexical-binding: t; no-byte-compile: t; -*-"
                               (require 'doom-themes)
                               (def-doom-theme ,name ,(symbol->string name) ,defs ,extra-faces))))
                 elisp-serialize*)))
         $)))

(define (elisp-serialize* exprs)
  #~(begin
      (use-modules ((ice-9 string-fun) #:select (string-replace-substring)))
      (string-replace-substring #$(elisp-serialize exprs) "(syntax " "(function ")))
#+end_src
****** Doom private
#+begin_src scheme
(define (doom-private config)
  (file-union
   "doom-private"
   (append
    (map (match-lambda
           ((name file)
            `(,(string-append name)
              ,(mixed-text-file (string-append "doom-" name) (assoc-ref config file)))))
         '(("init.el" #:init-file)
           ("config.el" #:config-file)
           ("packages.el" #:packages-file)))
    (map (match-lambda
           ((theme-name file)
            (let ((name (string-append (symbol->string theme-name) "-theme.el")))
              `(,(string-append "themes/" name)
                ,(mixed-text-file name file)))))
         (assoc-ref config #:theme-files)))))
#+end_src
***** Extension helpers
#+begin_src scheme
(define* (doom-service name
                       #:key
                       modules
                       packages
                       config
                       themes)
  (simple-service
   (symbol-append name '-doom)
   doom-service-type
   `((#:modules . ,modules)
     (#:packages . ,packages)
     (#:config . ,config)
     (#:themes . ,themes))))
#+end_src
****** Stateless
#+begin_src scheme
(define* (doom-stateless-service name #:key state ignore)
  (home-stateless-service
   (symbol-append name '-doom)
   #:state (state-with-doom-dir state)
   #:ignore ignore))

(define (state-with-doom-dir state)
  (map (lambda (i)
         (acons #:path (path-with-doom-dir (assoc-ref i #:path)) i))
       state))

(define (path-with-doom-dir path)
  (let ((doom-dir
         (lambda (base subpath)
           `(,(string-append
               "doom/"
               (case base
                 ((#:cache) "cache")
                 ((#:data) "etc"))
               "/" subpath)
             #:xdg-base "XDG_STATE_HOME"))))
    (apply (lambda* (tail #:key doom-base)
             (doom-dir doom-base tail))
           path)))
#+end_src
**** Doom Emacs :package:version:
:PROPERTIES:
:meta-dir+: /packages
:END:
#+begin_src scheme :tangle (meta-in-dir "doom-emacs.scm")
(define-module (phrenetic packages doom-emacs)
  #:use-module (guix build-system copy)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module ((gnu packages rust-apps) #:select (fd ripgrep))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module ((phrenetic packages all-the-icons-fonts) #:select (all-the-icons-fonts)))

(define-public doom-emacs
  (let ((commit "285b460c80e455fabaf036f0eb48575637586a46")
        (revision "0"))
    (package
      (name "doom-emacs")
      (version (git-version "3.0.0-pre" revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/doomemacs/doomemacs")
               (commit commit)))
         (sha256
          (base32
           "0xh5fzhk8qr23sgv931va0mjfgnw9qwxy5z4dp4fdr4dvnavd6vz"))
         (file-name (git-file-name name version))
         (patches
          (list (local-file "patches/dirvish.patch")))))
      (build-system copy-build-system) ; TODO LICENSE file gets installed to a "share/" folder, not hurting anything but maybe remove. More generally perhaps check to see what other changes there might be between a simple checkout of the repo and what copy-build-system does.
      (arguments
       (list
        ;; #:install-plan
        ;; '(("." "share/doom-emacs/"))
        ;; #:tests? #t
        ;; #:test-command '("./bin/doom" "test")
        #:phases
        #~(modify-phases %standard-phases
            (add-after 'install 'symlink-bin
              (lambda _
                (mkdir #$output:bin)
                (symlink (string-append #$output "/bin")
                         (string-append #$output:bin "/bin")))))))
      (propagated-inputs
       (list git
             ripgrep
             fd
             all-the-icons-fonts

             ;; TODO For dirvish, putting them here temporarily.
             (@ (gnu packages rust-apps) fd)
             (@ (gnu packages imagemagick) imagemagick)
             (@ (gnu packages pdf) poppler) ; TODO Readme says "or pdf-tools"?
             ;; TODO epubs. See:
             ;; - https://github.com/alexluigit/dirvish/blob/main/docs/CUSTOMIZING.org
             ;; - https://github.com/alexluigit/dirvish/issues/85
             (@ (gnu packages video) ffmpegthumbnailer)
             (@ (gnu packages video) mediainfo)
             (@ (gnu packages base) tar)
             (@ (gnu packages compression) unzip)))
      (outputs '("out" "bin"))
      (synopsis "An Emacs framework for the stubborn martian hacker")
      (description "Doom is a configuration framework for GNU Emacs tailored for
Emacs bankruptcy veterans who want less framework in their frameworks, a modicum
of stability (and reproducibility) from their package manager, and the
performance of a hand rolled config (or better).")
      (home-page "https://github.com/doomemacs/doomemacs")
      (license license:expat))))
#+end_src
***** WAIT Doom tests :wait_on_doom:
Nonfunctional at the moment ([[doom:core/core-cli.el::212][hlissner has them commented out]]) but once they're working determine if they make sense to run during packaging (if they can find places where my patches, substitutions, etc. can mess stuff up). I'm concerned they'll take too long to run or require network access (to download Straight dependencies). Make sure there aren't any side effect files that end up getting installed.
***** Emacs packages :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "emacs-xyz.scm")
:END:
#+begin_src scheme
(define-module (phrenetic packages emacs-xyz)
  #:use-module (guix build-system copy)
  #:use-module (guix build-system emacs)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages emacs-xyz) #:select (emacs-tldr) #:prefix emacs-xyz:)
  #:use-module ((gnu packages compression) #:select (unzip))
  #:use-module (phrenetic utils))
#+end_src
****** guix-contributing
#+begin_src scheme
(define-public emacs-guix-contributing
  (package
    (name "emacs-guix-contributing")
    (version "0")
    (source
     (local-file "guix-contributing.el"))
    (build-system emacs-build-system)
    (arguments
     '(#:phases
       (modify-phases %standard-phases
         (add-after 'unpack 'patch-guix-source-path
           (lambda* (#:key inputs #:allow-other-keys)
             (make-file-writable "guix-contributing.el")
             (emacs-substitute-variables "guix-contributing.el"
               ("guix-contributing-source-path" (search-input-directory inputs "share/guix-emacs-development"))))))))
    (inputs
     (list guix-emacs-development))
    (home-page #f)
    (synopsis "Some Emacs integration to assist in contributing to Guix")
    (description "See https://guix.gnu.org/manual/en/guix.html#The-Perfect-Setup")
    (license license:gpl3+)))
#+end_src
******* Source
Tempel snippets now available under =/etc/snippets/tempel= as of [2022-08-30 Tue] and this [[https://github.com/guix-mirror/guix/commit/c4acaf412064568a546034871a9e0d3888aa7937][commit]].
#+begin_src emacs-lisp :tangle (meta-in-dir "guix-contributing.el")
(defvar guix-contributing-source-path "~/src/guix")

(with-eval-after-load 'yasnippet
  (add-to-list 'yas-snippet-dirs (concat guix-contributing-source-path "/etc/snippets/yas")))

(load-file (concat guix-contributing-source-path "/etc/copyright.el"))

(when (and user-full-name
           user-mail-address)
  (setq copyright-names-regexp (format "%s <%s>" user-full-name user-mail-address)))

(provide 'guix-contributing)
#+end_src
******* Guix's Emacs development code
Use the github mirror since the canonical repo doesn't allow shallow fetches.
#+begin_src scheme
(define guix-emacs-development*
  (let ((commit "bf0389a3806509650b7a8425973ac5aac722901a")
        (revision "0"))
    (package
      (name "guix-emacs-development")
      (version (git-version "1.3.0" revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://git.savannah.gnu.org/git/guix.git")
               (commit commit)))
         (sha256
          (base32
           "0x4mpw017q4l14aimlyzxxa68jz2rn6zb8m8l7s791fkkdn2paja"))))
      (build-system copy-build-system)
      (arguments
       `(#:install-plan
         '(("etc/copyright.el" "share/guix-emacs-development/etc/copyright.el")
           ("etc/snippets" "share/guix-emacs-development/etc/snippets"))))
      (home-page #f)
      (synopsis #f)
      (description #f)
      (license #f))))

(define guix-emacs-development
  (with-git-url guix-emacs-development* "https://github.com/guix-mirror/guix"))
#+end_src
****** tldr
#+begin_src scheme
(define-public emacs-tldr
  (package
    (inherit emacs-xyz:emacs-tldr)
    (arguments
     (substitute-keyword-arguments (package-arguments emacs-xyz:emacs-tldr)
       ((#:phases phases '%standard-phases)
        #~(modify-phases #$phases
            (add-after 'unpack 'patch-tldr-directory-path
              (lambda* (#:key inputs #:allow-other-keys)
                (emacs-substitute-variables "tldr.el"
                  ("tldr-directory-path" (search-input-directory inputs "share/tldr-pages")))))))))
    (inputs (modify-inputs (package-inputs emacs-xyz:emacs-tldr)
              (prepend tldr-pages)))))
#+end_src
******* tldr pages
#+begin_src scheme
(define tldr-pages
  (let ((commit "7ee7ed0f4afc90ef05b1dde87f6fec5b462a0394")
        (revision "0"))
    (package
      (name "tldr-pages")
      (version (git-version "1.5b" revision commit))
      (source
       (origin
         (method url-fetch/zipbomb)
         (uri (string-append "https://raw.githubusercontent.com/tldr-pages/tldr-pages.github.io/" commit "/assets/tldr.zip"))
         (sha256
          (base32
           "0a09ycfrxiaxv0hzjrkwi56l0ga5d7ydrlclmk4vd6ndb242vhgr"))))
      (build-system copy-build-system)
      (arguments
       `(#:install-plan
         '(("." "share/tldr-pages/"))))
      (home-page "https://tldr.sh")
      (synopsis "A collection of community-maintained help pages for command-line tools")
      (description synopsis)
      (license license:cc-by4.0))))
#+end_src
***** all-the-icons fonts :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "all-the-icons-fonts.scm")
:END:
#+begin_src scheme
(define-module (phrenetic packages all-the-icons-fonts)
  #:use-module (guix build-system font)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((gnu packages emacs-xyz) #:select (emacs-all-the-icons))
  #:use-module ((gnu packages fonts) #:select (font-google-material-design-icons font-awesome))
  #:use-module (phrenetic utils))

(define-public all-the-icons-fonts
  (let ((commit "4a4d6269b8b85b0b15954f063e6ce378630d80c0")
        (revision "0"))
    (package
      (name "all-the-icons-fonts")
      (version (git-version (package-version emacs-all-the-icons) revision commit))
      (source
       (origin
         (inherit (package-source emacs-all-the-icons))
         (uri (git-reference
               (inherit (-> emacs-all-the-icons package-source origin-uri))
               (commit commit)))
         (sha256
          (base32
           "0y1dpxv8hha8pcxssayy0gaa7jd15ad0hwpmpixg164xzjn0cnb6"))
         (file-name (git-file-name name version))))
      (build-system font-build-system)
      (arguments
       `(#:phases
         (modify-phases %standard-phases
           (add-before 'install 'remove-unbundled-fonts
             (lambda _
               (with-directory-excursion "fonts"
                 (for-each delete-file
                           (list "fontawesome.ttf"
                                 "material-design-icons.ttf"))))))))
      (propagated-inputs
       (list font-awesome
             font-google-material-design-icons))
      (home-page (package-home-page emacs-all-the-icons))
      (synopsis (package-synopsis emacs-all-the-icons))
      (description (package-description emacs-all-the-icons))
      (license (package-license emacs-all-the-icons)))))
#+end_src
***** Patches
****** Dirvish :version:
Taken from https://github.com/doomemacs/doomemacs/pull/6760.
#+begin_src diff :tangle (meta-in-dir "patches/dirvish.patch")
diff --git a/modules/emacs/dired/autoload.el b/modules/emacs/dired/autoload.el
deleted file mode 100644
index e44d3dda0dd..00000000000
--- a/modules/emacs/dired/autoload.el
+++ /dev/null
@@ -1,15 +0,0 @@
-;;; emacs/dired/autoload.el -*- lexical-binding: t; -*-
-
-;;;###autoload
-(defun +dired/quit-all ()
-  "Kill all `dired-mode' buffers."
-  (interactive)
-  (mapc #'kill-buffer (doom-buffers-in-mode 'dired-mode))
-  (message "Killed all dired buffers"))
-
-;;;###autoload
-(defun +dired-enable-git-info-h ()
-  "Enable `dired-git-info-mode' in git repos."
-  (and (not (file-remote-p default-directory))
-       (locate-dominating-file "." ".git")
-       (dired-git-info-mode 1)))
diff --git a/modules/emacs/dired/config.el b/modules/emacs/dired/config.el
index 26e5e74e20b..c7d12bb33e0 100644
--- a/modules/emacs/dired/config.el
+++ b/modules/emacs/dired/config.el
@@ -1,10 +1,9 @@
-;;; tools/dired/config.el -*- lexical-binding: t; -*-
+;;; emacs/dired/config.el -*- lexical-binding: t; -*-
 
 (use-package! dired
   :commands dired-jump
   :init
   (setq dired-dwim-target t  ; suggest a target for moving/copying intelligently
-        dired-hide-details-hide-symlink-targets nil
         ;; don't prompt to revert, just do it
         dired-auto-revert-buffer #'dired-buffer-stale-p
         ;; Always copy/delete recursively
@@ -25,31 +24,21 @@
     :slot 20 :size 0.8 :select t :quit nil :ttl 0)
   (set-evil-initial-state! 'image-dired-display-image-mode 'emacs)
 
-  (let ((args (list "-ahl" "-v" "--group-directories-first")))
-    (when IS-BSD
-      ;; Use GNU ls as `gls' from `coreutils' if available. Add `(setq
-      ;; dired-use-ls-dired nil)' to your config to suppress the Dired warning
-      ;; when not using GNU ls.
-      (if-let (gls (executable-find "gls"))
-          (setq insert-directory-program gls)
-        ;; BSD ls doesn't support -v or --group-directories-first
-        (setq args (list (car args)))))
-    (setq dired-listing-switches (string-join args " "))
-
-    (add-hook! 'dired-mode-hook
-      (defun +dired-disable-gnu-ls-flags-maybe-h ()
-        "Remove extraneous switches from `dired-actual-switches' when it's
-uncertain that they are supported (e.g. over TRAMP or on Windows).
-
-Fixes #1703: dired over TRAMP displays a blank screen.
-Fixes #3939: unsortable dired entries on Windows."
-        (when (or (file-remote-p default-directory)
-                  (and (boundp 'ls-lisp-use-insert-directory-program)
-                       (not ls-lisp-use-insert-directory-program)))
-          (setq-local dired-actual-switches (car args))))))
-
-  ;; Don't complain about this command being disabled when we use it
-  (put 'dired-find-alternate-file 'disabled nil)
+  (let ((non-gnu-args "-alh")
+        (gnu-args
+         "-l --almost-all --human-readable --group-directories-first"))
+    (cond ((and (boundp 'ls-lisp-use-insert-directory-program)
+                (not ls-lisp-use-insert-directory-program)
+                (< emacs-major-version 28))
+           ;; Fixes #3939: unsortable dired entries on Windows
+           (setq dired-listing-switches non-gnu-args))
+          (IS-BSD
+           ;; BSD ls doesn't support long options
+           (if-let (gls (executable-find "gls"))
+               (setq insert-directory-program gls
+                     dired-listing-switches gnu-args)
+             (setq dired-listing-switches non-gnu-args)))
+          (t (setq dired-listing-switches gnu-args))))
 
   (defadvice! +dired--no-revert-in-virtual-buffers-a (&rest args)
     "Don't auto-revert in dired-virtual buffers (see `dired-virtual-revert')."
@@ -57,127 +46,11 @@ Fixes #3939: unsortable dired entries on Windows."
     (not (eq revert-buffer-function #'dired-virtual-revert)))
 
   (map! :map dired-mode-map
-        ;; Kill all dired buffers on q
-        :ng "q" #'+dired/quit-all
         ;; To be consistent with ivy/helm+wgrep integration
         "C-c C-e" #'wdired-change-to-wdired-mode))
 
 
-(use-package! dired-rsync
-  :general (dired-mode-map "C-c C-r" #'dired-rsync))
-
-
-(use-package! diredfl
-  :hook (dired-mode . diredfl-mode))
-
-
-(use-package! ranger
-  :when (modulep! +ranger)
-  :after dired
-  :init (setq ranger-override-dired t)
-  :config
-  (unless (file-directory-p image-dired-dir)
-    (make-directory image-dired-dir))
-
-  (set-popup-rule! "^\\*ranger" :ignore t)
-
-  (defadvice! +dired--cleanup-header-line-a ()
-    "Ranger fails to clean up `header-line-format' when it is closed, so..."
-    :before #'ranger-revert
-    (dolist (buffer (buffer-list))
-      (when (buffer-live-p buffer)
-        (with-current-buffer buffer
-          (when (equal header-line-format '(:eval (ranger-header-line)))
-            (setq header-line-format nil))))))
-
-  (defadvice! +dired--cleanup-mouse1-bind-a ()
-    "Ranger binds an anonymous function to mouse-1 after previewing a buffer
-that prevents the user from escaping the window with the mouse. This command is
-never cleaned up if the buffer already existed before ranger was initialized, so
-we have to clean it up ourselves."
-    :after #'ranger-setup-preview
-    (when (window-live-p ranger-preview-window)
-      (with-current-buffer (window-buffer ranger-preview-window)
-        (local-unset-key [mouse-1]))))
-
-  (defadvice! +dired--ranger-travel-a ()
-    "Temporary fix for this function until ralesi/ranger.el#236 gets merged."
-    :override #'ranger-travel
-    (interactive)
-    (let ((prompt "Travel: "))
-      (cond
-       ((bound-and-true-p helm-mode)
-        (ranger-find-file (helm-read-file-name prompt)))
-       ((bound-and-true-p ivy-mode)
-        (ivy-read prompt 'read-file-name-internal
-                  :matcher #'counsel--find-file-matcher
-                  :action
-                  (lambda (x)
-                    (with-ivy-window
-                     (ranger-find-file (expand-file-name x default-directory))))))
-       ((bound-and-true-p ido-mode)
-        (ranger-find-file (ido-read-file-name prompt)))
-       (t
-        (ranger-find-file (read-file-name prompt))))))
-
-  (setq ranger-cleanup-on-disable t
-        ranger-excluded-extensions '("mkv" "iso" "mp4")
-        ranger-deer-show-details t
-        ranger-max-preview-size 10
-        ranger-show-literal nil
-        ranger-hide-cursor nil))
-
-
-(use-package! dirvish
-  :when (modulep! +dirvish)
-  :defer t
-  :init (after! dired (dirvish-override-dired-mode))
-  :hook (dired-mode . dired-omit-mode)
-  :config
-  (setq dirvish-cache-dir (concat doom-cache-dir "dirvish/")
-        dirvish-hide-details nil
-        dirvish-attributes '(git-msg)
-        dired-omit-files (concat dired-omit-files "\\|^\\..*$"))
-  (when (modulep! +icons)
-    (push 'all-the-icons dirvish-attributes))
-  (map! :map dirvish-mode-map
-        :n "b" #'dirvish-goto-bookmark
-        :n "z" #'dirvish-show-history
-        :n "f" #'dirvish-file-info-menu
-        :n "F" #'dirvish-toggle-fullscreen
-        :n "l" #'dired-find-file
-        :n "h" #'dired-up-directory
-        :localleader
-        "h" #'dired-omit-mode))
-
-
-(use-package! all-the-icons-dired
-  :when (modulep! +icons)
-  :unless (modulep! +dirvish)
-  :hook (dired-mode . all-the-icons-dired-mode)
-  :config
-  ;; HACK Fixes #1929: icons break file renaming in Emacs 27+, because the icon
-  ;;      is considered part of the filename, so we disable icons while we're in
-  ;;      wdired-mode.
-  (defvar +wdired-icons-enabled -1)
-
-  ;; display icons with colors
-  (setq all-the-icons-dired-monochrome nil)
-
-  (defadvice! +dired-disable-icons-in-wdired-mode-a (&rest _)
-    :before #'wdired-change-to-wdired-mode
-    (setq-local +wdired-icons-enabled (if all-the-icons-dired-mode 1 -1))
-    (when all-the-icons-dired-mode
-      (all-the-icons-dired-mode -1)))
-
-  (defadvice! +dired-restore-icons-after-wdired-mode-a (&rest _)
-    :after #'wdired-change-to-dired-mode
-    (all-the-icons-dired-mode +wdired-icons-enabled)))
-
-
 (use-package! dired-x
-  :unless (modulep! +dirvish)
-  :unless (modulep! +ranger)
   :hook (dired-mode . dired-omit-mode)
   :config
   (setq dired-omit-verbose nil
@@ -211,37 +84,55 @@ we have to clean it up ourselves."
         "h" #'dired-omit-mode))
 
 
-(use-package! fd-dired
-  :when doom-projectile-fd-binary
-  :defer t
-  :init
-  (global-set-key [remap find-dired] #'fd-dired)
-  (set-popup-rule! "^\\*F\\(?:d\\|ind\\)\\*$" :ignore t))
-
 (use-package! dired-aux
   :defer t
   :config
   (setq dired-create-destination-dirs 'ask
         dired-vc-rename-file t))
 
-;;;###package dired-git-info
-(map! :after dired
-      :map (dired-mode-map ranger-mode-map)
-      :ng ")" #'dired-git-info-mode)
-(setq dgi-commit-message-format "%h %cs %s"
-      dgi-auto-hide-details-p nil)
-(after! wdired
-  ;; Temporarily disable `dired-git-info-mode' when entering wdired, due to
-  ;; reported incompatibilities.
-  (defvar +dired--git-info-p nil)
-  (defadvice! +dired--disable-git-info-a (&rest _)
-    :before #'wdired-change-to-wdired-mode
-    (setq +dired--git-info-p (bound-and-true-p dired-git-info-mode))
-    (when +dired--git-info-p
-      (dired-git-info-mode -1)))
-  (defadvice! +dired--reactivate-git-info-a (&rest _)
-    :after '(wdired-exit
-             wdired-abort-changes
-             wdired-finish-edit)
-    (when +dired--git-info-p
-      (dired-git-info-mode +1))))
+
+(use-package! diredfl
+  :hook (dired-mode . diredfl-mode)
+  :hook (dirvish-directory-view-mode . diredfl-mode))
+
+
+(use-package! dirvish
+  :defer t
+  :general (dired-mode-map "C-c C-r" #'dirvish-yank) ; for backward compatibility
+  :after-call dired-noselect dired dired-jump
+  :config
+  (dirvish-override-dired-mode)
+  (setq dirvish-cache-dir (concat doom-cache-dir "dirvish/"))
+  (set-popup-rule! "^ ?\\*Dirvish.*" :ignore t)
+  (map! :map dirvish-mode-map
+        :n  "?"   #'dirvish-dispatch
+        :n  "q"   #'dirvish-quit
+        :ng "a"   #'dirvish-quick-access
+        :ng "f"   #'dirvish-file-info-menu
+        :ng "y"   #'dirvish-yank-menu
+        :ng "s"   #'dirvish-quicksort
+        :ng "TAB" #'dirvish-subtree-toggle
+        :ng "M-t" #'dirvish-layout-toggle
+        :ng "M-b" #'dirvish-history-go-backward
+        :ng "M-f" #'dirvish-history-go-forward
+        :ng "M-n" #'dirvish-narrow
+        :ng "M-m" #'dirvish-mark-menu
+        :ng "M-s" #'dirvish-setup-menu
+        :ng "M-e" #'dirvish-emerge-menu)
+  (if (modulep! +dirvish)
+      (setq dirvish-attributes '(file-size collapse)
+            dirvish-mode-line-format
+            '(:left (sort file-time symlink) :right (omit yank index)))
+    (setq dirvish-attributes nil
+          dirvish-use-header-line nil
+          dirvish-mode-line-format nil
+          dirvish-hide-details nil
+          dirvish-hide-cursor nil))
+  (when (modulep! :ui tabs)
+    (after! centaur-tabs
+      (add-hook! 'dired-mode-hook 'centaur-tabs-local-mode)
+      (add-hook! 'dirvish-directory-view-mode-hook 'centaur-tabs-local-mode)))
+  (when (modulep! :ui vc-gutter)
+    (push 'vc-state dirvish-attributes))
+  (when (modulep! +icons)
+    (appendq! dirvish-attributes '(all-the-icons subtree-state))))
diff --git a/modules/emacs/dired/doctor.el b/modules/emacs/dired/doctor.el
index 2c2e77b29ab..3c0c77a8cfd 100644
--- a/modules/emacs/dired/doctor.el
+++ b/modules/emacs/dired/doctor.el
@@ -2,3 +2,6 @@
 
 (when (and IS-BSD (not (executable-find "gls")))
   (warn! "Cannot find gls (GNU ls). This may cause issues with dired"))
+
+(when (modulep! +ranger)
+  (warn! "The +ranger flag has been removed from this module"))
diff --git a/modules/emacs/dired/packages.el b/modules/emacs/dired/packages.el
index 06e5659a592..a3dfc11359c 100644
--- a/modules/emacs/dired/packages.el
+++ b/modules/emacs/dired/packages.el
@@ -1,14 +1,5 @@
 ;; -*- no-byte-compile: t; -*-
 ;;; emacs/dired/packages.el
 
-(package! diredfl :pin "f9140b2c42151dca669003d685c9f079b2e3dc37")
-(package! dired-git-info :pin "9461476a28a5fec0784260f6e318237c662c3430")
-(package! dired-rsync :pin "7940d9154d0a908693999b0e1ea351a6d365c93d")
-(when (modulep! +ranger)
-  (package! ranger :pin "2498519cb21dcd5791d240607a72a204d1761668"))
-(when (modulep! +dirvish)
-  (package! dirvish :pin "73dcaa404da9ab84d25f2919e6e3af4b1f8e7f37"))
-(when (and (modulep! +icons)
-           (not (modulep! +dirvish)))
-  (package! all-the-icons-dired :pin "5e9b097f9950cc9f86de922b07903a4e5fefc733"))
-(package! fd-dired :pin "458464771bb220b6eb87ccfd4c985c436e57dc7e")
+(package! diredfl :pin "62b559e1d6b69834a56a57eb1832ac6ad4d2e5d0")
+(package! dirvish :pin "22af07264007bdfced9f332d04053d9d93806289")
diff --git a/modules/ui/vc-gutter/config.el b/modules/ui/vc-gutter/config.el
index c555f9d08f7..006de3e3fc6 100644
--- a/modules/ui/vc-gutter/config.el
+++ b/modules/ui/vc-gutter/config.el
@@ -148,9 +148,10 @@ is deferred until the file is saved. Respects `git-gutter:disabled-modes'."
   :when (modulep! +diff-hl)
   :hook (find-file    . diff-hl-mode)
   :hook (vc-dir-mode  . diff-hl-dir-mode)
-  :hook (dired-mode   . diff-hl-dired-mode)
   :hook (diff-hl-mode . diff-hl-flydiff-mode)
   :config
+  (unless (modulep! :emacs dired)
+    (add-hook! 'dired-mode-hook #'diff-hl-dired-mode))
   (set-popup-rule! "^\\*diff-hl" :select nil :size '+popup-shrink-to-fit)
 
   ;; PERF: reduce load on remote
#+end_src
***** packaging doom WIP
Extremely WIP, basically just a scratchpad
****** first attempts
Had =:tangle (meta-in-dir "packaging-doom-wip-1.scm")=
#+begin_src scheme :tangle no
(define-module (phrenetic packaging-doom-wip)
  #:use-module (guix build-system trivial)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  ;; #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module (phrenetic packages emacs)
  #:use-module (phrenetic packages doom-emacs)
  )

;; (define doom-inputs
;;   (computed-file
;;    "doom-inputs"
;;    (with-imported-modules '((guix build utils))
;;      #~(begin
;;          (use-modules (guix build utils))
;;          (invoke (string-append #+doom-emacs:bin "/bin/doom") "help")
;;          (copy-file #$(local-file "nixpkgs-config.nix") #$output)
;;          ;; `emacs-substitute-sexps' might be useful here if my needs get more sophisticated.
;;          ;; (substitute* #$output
;;          ;;   (("(dunstctl|dunst)" all) (case (string->symbol all)
;;          ;;                               ((dunst) (string-append #$(file-append dunst "/bin/dunst")
;;          ;;                                                       " -config " #$(local-file "dunstrc")))
;;          ;;                               ((dunstctl) #$(file-append dunst "/bin/dunstctl"))))
;;          ;;   (("nm-applet") #$(file-append network-manager-applet "/bin/nm-applet"))
;;          ;;   (("pasystray") #$(file-append pasystray "/bin/pasystray"))
;;          ;;   (("redshift-gtk") (string-append #$redshift:gtk "/bin/redshift-gtk"))
;;          ;;   (("udiskie") #$(file-append udiskie "/bin/udiskie")))
;;          ))))


(define-public temp-doom-emacs
  (package
    (name "doom-emacs")
    (version "0")
    (source
     (local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t))
    (build-system (@ (guix build-system copy) copy-build-system))
    (synopsis "")
    (description "")
    (home-page "")
    (license #f)))

(define-public doom-inputs
  (package
    (name "doom-inputs")
    (version "0")
    (source #f)
    (inputs
     (list emacs-29-pgtk+native-comp
           ;; doom-emacs
           temp-doom-emacs
           ;; (local-file "doom-private" #:recursive? #t)
           git
           ;; (local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/straight.el" #:recursive? #t)
           ;; (local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/use-package" #:recursive? #t)
           ))
    (build-system trivial-build-system)
    (arguments
     `(#:modules ((guix build utils))
       #:builder
       ,#~(begin
            (use-modules (guix build utils))
            (let ((doom-private #$(local-file "doom-private" #:recursive? #t))
                  (doom-local-dir (string-append #$output "/doom-local")))
              (mkdir-p doom-local-dir)

              ;; (mkdir-p (string-append #$output "/asdf"))
              ;; (with-output-to-file (string-append #$output "/asdf/asdf.txt")
              ;;   (lambda _
              ;;     (display "asdffffffffffff")))

              (setenv "PATH" (string-append (getenv "PATH")
                                            ":" (assoc-ref %build-inputs "emacs-29-pgtk+native-comp") "/bin"
                                            ":" (assoc-ref %build-inputs "git") "/bin"
                                            ))
              ;; (setenv "DOOMDIR" (assoc-ref %build-inputs "doom-private"))
              (setenv "DOOMDIR" doom-private)
              (setenv "DOOMLOCALDIR" doom-local-dir)

              ;; (chdir #$output)
              ;; (invoke "git" "clone" "https://github.com/dracula/gtk")

              ;; (display "hi!")
              ;; (display doom-private)
              ;; (display straight-el)

              (let ((repos-dir (string-append doom-local-dir "/straight/repos")))
                (mkdir-p repos-dir)
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/straight.el" #:recursive? #t)
                         (string-append repos-dir "/straight.el"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/use-package" #:recursive? #t)
                         (string-append repos-dir "/use-package"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/melpa" #:recursive? #t)
                         (string-append repos-dir "/melpa"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/gnu-elpa-mirror" #:recursive? #t)
                         (string-append repos-dir "/gnu-elpa-mirror"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/el-get" #:recursive? #t)
                         (string-append repos-dir "/el-get"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/emacsmirror-mirror" #:recursive? #t)
                         (string-append repos-dir "/emacsmirror-mirror")))

              (setenv "HOME" "/tmp/asdfasdf")
              (mkdir-p "/tmp/asdfasdf")

              ;; (symlink #$(local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
              ;;            (string-append #$output "/temp-doom-emacs"))
              (let ((doom
                     ;; #$(local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
                     (assoc-ref %build-inputs "doom-emacs")
                     ;; (string-append #$output "/temp-doom-emacs")
                     ))
                ;; (invoke (string-append #$(@ (gnu packages base) coreutils) "/bin/echo") "asdfasdfsdf")
                ;; (invoke (string-append doom "/bin/doom") "help")
                (invoke (string-append doom "/bin/doom") "install" "--no-config" "--no-env" "--no-fonts" "--no-hooks")
                )

              ;; (copy-file #$(local-file "nixpkgs-config.nix") #$output)
              )


            #t)))

    ;; (arguments
    ;;  `(;; #:install-plan
    ;;    ;; '(("." "share/doom-emacs/"))
    ;;    ;; #:tests? #t
    ;;    ;; #:test-command '("./bin/doom" "test")
    ;;    #:phases
    ;;    ,#~(modify-phases %standard-phases
    ;;         (add-after 'install 'symlink-bin
    ;;           (lambda _
    ;;             (mkdir #$output:bin)
    ;;             (symlink (string-append #$output "/bin")
    ;;                      (string-append #$output:bin "/bin")))))))

    (synopsis "")
    (description "")
    (home-page "")
    (license #f)))





(use-modules ((guix packages) #:select (content-hash content-hash-algorithm content-hash-value)))

(define doom-build
  (computed-file
   "doom-build"
   (with-imported-modules '((guix build utils))
     #~(begin
         (use-modules (guix build utils))

         ;; (mkdir-p #$output)

         (setenv "GIT_SSL_NO_VERIFY" "true") ; do ssl if it's easy. Also if I'm using `(guix build git) git-fetch' consider if it setting this variable leaks out.

         ;; (invoke (string-append #+doom-emacs:bin "/bin/doom") "help")
         ;; (copy-file #$(local-file "nixpkgs-config.nix") #$output)
         ;; (invoke (string-append #$(@ (gnu packages wget) wget) "/bin/wget") "--no-check-certificate" "https://xkcd.com/")
         ;; (copy-file "index.html" #$output)

         ;; TODO Consider making e.g. emacs, git not ungexped in a let but instead everywhere they're used (and move this let outside of the gexp). Then I could use file-append instead of string-append in places I guess. Which is better practice?
         (let ((doom-private #+(file-union "doom-private"
                                           `(("init.el" ,(file-append (local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
                                                                      "/init.example.el"))
                                             ("config.el" ,(file-append (local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
                                                                        "/core/templates/config.example.el"))
                                             ("packages.el" ,(file-append (local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
                                                                          "/core/templates/packages.example.el")))))
               ;; (doom-private #$(local-file "doom-private" #:recursive? #t))
               (doom-local-dir (string-append #$output "/doom-local"))
               (emacs #+emacs-29-pgtk+native-comp)
               (git #+git)
               ;; (emacs (assoc-ref %build-inputs "emacs-29-pgtk+native-comp"))
               ;; (git (assoc-ref %build-inputs "git"))
               (doom-emacs #+temp-doom-emacs)
               ;; (doom-emacs #+doom-emacs)
               ;; (doom-emacs (assoc-ref %build-inputs "doom-emacs"))
               ;; (doom-emacs #$(local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t))
               )
           (mkdir-p doom-local-dir)

           (setenv "PATH" (string-append (getenv "PATH")
                                         ":" emacs "/bin"
                                         ":" git "/bin"
                                         ":" #+(@ (gnu packages base) coreutils) "/bin" ; donno if this is necessary
                                         ":" #+(@ (gnu packages base) sed) "/bin"
                                         ))
           ;; Is this a better/cleaner way to do path-setting? Consider also the comment (from git-download.scm), should I add more stuff to the path?
           ;;
           ;; The 'git submodule' commands expects Coreutils, sed,
           ;; grep, etc. to be in $PATH.
           ;; (set-path-environment-variable "PATH" '("bin")
           ;;                                (match '#+inputs
           ;;                                  (((names dirs outputs ...) ...)
           ;;                                   dirs)))

           (setenv "DOOMDIR" doom-private)
           (setenv "DOOMLOCALDIR" doom-local-dir)

           ;; (chdir #$output)
           ;; (invoke "git" "clone" "https://github.com/dracula/gtk")

           ;; donno if this is necessary
           (setenv "HOME" "/tmp/asdfasdf")
           (mkdir-p "/tmp/asdfasdf")

           ;; temporary straight.el experimentation
           ;; (mkdir-p "/tmp/asdfasdf/123456")
           (mkdir-p (string-append doom-local-dir "/straight/repos"))
           (symlink #+(local-file "/home/pharcosyle/work/dotfiles/straight.el" #:recursive? #t)
                    (string-append doom-local-dir "/straight/repos/straight.el"))

           ;; (copy-file #$(local-file "nixpkgs-config.nix") (string-append doom-local-dir "/asdf.txt"))
           ;; (invoke (string-append doom-emacs "/bin/doom") "help")
           (invoke (string-append doom-emacs "/bin/doom") "install" "--no-config" "--no-env" "--no-fonts" "--no-hooks")
           ;; (invoke (string-append doom-emacs "/bin/doom") "upgrade")
           ;; (invoke (string-append doom-emacs "/bin/doom") "build")
           ;; (invoke (string-append doom-emacs "/bin/doom") "sync")

           ;; (invoke (string-append emacs "/bin/emacs") "--batch" "--eval=\"(progn (load user-init-file) (straight-freeze-versions))\"")
           ;; (invoke (string-append emacs "/bin/emacs") "--batch" "--eval='(progn (message \"hello!\"))'")
           ;; (invoke "emacs" "--batch" "--eval='(message \"hello!\")'")
           ;; (chdir #$output)
           ;; (invoke "emacs" "--batch" "--eval='(with-temp-file \"asdf.txt\" (insert \"asdfasdf\"))'")
           ;; (invoke "emacs" "--batch" "--eval='(message \"hello!\")'")
           ;; (invoke "emacs" "--help")
           ;; (invoke "echo" (string-append (string-append emacs "/bin/emacs") "--batch" (string-append "--load=" doom-emacs "/init.el") "--eval=(progn (message \"hi\") (message \"yo\"))"))
           ;; (invoke (string-append emacs "/bin/emacs") "--batch" (string-append "--load=" doom-emacs "/init.el") "--eval=(progn (message \"hi\") (straight-freeze-versions) (message \"yo\"))")
           ;; (invoke "echo" "asdf")

           )))
   #:options (let ((ch (content-hash "1zcpkabkizadc3j9jqnnpyqm4d71bnvxz2x6as53f6wjwn82ahd9")))
               (list #:hash (content-hash-value ch)
                     #:hash-algo (content-hash-algorithm ch)
                     #:recursive? #t
                     ;; #:substitutable? #f ; This isn't appropriate, right?
                     ))))

;; (define-public doom-build-pkg
;;   (package
;;     (name "doom-build-pkg")
;;     (version "0")
;;     (source doom-build)
;;     (build-system (@ (guix build-system copy) copy-build-system))
;;     (synopsis "")
;;     (description "")
;;     (home-page "")
;;     (license #f)))
#+end_src
****** second attempt
Had =:tangle (meta-in-dir "packaging-wip-2.scm") :comments link=
#+begin_src scheme :tangle no
(define-module (phrenetic packaging-wip)
  ;; #:use-module (guix build-system trivial)
  ;; #:use-module (guix gexp)
  ;; #:use-module (guix git-download)
  ;; #:use-module (guix packages)
  ;; #:use-module ((guix licenses) #:prefix license:)
  ;; ;; #:use-module ((gnu packages emacs) #:select (emacs))
  ;; #:use-module ((gnu packages version-control) #:select (git))
  ;; #:use-module (phrenetic packages emacs)
  ;; #:use-module (phrenetic packages doom-emacs)

  #:use-module ((guix packages) #:select (package-input-rewriting))
  #:use-module ((gnu packages emacs) #:select (emacs emacs-minimal emacs-no-x emacs-next emacs-next-pgtk emacs-xwidgets emacs-no-x-toolkit emacs-wide-int))

  )
(define emacs-variant (@ (phrenetic packages emacs) emacs-29-pgtk+native-comp))

;; TODO does this rewrite recursively?
;; package-input-rewriting/spec says it specifically does this while package-input-rewriting does not. And what about using `package-mapping'? I can check the final product for references to emacs/emacs-minimal but still read over the source code of each later. What about native-inputs, sometimes emacs(-minimal) is in there.
;; TODO do I need to specify all of the different emacs packages for rewriting?
;; Does it work without doing this already? Would package-input-rewriting/spec handle them somehow? Does `package/inherit' (in both the -spec and non-spec versions)?
(define with-emacs-variant
  (package-input-rewriting `((,emacs . ,emacs-variant)
                             (,emacs-minimal . ,emacs-variant)
                             (,emacs-no-x . ,emacs-variant)

                             ;; TODO maybe ths should be in a nested `package-input-rewriting' or having packages with themselves as input rewrites
                             ;; will cause problems, I donno. Putting this here for now.
                             (,(@ (gnu packages emacs-xyz) emacs-dash) . ,(@ (phrenetic packages emacs-xyz) emacs-dash)))))

;; (define-public test-reftex
;;   (with-emacs-variant (@ (gnu packages emacs-xyz) emacs-company-reftex)))
;; (define-public test-dash-existing
;;   (with-emacs-variant (@ (gnu packages emacs-xyz) emacs-dash)))
;; (define-public test-dash
;;   (with-emacs-variant (@ (phrenetic packages emacs-xyz) emacs-dash)))

;; (define orig-pkg (@ (gnu packages emacs-xyz) emacs-build-farm))
;; (define orig-pkg (@ (gnu packages emacs-xyz) emacs-cider))
(define orig-pkg (@ (gnu packages emacs-xyz) emacs-buttercup))

(define-public test-pkg
  (with-emacs-variant orig-pkg))





(use-modules (guix packages)
             (guix git-download))

(define (git-origin url commit hash recursive?)
  (origin
    (method git-fetch)
    (uri (git-reference
          (url url)
          (commit commit)
          (recursive? recursive?)))
    (sha256
     (base32
      hash))))



(use-modules (gnu packages)
             (guix profiles)
             ;; ((srfi srfi-1) #:select (remove))
             ;; (phrenetic utils)
             )

;; (define (doom-ps)
;;   (->> (call-with-input-file "../doom-packaging/guix-doom-emacs-packages-from-straight-build-cache.txt" read)
;;        (remove
;;         (lambda (dpns)
;;           (member dpns (list "donnager"

;;                              "straight"

;;                              ;; TODO built-in, ignoring for now but handle this when grabbing from ~doom-packages~. It marks them as ~:ignored t~
;;                              ;; - but what about built-in 'prefer, this isn't marked specially
;;                              "hideshow"
;;                              "vc"
;;                              "vc-annotate"
;;                              "smerge-mode"
;;                              "elisp-mode"
;;                              "css-mode"

;;                              "org-elpa"
;;                              "melpa"
;;                              "gnu-elpa-mirror"
;;                              "el-get"
;;                              "emacsmirror-mirror"
;;                              ))))))

(define (emacs-ps)
  (map (lambda (x)
         (string-append "emacs-" x))
       (doom-ps)))

;; (display
;;  (map (lambda (x)
;;         (find-best-packages-by-name x #f))
;;       (emacs-ps)))

;; (display
;;  (->> (emacs-ps)
;;       (map (lambda (x)
;;              (let ((found (find-best-packages-by-name x #f)))
;;                (if (null? found)
;;                  x '()))))
;;       (remove null?)))

(use-modules (gnu packages emacs-xyz)
             (phrenetic packages emacs-xyz)
             ;; (phrenetic packages emacs-xyz-batch)
             )

(define (str->pkg x)
  (primitive-eval
   (string->symbol
    (if (equal? "emacs-git-modes" x)
        "git-modes"
        x))))

;; (let ((the-manifest
;;        (packages->manifest
;;         (map str->pkg (emacs-ps)))))
;;   ;; (display the-manifest)
;;   #f)






(use-modules ((guix base32) #:select (bytevector->nix-base32-string))
             ((guix build git) #:select (git-fetch) #:prefix other:)
             (guix build utils)
             ((guix hash) #:select (file-hash*)))

(define* (git-checkout-hash url commit #:key recursive?)
  (let ((dir (string-append "/tmp" "/8888")))
    (when (file-exists? dir)
      (delete-file-recursively dir))
    (if (other:git-fetch url commit dir
                         #:recursive? recursive?
                         ;; #:git-command (string-append #+git "/bin/git")
                         )
        (let ((hash (bytevector->nix-base32-string (file-hash* dir))))
          (delete-file-recursively dir)
          hash)
        #f)))


(define (test-get-hash)
  (display
   (git-checkout-hash
    "https://github.com/emacs-evil/evil-surround"
    "282a975bda83310d20a2c536ac3cf95d2bf188a5"
    #:recursive? #t)))

;; (test-get-hash)


(define* (find-hash doom-pkg p commit #:key recursive?)
  (let ((hasher (lambda (url)
                  (git-checkout-hash url commit #:recursive? recursive?))))
    (as-> hasher $
          ($ (if (equal? (-> p package-source origin-method) git-fetch)
                 (-> p
                     package-source
                     origin-uri
                     git-reference-url)
                 (string-append "https://github.com/emacs-straight/" doom-pkg)))
          (if $ $ "NONE_FOUND"))))

;; TODO later: maybe don't look for hashes if the requested commit is already in the Guix package
;; - and maybe if the hashes turn out to be the same after doing `git-checkout-hash', presumably
;; because the Guix package had a git tag or something but it ended up being the same as the
;; Doom-requested commit, don't save the hash? Meh.
;; TODO maybe don't write out the hashes file
;; Just cache the results somehow in the guix store so hash generation can be run as-needed
(define (hashes ps)
  (let ((commits (call-with-input-file "../doom-packaging/straight-commits.txt" read)))
    (map
     (lambda (doom-pkg)
       (let* ((p (str->pkg (string-append "emacs-" doom-pkg)))
              (commit (assoc-ref commits doom-pkg))
              (hash (find-hash doom-pkg p commit #:recursive? #t)))
         (kvm #:package doom-pkg
              #:commit commit
              #:hash hash)))
     ps)))

(define (spit f content)
  (call-with-output-file f
    (lambda (port)
      (write content port))))

;; (define write-hashes (partial spit "../doom-packaging/hashes.txt"))

;; (write-hashes
;;  (hashes (list "restart-emacs" "smartparens")))
;; (write-hashes (doom-ps))
#+end_src
****** active WIP
******* clojure part
******** clj file
I had =:tangle phrenetic/src/protostar/hickeyland.clj :comments link= for the source block options here.
#+begin_src clojure :tangle no
(ns protostar.hickeyland
  (:require [clojure.alpha.spec :as s]
            [clojure.edn :as edn]
            [clojure.java.io :as io]
            [clojure.string :as str]))

;; TODO At end: just maybe try doing this, slurp, any anything else impure as some sort of "coeffects"
(defn- file-exists? [f]
  (.exists (io/file f)))


(s/defop nospec [_]
  any?)



(s/def ::str->edn (s/conformer edn/read-string)) ; TODO donno if I want to use this or just do it in clojure code (is that more idiomatic then writing a spec/conformer for everything?)


(s/def :char/blank #{\space \tab})
;; (s/def :char/newline #{\newline}) ; TODO remvoe if not needed

(s/def ::text->lines (s/conformer str/split-lines)) ; TODO donno if I want to use this or just do it in clojure code (is that more idiomatic then writing a spec/conformer for everything?)

(s/def ::str->chars (s/conformer seq))
(s/def ::chars->str (s/conformer (partial apply str)))



;; TODO would this be better / more flexible if I made it check validity (`valid?`) and then did conforming in a separate step?
;; TODO s/defop works currently but might not be the idiomatic way to do this
(s/defop s-filter [spec]
  (s/conformer
   (fn [xs]
     (keep (fn [x]
             (let [conformed (s/conform spec x)]
               (when-not (s/invalid? conformed)
                 conformed)))
           xs))))


(s/def :elisp/form any?)
(s/def :elisp/t #{t})
(s/def :elisp/list->car (s/conformer first)) ; TODO remove if not needed
(s/def :elisp/list->cdr (s/conformer next)) ; TODO remove if not needed
(s/def :elisp/plist->map (s/conformer (partial apply hash-map))) ; TODO remove if not needed
(s/def :elisp/nil-or-non-nil :elisp/form) ; TODO think this (perhaps just the name) through more?


(s/def :epkg.dep/name symbol?)
(s/def :epkg.dep/version (nospec string?))
(s/def :epkg.dep/name+ver (s/cat :name :epkg.dep/name
                                 :_version (s/? (nospec :epkg.dep/version))))
(s/def :epkg.dep/name+ver->name
  (s/conformer (fn [[form x]]
                 (case form
                   :name x
                   :name+ver (:name x)))))
(s/def :epkg/dep (s/or :name :epkg.dep/name
                       :name+ver :epkg.dep/name+ver))

(s/def :epkg/deps (s/coll-of :epkg/dep))
(s/def :epkg/deps->name-strs
  (s/coll-of (s/and
              :epkg.dep/name+ver->name
              (s/conformer str))))

;; Testing
;; (def test-deps '((emacs "24.1") another (seq) (cl-lib "0.5")))
;; (s/valid? :epkg/deps test-deps)
;; (s/explain-str :epkg/deps test-deps)
;; (s/conform :epkg/deps test-deps)
;; (s/conform
;;  (s/and
;;   :epkg/deps
;;   :epkg/deps->name-strs)
;;  test-deps)

;; TODO ideally do this better / more flexibly / maybe faster
(s/def :epkg.simple/req-header-name
  (s/&
   (s/+ char?)
   ::chars->str
   #(= "Package-Requires:" %))) ; TODO (if keeping things this way) could this just be a literal set predicate?

(s/def :epkg.simple/req-header-line
  (s/and
   ::str->chars
   (s/cat :_comment (s/&
                     (s/+ #{\;})
                     ::chars->str)
          :_ws (s/&
                (s/* :char/blank)
                ::chars->str)
          :_req-header :epkg.simple/req-header
          :_ws2 (s/&
                 (s/* :char/blank)
                 ::chars->str)
          :deps (s/&
                 (s/* char?)
                 ::chars->str
                 ::str->edn
                 :epkg/deps))))

(s/def :epkg.simple/reqs
  (s/and
   ::text->lines
   (s-filter :epkg.simple/req-header-line)
   ;; TODO spec that there should be exactly :count 1?
   (s/conformer first)
   ;; TODO what was I trying here?
   ;; (s/conformer (fn [xs]
   ;;                (or (first xs) :clojure.alpha.spec/invalid)))
   ))

;; Testing
;; (def test-pkgrequires-line ";; Package-Requires: ((emacs \"24.1\") (cl-lib \"0.5\"))")
;; (s/conform :epkg.simple/reqs (str "asdf\n" test-pkgrequires-line))
;; (s/explain-str :epkg.simple/reqs test-pkgrequires-line)

(s/def :epkg.multifile/reqs
  (s/cat :_define-package #{define-package}
         :_name (nospec string?)
         :_version (nospec :epkg.dep/version)
         :_docstring (s/? (nospec string?))
         :requirements (s/? (s/cat
                             :quote #(= (symbol (str \')) %) ; "Artifact" of `edn/read-string`.
                             :form :epkg/deps))
         :_extra (s/* (nospec nil))))

;; Testing
;; (s/conform :epkg.multifile/reqs {:pname "magit" :dir "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp"})
;; (s/conform :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp/magit-pkg.el")))
;; (s/explain-str :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp/magit-pkg.el")))
;; (s/conform :epkg.multifile/reqs "asdf")
;; (s/conform :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/drag-stuff.el/drag-stuff-pkg.el")))

;; TODO Might not need to test if file-exists for simple packages, is there always a packagename.el file? Or should always be one if there's no -pkg.el so its find to have it as a fallthrough case?
;; TODO maybe do coeffects if it's easy
;; Maybe see my now-deleted cofx attempts
(s/def :epkg/reqs->deps
  (s/or :multifile
        (s/and
         (s/conformer
          (fn [{:keys [pname dir]}]
            (let [f (str dir "/" pname "-pkg.el")]
              (if (file-exists? f)
                (-> f slurp edn/read-string)
                :clojure.alpha.spec/invalid))))
         :epkg.multifile/reqs
         (s/conformer #(get-in % [:requirements :form])))
        :simple
        (s/and
         (s/conformer
          (fn [{:keys [pname dir]}]
            (let [f (str dir "/" pname ".el")]
              (if (file-exists? f)
                (-> f slurp edn/read-string)
                :clojure.alpha.spec/invalid))))
         :epkg.simple/reqs
         (s/conformer :deps))))

(defn epkg-dependencies [name dir]
  (let [deps
        (s/conform
         (s/and
          :epkg/reqs->deps
          (s/conformer (fn [[_ reqs]] reqs))
          :epkg/deps->name-strs)
         {:pname name :dir dir})]
    (when-not (s/invalid? deps)
      deps)))

;; Testing
;; (epkg-dependencies "magit" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp")
;; (println (epkg-dependencies "dash" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/dash"))
;; (println (epkg-dependencies "helpful" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/helpful"))
;; (println (epkg-dependencies "evil" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/evil"))
;; (println (epkg-dependencies "drag-stuff" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/drag-stuff.el"))
;; (println (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/evil/evil-pkg.el"))




(s/def ::forge-repo
  (s/and
   ::str->chars
   (s/cat :user-name (s/&
                      (s/+ char?)
                      ::chars->str)
          :slash #{\/}
          :repo-name (s/&
                      (s/+ char?)
                      ::chars->str))))

(s/def ::glob string?)

(s/def ::recipe-subdirective
  (s/alt :subdir string?
         :exclude #{:exclude}))

(s/def ::recipe-defaults #{:defaults})




; TODO better sha and ref specs
(s/def :git/sha string?)
(s/def :git/ref string?)

(s/def :melpa.recipe.files/element
  (s/alt :glob ::glob
         :sublist (s/nest
                   (s/cat :subdirective ::recipe-subdirective
                          :elements (s/+ :melpa.recipe.files/element)))))
(s/def :melpa.recipe/files
  (s/cat
   :defaults (s/? ::recipe-defaults)
   :elements (s/* :melpa.recipe.files/element)))

(s/def :melpa.recipe/name symbol?)
(s/def :melpa.recipe/fetcher #{git hg github gitlab})
(s/def :melpa.recipe.vc/url string?)
(s/def :melpa.recipe.forge/repo ::forge-repo)
;; TODO nb: "commit" is used only once in all of the melpa recipes. Do doom/straight even consider it?
(s/def :melpa.recipe.git/commit (s/or :git/sha
                                      :git/ref))
(s/def :melpa.recipe.git/branch string?) ; TODO do better spec? It can be a git or hg branch, right?
;; -- originial position of :melpa.recipe/files before I moved it up --
;; TODO nb: ignoring :version-regexp and :old-names, I don't care about them, right (straight doesn't seem to)? And I'm excluding from even this validation spec stuff I don't care about, right? Or just maybe spec them but do a `s/select` that doesn't include them (or use `nospec`)? Remember to add them to :melpa.recipe/schema.

(s/def :melpa.recipe/props
  (s/schema {;; :melpa.recipe/name
             :fetcher :melpa.recipe/fetcher
             :files :melpa.recipe/files}))

(s/def :melpa.recipe/vc-props
  (s/schema {:url :melpa.recipe.vc/url}))

(s/def :melpa.recipe/forge-props
  (s/schema {:repo :melpa.recipe.forge/repo}))

(s/def :melpa.recipe/git-props
  (s/schema {:commit :melpa.recipe.git/commit
             :branch :melpa.recipe.git/branch}))

(defmulti melpa-recipe-fetcher :fetcher)

(defmethod melpa-recipe-fetcher 'git [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/vc-props
            :melpa.recipe/git-props)
   [:url]))
(defmethod melpa-recipe-fetcher 'hg [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/vc-props)
   [:url]))
(defmethod melpa-recipe-fetcher 'github [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/forge-props
            :melpa.recipe/git-props)
   [:repo]))
(defmethod melpa-recipe-fetcher 'gitlab [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/forge-props
            :melpa.recipe/git-props)
   [:repo]))

(s/def :melpa/recipe
  (s/cat
   :name (nospec :melpa.recipe/name)
   :props
   (s/&
    (s/* :elisp/form)
    #(even? (count %))
    :elisp/plist->map
    (s/multi-spec melpa-recipe-fetcher :fetcher))))

;; Testing
;; (def test-melpa-recipe '(yasnippet :repo "joaotavora/yasnippet"
;;                                    :fetcher github
;;                                    :files ("yasnippet.el" "snippets")))
;; (s/conform :melpa/recipe test-melpa-recipe)
;; (s/explain-str :melpa/recipe test-melpa-recipe)



(s/def :straight.recipe-repo/name symbol?)

(s/def :straight.recipe/name symbol?) ; Maybe spec this so I can accept the argument to `straight-use-package` (for other users who use straight): doom doesn't take this just the rest of the recipe plist. Update: also need it for :includes.
(s/def :straight.recipe/local-repo string?)
;; TODO maybe some of the sub-stuff in :straight.recipe/files should be `nospec` or have leading keywork underscores.
(s/def :straight.recipe/files
  (s/*
   (s/alt :glob ::glob
          :pair (s/cat :car string?
                       :dot #{.}
                       :cdr string?)
          :sublist (s/nest
                    (s/cat :subdirective ::recipe-subdirective
                           :elements (s/+ :straight.recipe/files)))
          :defaults ::recipe-defaults)))
(s/def :straight.recipe/flavor #{melpa})
(s/def :straight.recipe/build any?) ; TODO. Had #{nil t}, it would be better to use :elisp/t but set specs take literal, not spec, values
(s/def :straight.recipe/pre-build any?) ; TODO
(s/def :straight.recipe/post-build any?) ; TODO
(s/def :straight.recipe/type #{git built-in})
(s/def :straight.recipe/source (s/or :one :straight.recipe-repo/name
                                     :many (s/coll-of :straight.recipe-repo/name)))
(s/def :straight.recipe/includes (s/or :one :straight.recipe/name
                                       :many (s/coll-of :straight.recipe/name)))
(s/def :straight.recipe/inherit :elisp/nil-or-non-nil)
(s/def :straight.recipe.git/host #{nil github gitlab bitbucket})
(s/def :straight.recipe.git/branch string?)
(s/def :straight.recipe.git/remote string?)
(s/def :straight.recipe.git/nonrecursive :elisp/nil-or-non-nil)
(s/def :straight.recipe.git/fork any?) ; TODO
(s/def :straight.recipe.git/depth (s/or :full #{full}
                                        :n integer?))
(s/def :straight.recipe.git/protocol #{https ssh})
(s/def :straight.recipe.git/upstream any?) ; TODO


(s/def :straight.recipe/props
  (s/schema {;; :straight.recipe/name
             :local-repo :straight.recipe/local-repo
             :files :straight.recipe/files
             :flavor :straight.recipe/flavor
             :build :straight.recipe/build
             :pre-build :straight.recipe/pre-build
             :post-build :straight.recipe/post-build
             :type :straight.recipe/type
             :source :straight.recipe/source
             :includes :straight.recipe/includes
             :inherit :straight.recipe/inherit}))

(s/def :straight.recipe/git-props
  (s/schema {;; :repo :straight.recipe.git/repo
             :host :straight.recipe.git/host
             :branch :straight.recipe.git/branch
             :remote :straight.recipe.git/remote
             :nonrecursive :straight.recipe.git/nonrecursive
             :fork :straight.recipe.git/fork
             :depth :straight.recipe.git/depth
             :protocol :straight.recipe.git/protocol
             :upstream :straight.recipe.git/upstream}))


(s/def :straight/repository-url string?)

(defmulti straight-recipe-git-host :host)

(defmethod straight-recipe-git-host nil [_]
  (s/select {:repo :straight/repository-url} [:repo]))
(defmethod straight-recipe-git-host 'github [_]
  (s/select {:repo ::forge-repo} [:repo]))
(defmethod straight-recipe-git-host 'gitlab [_]
  (s/select {:repo ::forge-repo} [:repo]))
(defmethod straight-recipe-git-host 'bitbucket [_]
  (s/select {:repo ::forge-repo} [:repo]))


(def straight-default-vc 'git)

(defmulti straight-recipe-type #(get % :type straight-default-vc))

(defmethod straight-recipe-type 'git [_]
  (s/and
   (s/union :straight.recipe/props
            :straight.recipe/git-props)
   (s/multi-spec straight-recipe-git-host :host)))
(defmethod straight-recipe-type 'built-in [_]
  (s/schema {}))


(s/def :straight.recipe/props-asdf
  (s/&
   (s/* :elisp/form)
   #(even? (count %))
   :elisp/plist->map
   (s/multi-spec straight-recipe-type :type)))

;; TODO I don't think I need this for anything
(s/def :straight/recipe
  (s/cat
   :name (nospec :straight.recipe/name)
   :props :straight.recipe/props-asdf))


(s/def :doom.package/name symbol?)
(s/def :doom.package/type #{core local built-in virtual}) ; Depending on where I'm doing "checking for stuff I explicitly don't support" either remove local/built-in/(maybe)virtual here or check for them elsewhere
(s/def :doom.package/recipe :straight.recipe/props-asdf)
(s/def :doom.package/disable :elisp/t)
(s/def :doom.package/ignore :elisp/t)
(s/def :doom.package/pin :git/sha)
;; TODO nb: not speccing :modules (for now?)

(s/def :doom.package/props
  (s/schema {:type :doom.package/type
             :recipe :doom.package/recipe
             :disable :doom.package/disable
             :ignore :doom.package/ignore
             :pin :doom.package/pin}))

(s/def :doom/package
  (s/cat
   :name :doom.package/name
   :props
   (s/&
    (s/* :elisp/form)
    #(even? (count %))
    :elisp/plist->map
    :doom.package/props)))


#_(defn parse-doom-packages []
  (as-> (slurp "/home/pharcosyle/work/phrenetic/doom-packaging/my-doom-packages.el") $
    (edn/read-string $)
    (map parse-doom-package $)
    ;; TODO later: this is Doom-specific, move it out of the main "guix-emacs-generator"
    (remove #(= (:package/name %) "straight") $)
    (remove :package/deactivated? $)))



(s/def ::todo any?)

;; (s/def :fex.repo/user-name ::todo)
;; (s/def :fex.repo/repo-name ::todo)
;; (s/def :fex/repo
;;   (s/schema [:fex.repo/user-name
;;              :fex.repo/repo-name]))

(s/def :fex.package/url ::todo)
;; (s/def :fex.package/forge #{:forge/github
;;                             :forge/gitlab
;;                             ;; :forge/bitbucket
;;                             })
;; (s/def :fex.package.forge/repo :fex/repo) ; TODO maybe just use :fex/repo or ::forge-repo (and make the current ::forge-repo be ::forge-repo-str or something)
(s/def :fex.package/branch ::todo)
(s/def :fex.package/nonrecursive? #{true})
(s/def :fex.package/files :melpa.recipe/files) ; TODO This is "inheritance", maybe make this a "shared" spec like ::recipe-defaults or just allow :melpa.recipe/files as a key in :fex/package (maybe even rename it to ::melpa-style-files or something)

(s/def :fex/package
  (s/schema [:fex.package/url
             ;; :fex.package/forge
             ;; :fex.package.forge/repo
             :fex.package/branch
             :fex.package/nonrecursive?
             :fex.package/files]))





(def ^:private forge-domains
  {'github "github.com"
   'gitlab "gitlab.com"
   'bitbucket "bitbucket.com"})

(defn forge-repo-url [forge user-name repo-name]
  (str "https://" (get forge-domains forge) "/" user-name "/" repo-name ".git"))


(require '[clojure.set :refer [rename-keys]])
(defn select-and-rename-keys [m kmap]
  (as-> m $
    (select-keys $ (keys kmap))
    (rename-keys $ kmap)))






(defmacro defkmultis [& methods]
  (let [create (fn [name]
                 `(defmulti ~name ~(fn [k & _] k)))]
    `(do
       ~@(map create methods))))

(defmacro defkmethods [k & methods]
  (let [register
        (fn [[name argslist & body]]
          `(defmethod ~name ~k ~(vec (cons '_ argslist)) ~@body))]
    `(do
       ~@(map register methods))))





;; Archives
(defkmultis
  ;; has-recipe
  get-recipe) ; TODO maybe rename this get-package or something, I'm returning fex packages, not straight/melpa recipes


(defn gnu-elpa-mirror-recipe-filename [p]
  (str "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/gnu-elpa-mirror" "/" p))

(defkmethods
  :archive/gnu-elpa-mirror
  (get-recipe [p] (let [f (gnu-elpa-mirror-recipe-filename p)]
                    ;; TODO straight checks against straight-recipes-gnu-elpa-ignored-packages for this archive, I might need to do that too. There are other notes on this already.
                    (when (file-exists? f)
                      {:fex.package/url (forge-repo-url
                                         (symbol :github) "emacs-straight" p)
                       :fex.package/files {:elements [[:glob "*"]]}})))) ; TODO straight also has ~(:exclude ".git")~ here but I don't think I need that.

(defn melpa-recipe-filename [p]
  (str "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/melpa/recipes" "/" p))

(defkmethods
  :archive/melpa
  ;; (has-recipe [p] (file-exists? (melpa-recipe-filename p)))
  (get-recipe [p] (let [f (melpa-recipe-filename p)]
                    (when (file-exists? f)
                      (let [text (slurp f)
                            parsed
                            (s/conform (s/and
                                        ::str->edn
                                        :melpa/recipe
                                        (s/conformer :props))
                                       text)]
                        ;; TODO check that `parsed` is not invalid?
                        ;; TODO "supported"-ness: this might be the place to check that the melpa recipe fetcher isn't 'hg. Alternatively, or perhaps preferably (it would match straight's behavior) just report there's no package if the fetcher is 'hg (or isn't 'git, 'github, or 'gitlab)
                        ;; TODO additional things straight does for this archive: adds -pkg.el to :files and sets flavor to melpa. Donno if I need these. There are other todos/notes on these already
                        (merge
                         {:fex.package/url (let [fetcher (:fetcher parsed)]
                                             (condp some #{fetcher}
                                               #{'git} (:url parsed)
                                               #{'github 'gitlab} (let [repo (:repo parsed)]
                                                                    (forge-repo-url
                                                                     fetcher
                                                                     (:user-name repo)
                                                                     (:repo-name repo)))))}
                         (select-and-rename-keys
                          parsed {:branch :fex.package/branch
                                  :files :fex.package/files})
                         ;; TODO not using, remove
                         ;; (when-let [files (:files parsed)]
                         ;;   {:fex.package/files (s/unform :melpa.recipe/files files)})
                         ))))))

;; Testing
;; (get-recipe :archive/melpa "yasnippet")

;; TODO I don't think the lisp/* bits are necessary since these already have :defaults but for now I've copied the :files over just like they are in straight.
(defkmethods
  :archive/org-elpa
  (get-recipe [p] (case p
                    "org"
                    {:fex.package/url "https://git.savannah.gnu.org/git/emacs/org-mode.git"
                     :fex.package/files {:defaults :defaults
                                         :elements [[:glob "lisp/*.el"]
                                                    [:sublist
                                                     {:subdirective [:subdir "etc/styles/"]
                                                      :elements [[:glob "etc/styles/*"]]}]]}}
                    "org-contrib"
                    {:fex.package/url "https://git.sr.ht/~bzg/org-contrib"
                     :fex.package/files {:defaults :defaults
                                         :elements [[:glob "lisp/*.el"]]}}
                    nil)))


;; TODO make this configurable (of course) and probably not global (pass it as an argument to functions that use it)
(def archives [:archive/org-elpa
               :archive/melpa
               :archive/gnu-elpa-mirror])

;; TODO probably add emacsmirror, etc archives but make all of the methods throw an exception stating that they're not implemented "yet".
;; (def archive-priority [:archive/org-elpa
;;                        :archive/melpa
;;                        :archive/gnu-elpa-mirror])

;; TODO maybe a way to get these from Doom programatically is to advise `straight-use-recipes` but then I'd have to run `doom--ensure-straight` as well
;; (def doom-recipe-repos
;;   '((org-elpa :local-repo nil)
;;     (melpa              :type git :host github
;;                         :repo "melpa/melpa"
;;                         :build nil)
;;     (gnu-elpa-mirror    :type git :host github
;;                         :repo "emacs-straight/gnu-elpa-mirror"
;;                         :build nil)
;;     (el-get             :type git :host github
;;                         :repo "dimitri/el-get"
;;                         :build nil)
;;     (emacsmirror-mirror :type git :host github
;;                         :repo "emacs-straight/emacsmirror-mirror"
;;                         :build nil)))
;; (def doom-straight-recipe-repositories
;;   '(org-elpa melpa gnu-elpa-mirror el-get emacsmirror-mirror))




(require '[clojure.java.shell :refer [sh]])
(def eb-dir "/home/pharcosyle/work/phrenetic/phrenetic")
(def guix-repl-cmd ["guix" "repl" "-L" "." "--" "phrenetic/packaging-runner.scm"])
(defn sh-call [f & args]
  (apply sh (concat guix-repl-cmd
                    [(name f)]
                    (map pr-str args)
                    [:dir eb-dir])))
;; (sh-call :guix/asdf 6)
(def get-origin-data (partial sh-call :guix/get-origin-data))







(defn get-archive-package [archives package-name]
  (first (map #(get-recipe % package-name) archives)))

(defn package-with-inheritance [package-name package]
  (merge
   (get-archive-package package-name)
   package))






(defn convert-straight-recipe-props-to-package [props]
  (let [; parsed (s/conform :straight.recipe/props-asdf props)
        parsed props]
    ;; TODO check that `parsed` is not invalid?
    ;; TODO "supported"-ness: is this the place to check that there aren't unsupported keys and provided keys have supported values (including that the :files is a valid /melpa/ :files)?
    (merge
     {:fex.package/url
      (let [{:keys [host repo]} parsed]
        (if host
          (forge-repo-url
           host
           (:user-name repo)
           (:repo-name repo))
          repo))}
     (select-and-rename-keys
      parsed {:branch :fex.package/branch})
     (when (:nonrecursive parsed)
       {:fex.package/nonrecursive? true})
     (when-let [files (:files parsed)]
       ;; TODO donno why I want to do it this convoluted way, maybe because I don't want to use the "raw" props?
       {:fex.package/files
        ;; (s/conform :melpa.recipe/files props)
        (->> files
             (s/unform :straight.recipe/files)
             (s/conform :melpa.recipe/files))}))))




;; (def my-doom-packages-test "/home/pharcosyle/work/phrenetic/doom-packaging/my-doom-packages.el")
;; (def my-doom-packages-test "/home/pharcosyle/work/phrenetic/doom-packaging/my-doom-packages-edited.el")
(def my-doom-packages-test "/home/pharcosyle/work/phrenetic/doom-packaging/my-doom-packages-small.el")

(defn test-packages []
  (let [data (-> my-doom-packages-test
                 slurp
                 edn/read-string)
        conformed (s/conform (s/coll-of :doom/package) data)]
    ;; (s/explain (s/coll-of :doom/package) data)
    (as-> conformed $
      (map #(get-in % [:props :recipe]) $)
      (map convert-straight-recipe-props-to-package $))))

;; (test-packages)





(def straight-allow-recipe-inheritance? true)

;; TODO Ideally I think I want to grab any pertinent straight settings from Doom Emacs
;; By serializing them "in the same run" as when I grab e.g `doom-packages`. Update: but wait I won't have straight installed when I do this, perhaps scrape the straight code for sexps or maybe it'll be enough to just get the ones that Doom sets itself (see core-packages.el line 78-97)
;; - default protocol, allow inheritance, the recipe repos Doom sets up, etc
;; - straight-default-vc
;; - look through straight's ~defcustom~s
(def defaults {:recipe/protocol "https"})
;; maybe?:
;; :files '("*.el" "*.el.in" "dir"
;;          "*.info" "*.texi" "*.texinfo"
;;          "doc/dir" "doc/*.info" "doc/*.texi" "doc/*.texinfo" "lisp/*.el"
;;          (:exclude ".dir-locals.el" "test.el" "tests.el" "*-test.el" "*-tests.el")

;; TODO regarding :flavor: read `straight-expand-files-directive' and see if I need this / what I should do about :files. Also read the melpa readme about the rules it has for expanding its :files property
;; - :melpa/recipe shouldn't have a flavor, right? Just straight recipes?
;; - new thoughts
;;   - I might need it to make sure template files are copied over "before build", does that make sense I can't be fucked to think through the ordering at present
;;   - If I do need to consider .el.in files perhaps I can prepreocess the :fex.package/files returned from the melpa archive (but that might not be feasable, the .el.in logic is deep in the melpa/straight files expansion logic)
;;   - The Guix elpa importer doesn't even consider .el.in files, maybe they're super rare
;;   - nb: straight recipe inheritance logic includes :flavor and I'm not presently doing that
;;   - reconcile the Guix elpa importer's file expansion logc with melpa's to make sure it's thorough (not straight's, it's different, but do look it over afterwards anyway)
;; TODO downloading to a cache like the elpa importer does would speed up successive/reattempted runs, no?
;; - assuming that is what it's doing (check). Do those repo caches stick around forever though? Will adding my own interfere with anything?
;; - if it's /really/ fast maybe I could get rid of the later-to-come bump "scripts"'s need to read an existing list of generated packges at all! I wouldn't even have to save it to disk, just the lockfile!
;;   - even if the guix git repositories cache thing is untenable maybe there's some other cache I could write the repos or the generated packages-with-hashes to, even just ~./cache. I'd like to not have to manage a generated packages file if I don't have to
;; TODO handle :host: search "bitbucket" in straight to see stuff that affects hosts. If necessary add a check to make sure a supported host is provided.
;; TODO use value of `straight-built-in-pseudo-packages' (let-alist emacs nadvice python) in addition to elpa.scm's `emacs-standard-library?'? What about `straight-recipes-gnu-elpa-ignored-packages'? What about straight--package-built-in-p and package--builtins (read its doc)?
;; - Straight claims to be able to "deal with built-in packages" even without this variable. How? Something like hlissner does when :built-in is set to 'prefer? Use one
;;   of these approaches instead of making a (brittle) list of built-in pseudo packages?
;; - Remember, sometimes even if a package is built-in it should still be installed (like org)
;; - unrelated: are there any built-in dependencies with newer upstream/external versions? Do I want them?
;;   Perhaps not even proper versions just newer commits in a git repo
;; TODO always include *pkg.el like straight.el::3168 says?
;; Is that just about making sure that dependencies get resolved? It says "linked over" though. But then why wouldn't the other `straight-recipes-REPO-retrieve' methods have it? For
;; the elpa one at least it could be because it includes everything (=:files "*"=)
;; - also see the github melpa readme: "For multi-file packages, the file <NAME>-pkg.el is automatically generated..."
;; - update: shit is the /built/ package (after the :files directive has been "applied", among other things) used for determining dependencies? That's the way straight does it, I was just going to use the "raw" cloned repo to find dependencies. Note that e.g. ghub, magit-secion have their -pkg.el files in a subfolder so assuming -pkg.el lives in the root of the unbuilt repo isn't going to work the way I have it now. Conceivably the same could be true of a regular packagename.el file: it could be in a subdirectory.
;;   - I'll probably have to build the package before I get dependencies like straight does. Is there anything else about building the package, besides doing the :files copying/linking, that could affect the packagename.el and packagename-pkg.el files and thus dependency resolution?
;; TODO do I actually need :includes / consider the org-elpa pseudo repository (look at straight-recipes-org-elpa-retrieve in particular)
;; I think the Doom package declarations of org/org-contrib are inheriting from org-elpa and all that stuff it does with :includes and maybe other stuff /does/ matter?
;; - how does Guix handle org? One package, multiple?
;; TODO consider `straight--convert-recipe'
;; TODO consider straight-built-in-pseudo-packages
;; esp. in straight--convert-recipe
;; TODO consider how straight.el recipe inheritance works
;; esp. in straight--convert-recipe

;; TODO hack
;; Wait to do this until the end when I have a concrete idea of all the stuff I'll have to read (doom packages, melpa recipes...) and how I want to do it.
;; Ideas:
;; - hack scm/edn.scm somehow?
;; - convert `doom-packages` (and melpa recipes) package names to strings on the elisp side
;;   Would be messy with melpa recipes since there's no "elisp-reading phase"
;; - elisp "parseclj"/"parseedn" are nice but they don't solve the 0x0 problem
;;   Are they worth the additional overhead of running them on the elisp side? Again, with melpa there might not /be/ an elisp side
;;   - nice to have but maybe not necessary: handling dotted pairs, t/nil become true/nil
;; - don't use the 0x0 package
(defn icky [x]
  (if (= x "0")
    "0x0" x))

;; TODO probably do this with spec, but wait until a bit later / the end
;; (if-let [unsupported (seq (filter (fn [p]
;;                                       (or (let [type (get p :doom.package/type)]
;;                                             (some (hash-set type) (vector :doom.package.type/local :doom.package.type/built-in)))
;;                                           (let [vc (get-in p (vector :package/recipe :recipe/vc))]
;;                                             (and vc (not= vc :vc/git)))
;;                                           (get-in p (vector :package/recipe :straight.recipe/protocol))
;;                                           (get-in p (vector :package/recipe :straight.recipe/source))
;;                                           (get-in p (vector :package/recipe :straight.recipe/fork))
;;                                           (get-in p (vector :package/recipe :straight.recipe/upstream))
;;                                           (get-in p (vector :package/recipe :straight.recipe/includes))))
;;                                   $))]
;;         (throw (ex-info "Package(s) with unsupported configuration" {:packages unsupported}))
;;         $)
;; TODO NEW stuff I've decided I'm /definitely/ not supporting: fork, source
;; - don't support :build. (At leat for values other than 't, which is harmless and which Doom's org package declaration uses. Maybe just override the Doom org package like I'm going to do for its :pre-build)
;; - don't support :pre-build/:post-build (Doom's org and notmuch packages use :pre-build though, so find probably override those recipes to not have :pre-build steps and make sure the Guix packages for them do what the :pre-build steps would have done).
;; - probably not supporting manually-set inherit property (and straight-allow-recipe-inheritance must be true)
;; - list of straight package props Doom actually uses
;;   host
;;   repo
;;   files
;;   nonrecursive
;;   branch
;;   local-repo
;;   - Only straight has this and it doesn't matter for me
;;   build
;;   - only org (:build t)
;;   pre-build
;;   - only org and notmuch
;;   depth
;;   - only org (:depth 1)
;; - spec that both host and repo must be specified so in inheritance one isn't overridden without the other?
#+end_src
******** deps
Had =:tangle phrenetic/deps.edn :comments link=
#+begin_src clojure :tangle no
{:paths ["src" "resources"]
 :deps {org.clojure/clojure {:mvn/version "1.11.1"}
        org.clojure/alpha.spec {:git/url "https://github.com/clojure/spec-alpha2.git"
                                :sha "99456b1856a6fd934e2c30b17920bd790dd81775"}
        babashka/fs {:mvn/version "0.1.6"}}
 :aliases
 {:run-m {:main-opts ["-m" "protostar.hickeyland"]}
  :run-x {:ns-default protostar.hickeyland
          :exec-fn greet
          :exec-args {:name "Clojure"}}
  :build {:deps {io.github.seancorfield/build-clj
                 {:git/tag "v0.6.3" :git/sha "9b8e09b"
                  ;; since we're building an app uberjar, we do not
                  ;; need deps-deploy for clojars.org deployment:
                  :deps/root "slim"}}
          :ns-default build}
  :test {:extra-paths ["test"]
         :extra-deps {org.clojure/test.check {:mvn/version "1.1.1"}
                      io.github.cognitect-labs/test-runner
                      {:git/tag "v0.5.0" :git/sha "48c3c67"}}}}}
#+end_src
******* guix part
Had =:tangle phrenetic/lokke/ns/phrenetic/packaging-wip.clj :comments link=
#+begin_src clojure :tangle no
(ns phrenetic.packaging-wip
  (:require [guile :refer [command-line]]
            [guile.guix.base32 :refer [bytevector->nix-base32-string]]
            [guile.guix.git :refer [latest-repository-commit]]
            [guile.guix.hash :refer [file-hash*]]
            [guile.guix.store :refer [with-store]]
            [guile.srfi.srfi-11 :as srfi-11]

            [guile.guix.build-system.emacs :refer [emacs-build-system]]
            [guile.guix.git-download :refer [git-fetch git-reference git-file-name]]
            [guile.guix.packages :refer [package origin content-hash]]))

(defn- pair [a b]
  (guile/cons a b))

(defmacro let-values [bindings & body]
  (let [bindings*
        (->> bindings
             (partition 2)
             (map (fn [[names expr]]
                    (list
                     (apply list names) expr))))]
    `(srfi-11/let-values ~bindings*
       ~@body)))

(defn- download-git-repo! [url [ref' ref''] recursive?]
  (let-values
   [[dir commit]
    (with-store store
      (latest-repository-commit store url
                                :ref (pair (symbol ref') ref'')
                                :recursive? recursive?))]
   {:dir dir :commit commit}))

;; (println
;;  (download-git-repo! "https://github.com/raxod502/straight.el.git" [:branch "develop"] false))
;; (println
;;  (download-git-repo! "https://github.com/minad/consult.git" '()))

(defn get-origin-data [url ref recursive?]
  (let [{:keys [dir commit]} (download-git-repo! url ref recursive?)]
   {:commit commit
    :hash (bytevector->nix-base32-string
           (file-hash* dir))}))

;; (println
;;  (get-origin-data "https://github.com/raxod502/straight.el.git" [:branch "develop"] false))





(defn fex-package [package-name url commit recursive? hash]
  (package
   (name (str "emacs-" package-name))
   (version "0.0.1")
   (source
    (origin
     (method git-fetch)
     (uri (git-reference
           (url url)
           (commit commit)
           (recursive? recursive?)))
     (file-name (git-file-name name version))
     (hash
      (content-hash hash))))
   (build-system emacs-build-system)
   ;; (arguments
   ;;  `(#:phases
   ;;    (modify-phases %standard-phases
   ;;      (add-after 'unpack 'move-source-files
   ;;        (lambda _
   ;;          (let ((el-files (find-files "./extensions" ".*\\.el$")))
   ;;            (for-each (lambda (f)
   ;;                        (rename-file f (basename f)))
   ;;                      el-files)))))))
   ;; (native-inputs
   ;;  (list texinfo))
   (home-page nil)
   (synopsis nil)
   (description nil)
   (license nil)))

;; (println
;;  (fex-package "tldr"
;;               "https://github.com/kuanyui/tldr.el"
;;               "7203d1be3dcbf12131846ffe06601933fa874d74"
;;               nil
;;               "1bw6la463l2yfm7rp76ga4makfy4kpxgwi7ni5gxk31w11g26ryk"))




;; (defn call [nm & args]
;;   (let [f (ns-resolve *ns* (symbol nm))]
;;     (apply f args)))

(defn asdf [n]
  (+ 1 n))

(when (< (count (command-line)) 1) ; temporarily let me run this file manually
  (let [f (-> (command-line) second)
        args (-> (command-line) next next)]
    (println
     (let [func
           (case f
             "asdf" asdf)]
       (apply func (map read-string args))))))
#+end_src
******* packaging runner
Had =:tangle (meta-in-dir "packaging-runner.scm")=
#+begin_src scheme :tangle no
(use-modules (lokke ns))
(require #(phrenetic.packaging-wip))
#+end_src
******* test clj
Had =:tangle phrenetic/lokke/ns/phrenetic/test-clj.clj :comments link=
#+begin_src clojure :tangle no
(ns phrenetic.test-clj
  (:require [guile.guix.gexp :as g]
            [guile.guix.packages :refer [package package-description]]))

(println
 (gexp "asdf"))

;; (println
;;  (p/package (name "asdf")))

;; (println
;;  (package-description
;;   (package
;;     (name "asdf")
;;     (version "0")
;;     (source nil)
;;     (build-system nil)
;;     (synopsis "asdf")
;;     (description "asdf3333")
;;     (home-page nil)
;;     (license nil))))

(+ 1 1)
(println 5)

#+end_src
******* test scm
Had =tangle (meta-in-dir "test-scm.scm")=
#+begin_src scheme :tangle no
(use-modules (lokke ns))
(require #(phrenetic.test-clj))
#+end_src
******* elisp
Had =:tangle (meta-in-dir "parse-doom-packages.el")=
- [2022-09-11 Sun] nb: I removed the global lexical arg to emacs-lisp code blocks. Probably doesn't matter.
#+begin_src emacs-lisp :tangle no
(defun m-slurp (f)
  (with-temp-buffer
    (insert-file-contents f)
    (buffer-string)))

(defun m-spit (f content)
  (with-temp-file f
    (insert content)))




(defun m-process ()
  (-as-> (m-slurp "~/work/phrenetic/doom-packaging/my-doom-packages.el") $
         (read $)
         (-map #'-first-item $)
         (-map #'symbol-name $)))

(defun write-doom-pkgs-txt ()
  (m-spit "doom-packaging/guix-doom-emacs-packages.txt"
          (pp (m-process))))





(defun repo-commit (r)
  (let ((default-directory (concat "~/.local/var/lib/doom-local/straight/repos/" r)))
    (straight--process-output "git" "rev-parse" "HEAD")))

(defun write-current-commits ()
  (let ((pkgs-to-repos
         (-map
          (lambda (x)
            (cons
             (-first-item x)
             (-as-> x $
                    (-fourth-item $)
                    (plist-get $ :local-repo))))
          (map-into straight--build-cache 'list))))
    (-map (lambda (x)
            (cons (car x)
                  (if-let ((y (cdr x)))
                      (if (not (equal y "/home/pharcosyle/work/dotfiles/donnager"))
                          (repo-commit y)
                        nil)
                    y)))
          pkgs-to-repos)))

;; (write-current-commits)
#+end_src
**** Doom services
***** Main
#+begin_src scheme
(define* (doom-main #:key
                    stateless?
                    evil?
                    icons?
                    email)
  (append
   (doom-general #:stateless? stateless?
                 #:evil? evil?
                 #:icons? icons?)
   (doom-user #:email email)
   (doom-keymaps)
   (doom-undo #:stateless? stateless?)
   (doom-emacs-lisp)
   (doom-markdown)))
#+end_src
****** General :bindings:
#+begin_src scheme
(define* (doom-general #:key
                       stateless?
                       evil?
                       icons?)
  (let ((name 'general))
    (list
     (doom-service
      name
      #:modules
      (let ((childframe? #t)
            (icons? #t))
        `((#:completion
           (company ,@(if childframe? '(+childframe) '()))
           (vertico ,@(if icons? '(+icons) '())))

          (#:ui
           doom
           doom-dashboard
           (emoji +unicode)
           hl-todo
           hydra
           indent-guides
           ;; (ligatures +extra)
           modeline
           nav-flash
           ophints
           (popup +defaults +all)
           treemacs
           vi-tilde-fringe
           window-select
           workspaces)

          (#:editor
           ,@(if evil? '((evil +everywhere)) '())
           file-templates
           fold
           format
           lispy
           multiple-cursors
           rotate-text
           snippets
           word-wrap)

          (#:emacs
           electric
           (ibuffer ,@(if icons? '(+icons) '())))

          (#:checkers
           (syntax ,@(if childframe? '(+childframe) '())))

          (#:tools
           (eval +overlay)
           lookup
           (pass +auth)
           pdf
           prodigy
           rgb
           taskrunner)

          (#:config
           (default +bindings +smartparens))))

      #:packages
      '((package! expand-region :pin "c5c4362741deebb0985a8a29f9b8b0e25160764a")
        (package! tldr :pin "d3fd2a809a266c005915026799121c78e8b358f0")
        ;; (package! 0x0 :pin "63cd5eccc85e527f28e1acc89502a53245000428") ; TODO `elisp-serialize' makes the `0x0' into `#{0x0}#'.
        )

      #:config
      (append
       '((setq scroll-margin 10
               save-interprogram-paste-before-kill t)

         ;; I like having line numbers on but hlissner says they're slow so I might want to disable them at some point. Keep in mind I use them to determine what lines are continuation lines so I might have to make the right fringe bigger if I do this and set visual-line-fringe-indicators.
         ;; (setq display-line-numbers-type nil)

         (setq-default indent-tabs-mode t) ; Doom sets this to nil, reset it.

         ;; I'd like to have this on but in the Doom code it says it's more efficient not to.
         ;; (setq-default cursor-in-non-selected-windows t)

         (after! doom-modeline
                 ;; (setq doom-modeline-checker-simple-format nil)
                 (setq doom-modeline-major-mode-icon t)
                 (setq doom-modeline-persp-name t))

         (use-package! highlight-indent-guides
                       :defer t
                       :init
                       ;; I don't want indent guides on by default, remove all the Doom module's hooks.
                       (remove-hook! '(prog-mode-hook
                                       text-mode-hook
                                       conf-mode-hook)
                                     #'highlight-indent-guides-mode))

         (use-package! lispy
                       :defer t
                       :init
                       ;; Not using lispy, remove all the Doom module's hooks.
                       (remove-hook! '(lisp-mode-hook
                                       emacs-lisp-mode-hook
                                       ielm-mode-hook
                                       scheme-mode-hook
                                       racket-mode-hook
                                       hy-mode-hook
                                       lfe-mode-hook
                                       dune-mode-hook
                                       clojure-mode-hook
                                       fennel-mode-hook)
                                     #'lispy-mode)
                       (remove-hook! 'eval-expression-minibuffer-setup-hook #'doom-init-lispy-in-eval-expression-h))

         (use-package! lispyville
                       :hook (prog-mode . lispyville-mode)
                       :init
                       (setq lispyville-key-theme nil) ; Prevent Doom module's invocation of `lispyville-set-key-theme' from doing anything.
                       :config
                       (lispyville-set-key-theme
                        '(operators
                          c-w
                          c-u
                          commentary))
                       (map! :map lispyville-mode-map
                             "C-s-j" #'lispyville-beginning-of-next-defun
                             "C-s-k" #'lispyville-beginning-of-defun
                             "C-s-," #'lispyville-end-of-defun
                             "C-s-a" #'lispyville-drag-backward
                             "C-s-g" #'lispyville-drag-forward
                             "C-s-p" #'lispyville-prettify
                             (:prefix "C-s-;"
                              "R" #'lispyville-raise-list)))

         (use-package! expand-region
                       :defer t
                       :init
                       (map! :nv "s-e" #'er/expand-region
                             :nv "s-E" #'er/contract-region)
                       :config
                       (setq expand-region-fast-keys-enabled nil) ; My mapping is conventient enough and I don't want the repeat key to conflict with anything.
                       ;; Copied from Doom config: ~/.config/emacs/modules/config/default/+emacs.el:12
                       (defadvice! biome--quit-expand-region-a (&rest _)
                         "Properly abort an expand-region region."
                         :before '(evil-escape doom/escape) ; TODO `evil-escape': maybe gate with `evil?'
                         (when (memq last-command '(er/expand-region er/contract-region))
                           (er/contract-region 0))))

         ;; REVIEW Trying out not having this so I can use avy dispatch commands.
         ;; (after! avy
         ;;   (setq avy-single-candidate-jump t))

         (after! paren
                 (setq! show-paren-delay 0))

         (add-hook! 'prog-mode-hook #'biome-sp-strict-h)

         (after! rainbow-delimiters
                 ;; Doom sets this to 4 for possible performance reasons. I like having more (and 9 is the rainbow-delimiters default). The Doom base theme defines 9 too so this should look okay on most themes (though if they define their own faces there might be some duplication/clash where their definitions stop and the base theme's start).
                 (setq rainbow-delimiters-max-face-count 9))

         (after! recentf
                 (setq recentf-max-saved-items 500))

         (after! smartparens
                 (map! :map smartparens-mode-map
                       "C-s-h" #'sp-backward-sexp
                       "C-s-l" #'sp-forward-sexp
                       "C-s-u" #'sp-backward-up-sexp
                       "C-s-o" #'sp-up-sexp
                       :gn "C-s-m" #'sp-backward-down-sexp ; Bind in normal mode explicitly to override the Doom mapping in ~/.config/emacs/modules/config/default/config.el:447
                       "C-s-." #'sp-down-sexp
                       "C-s-c" #'sp-splice-sexp
                       "C-s-s" #'sp-splice-sexp-killing-backward
                       "C-s-f" #'sp-splice-sexp-killing-forward
                       "C-s-x" #'sp-backward-slurp-sexp
                       "C-s-v" #'sp-forward-slurp-sexp
                       "C-s-w" #'sp-backward-barf-sexp
                       "C-s-r" #'sp-forward-barf-sexp
                       (:prefix "C-s-;"
                        "(" #'sp-wrap-round
                        "[" #'sp-wrap-square
                        "{" #'sp-wrap-curly
                        "s" #'sp-split-sexp
                        "j" #'sp-join-sexp
                        "r" #'sp-raise-sexp
                        "c" #'sp-convolute-sexp
                        "w" #'sp-rewrap-sexp)))

         (defun biome-sp-strict-h ()
           (add-hook! 'smartparens-enabled-hook :local
                      #'turn-on-smartparens-strict-mode
                      (defun biome-modify-sp-strict-mode-map-h ()
                        (map! :map smartparens-strict-mode-map
                              :i "DEL" #'sp-backward-delete-char)))))

       (if evil?
           '((after! evil
                     (map! :m (vector 'C-i) nil)) ; Remove Doom's binding for `evil-jump-forward'.

             (after! evil-multiedit
                     (setq evil-multiedit-follow-matches t)))
           '())

       (wip-config)))

     (when stateless?
       (doom-stateless-service
        name
        #:state '(((#:path . ("autosave/" #:doom-base #:cache))
                   (#:store . #:machine))
                  ((#:path . ("bookmarks" #:doom-base #:data))
                   (#:store . #:persist))
                  ((#:path . ("recentf" #:doom-base #:cache))
                   (#:store . #:persist))
                  ((#:path . ("savehist" #:doom-base #:cache))
                   (#:store . #:persist))
                  ((#:path . ("saveplace" #:doom-base #:cache))
                   (#:store . #:persist))
                  ((#:path . ("tramp" #:doom-base #:cache))
                   (#:store . #:machine))

                  ((#:path . ("scratch/" #:doom-base #:data))
                   (#:store . #:persist))

                  ((#:path . ("projectile.projects" #:doom-base #:cache))
                   (#:store . #:persist))
                  ((#:path . ("projectile.cache" #:doom-base #:cache))
                   (#:store . #:machine))

                  ((#:path . ("workspaces/autosave/" #:doom-base #:data))
                   (#:store . #:machine))))))))



;; TODO WIP. Some of this stuff belongs in other components or gated.

(define (wip-config)
  '((after! emojify
            (setq emojify-display-style 'unicode))

    ;; TODO donno where this should go, ~+default-minibuffer-maps~ is a doom thing I guess
    (define-key! :keymaps +default-minibuffer-maps
      "s-J" #'scroll-up-command
      "s-K" #'scroll-down-command)

    (map! "s-A" #'app-launcher-run-app)

    ;; I don't think I'll ever need this with Sway. Is it worth keeping this and having an "I'm not on Sway / some WM" conditional around it?
    ;; (add-to-list 'initial-frame-alist '(fullscreen . fullboth))

    (map! "s-&" (lambda (command)
                  (interactive (list (read-shell-command "$ ")))
                  (call-process-shell-command command nil 0 nil)))

    (map! :leader
          "s-," (lookup-key doom-leader-map (kbd "<")))

    (after! company
            (map! :map company-active-map
                  "s-[" #'company-show-doc-buffer ; Currently opens Help, it would be better if I made it use Helpful.
                  "s-]" #'company-show-location))

    (after! evil-org
            (map! :map evil-org-mode-map
                  (:prefix "g"
                   :nv "{" #'evil-backward-paragraph
                   :nv "}" #'evil-forward-paragraph)))

    ;; Doesn't work yet: you have to switch to the buffer "manually" once before it starts being treated as real
    (map! "s-d m" (cmd! (doom-set-buffer-real (current-buffer) t)))

    ;; `forward-char' in original definition is messing things up, do this for now
    ;; (defun +eshell/search-history ()
    ;;   (interactive)
    ;;   (consult-history))
    (after! esh-mode
            (map! :map eshell-mode-map
                  "C-s" #'consult-history))

    (after! vertico
            (setq vertico-count 20  ; Trying out, maybe too big.
                  vertico-scroll-margin 7))

    (map! (:leader
           "A" #'embark-dwim)
          ;; Trying out cycling (temp)
          "C-:" #'embark-act
          "s-q" #'embark-cycle)

    ;; REVIEW Might be useful if there end up being a lot more of these and they have a lot of similarities: https://www.gnu.org/software/emacs/manual/html_node/elisp/Extending-Rx.html
    ;; TODO `better-jumper-jump-backward' doesn't consider these buffers, that's probably not a problem with `doom-real-buffer-functions' but rather something I have to do specially for it.
    (use-package! s)
    (add-hook! 'doom-real-buffer-functions
               ;; (defun biome-new-buffer-p (buf)
               ;;   (s-matches?
               ;;    (rx bol "*new*"
               ;;        (* "<" (+ digit) ">")
               ;;        eol)
               ;;    (buffer-name buf)))
               ;; TODO This should be in my Org config section / module but wait to move it until I'm confident I'll be continuing with this marking-buffers-as-real approach.
               (defun biome-org-src-edit-buffer-p (buf)
                 (s-matches?
                  (rx bol "*Org Src " (+ anything) "*"
                      (* "<" (+ digit) ">")
                      eol)
                  (buffer-name buf))))

    ;;  TODO Might be easier to do this with file-local variables.
    ;; (setq biome--phrenetic-dir "~/work/phrenetic")
    ;; (add-hook! 'org-mode-hook
    ;;   (defun biome-add-org-autotangle-after-save-hook-h ()
    ;;     (add-hook! 'after-save-hook :local
    ;;       (defun biome-autotangle-h ()
    ;;         (when (file-in-directory-p buffer-file-name biome--phrenetic-dir)
    ;;           ;; TODO ensure there aren't files in the output directory that no longer correspond to the org file. Just wipe it?
    ;;           (let ((org-confirm-babel-evaluate nil))
    ;;             (org-babel-tangle)))))))

    ;; (use-package! org-tanglesync
    ;;   :hook ((org-mode . org-tanglesync-mode)
    ;;          ((prog-mode text-mode) . org-tanglesync-watch-mode))
    ;;   :config
    ;;   (setq org-tanglesync-watch-files '("/home/pharcosyle/work/phrenetic/phrenetic.org")))

    ;; Maybe `s-S' to save-and-tangle? If I don't get some sort of auto-tangling thing going
    ;; - maybe it could be "save and eval defun (C-M-x)" in lisp/programming modes?'
    ;; Maybe a hotkey that just jumps back and forth between my most recently focused browser window and eemacs?
    ;; Maybe bind `s-o' in `consult-buffer' to "close consult-buffer and open +vertico/switch-workspace-buffer"

    (map! "s-o" (lookup-key doom-leader-map (kbd "<")))
    ;; Get rid of binding for =s-r=?
    (map! "s-r" nil)

    ;; Also messes with my sexp-movement bindings
    ;; (map! "C-s-j" #'evil-scroll-down
    ;;       "C-s-k" #'evil-scroll-up)

    (after! evil
            (map! :map evil-motion-state-map
                  ;; Maybe "C-s-o" but then I'll have to change my sexp-movement command(s). There are other bindings for jump-forward though, maybe I'll just use those.
                  "C-S-o" #'evil-jump-forward))))
#+end_src
****** User
#+begin_src scheme
(define* (doom-user #:key email)
  (list
   (doom-service
    'user
    #:config
    `((setq user-mail-address ,email)))))
#+end_src
****** Keymaps :bindings:
#+begin_src scheme
(define (doom-keymaps)
  (append
   (list
    (doom-service
     'keymaps
     #:config
     '((defun biome--trans (&rest rest)
         (-each (-partition 2 rest)
                (-lambda ((to from))
                         (define-key key-translation-map (kbd to) (kbd from)))))

       (biome--trans "C-h" "DEL"
                     "C-?" "C-h"

                     "s-h" "<left>"
                     "s-j" "<down>"
                     "s-k" "<up>"
                     "s-l" "<right>")

       (setq doom-leader-alt-key "s-SPC"
             doom-localleader-key "s-m"
             doom-localleader-alt-key "s-m")

       (defalias 'original-yank-pop #'yank-pop)

       ;; REVIEW Some of these should be in `:after' (or their respective package) sections but I'm not totally certain where I want to put bindings yet and I'm lazy.
       (map! "s-V" #'original-yank-pop

             "s-SPC" doom-leader-map

             ;; Adapted from Doom macOS bindings: ~/.config/emacs/modules/config/default/config.el:263
             "s-`" #'other-frame
             "s-n" #'+default/new-buffer
             "s-z" #'undo
             "s-Z" #'redo
             "s-c" (if (featurep 'evil) #'evil-yank #'copy-region-as-kill) ; TODO If keeping this, gate with `evil?'.
             "s-v" #'yank
             "s-s" #'save-buffer
             "s-x" #'execute-extended-command
             ;; REVIEW I don't think I need this, any time I'm in visual mode I can use `evil-delete` ("d")
             ;; :v "s-x" #'kill-region
             "s-/" (cmd! (save-excursion (comment-line 1)))
             ;; TODO If keeping this, gate with `evil?'.
             :n "s-/" #'evilnc-comment-or-uncomment-lines
             :v "s-/" #'evilnc-comment-operator

             "s-t" (lookup-key doom-leader-map (kbd "`"))
             "s-f" (lookup-key doom-leader-map (kbd "s b"))
             "s-r" (lookup-key doom-leader-map (kbd "f r"))
             "s-w" (lookup-key doom-leader-map (kbd "b k"))
             "s-d w" (lookup-key doom-leader-map (kbd "w d"))
             "s-d s-w" (cmd! (kill-current-buffer)
                             (+workspace/close-window-or-workspace))
             "s-g" (lookup-key doom-leader-map (kbd "g g"))
             "s-," (lookup-key doom-leader-map (kbd "w w"))
             "s-<" (lookup-key doom-leader-map (kbd "w W"))
             "s-y" (lookup-key doom-leader-map (kbd "i y"))
             "s-{" (lookup-key doom-leader-map (kbd "b p"))
             "s-}" (lookup-key doom-leader-map (kbd "b n"))
             "s-p" (lookup-key global-map (kbd "C-~")) ; TODO if I'm keeping this, improve it to first switch focus to a/the popup window if one isn't focused already

             "s-u" (lookup-key doom-leader-map (kbd "u"))
             "s-U" #'negative-argument ; REVIEW Trying this out.
             (:map universal-argument-map
              "s-u" #'universal-argument-more)

             ;; TODO Gate with `evil?'.
             (:after evil-easymotion
              "s-a" (lookup-key evilem-map (kbd "SPC")))

             "s-." #'repeat

             ;; TODO Gate with `evil?'.
             "s-J" #'evil-scroll-down
             "s-K" #'evil-scroll-up

             (:prefix "s-d"
              "." #'repeat-complex-command

              "h" #'git-gutter:popup-hunk
              ;; "o" #'+macos/open-in-default-program ;; TODO consider a Guix alternative? Meh.
              "r" #'projectile-replace
              "t" #'tldr
              "s" #'org-save-all-org-buffers
              "a" #'link-hint-open-multiple-links
              ;; TODO Gate with `evil?'.
              ;; "b" (cmd! (evil-local-mode 'toggle)
              ;;           (when evil-local-mode (evil-normal-state)))
              (:prefix "c"
               "f" #'org-gcal-fetch
               "s" #'org-gcal-sync
               "p" #'org-gcal-post-at-point)))

       ;; TODO wip stuff
       ;; If I keep this I can get rid of the "C-_" binding I have too. Update: maybe? Some places C-_ works and some s-h does (in vertico)? What about my key translation for C-? ? Straighten all this shit out.
       ;; - update: Guile won't accept the help-char string escape the way it is so I've removed it for now:
       ;;   (setq help-char (string-to-char "\C-_"))
       (biome--trans "s-h" "C-h")
       ;; Maybe "C-s-i" but then I'll have to change my sexp-movement command(s). Maybe keep this even if I do that, for consistency.
       (biome--trans "C-S-i" "<backtab>"))))

   (doom-dash)))
#+end_src
****** Undo
#+begin_src scheme
(define* (doom-undo #:key stateless?)
  (let ((name 'undo))
    (list
     (doom-service
      name
      #:modules '((#:emacs
                   undo))
      #:config
      '((after! undo-fu
                (setq undo-fu-ignore-keyboard-quit t))

        ;; (after! undo-tree
        ;;   (setq undo-tree-visualizer-timestamps t))
        ))

     (when stateless?
       (doom-stateless-service
        name
        #:state '(((#:path . ("undo-fu-session/" #:doom-base #:cache))
                   (#:store . #:machine)))))

     (simple-service
      (symbol-append 'doom- name '-add-zstd)
      home-profile-service-type
      (list zstd)))))
#+end_src
***** Languages
#+begin_src scheme
(define* (doom-ts-lang lang
                       #:key
                       tree-sitter?)
  (append
   (list
    (doom-service
     lang
     #:modules `((#:lang
                  (,lang ,@(if tree-sitter? '(+tree-sitter) '()))))))

   (if tree-sitter?
       (doom-tree-sitter) '())))

(define (doom-tree-sitter)
  (list
   (doom-service
    'tree-sitter
    #:modules `((#:tools
                 tree-sitter)))))
#+end_src
****** Emacs Lisp
#+begin_src scheme
(define (doom-emacs-lisp)
  (list
   (doom-service
    'emacs-lisp
    #:modules `((#:lang
                 emacs-lisp))
    #:config
    '((after! elisp-mode
              (setq-hook! 'emacs-lisp-mode-hook indent-tabs-mode nil))))))
#+end_src
****** Javascript
#+begin_src scheme
(define* (doom-javascript #:key tree-sitter?)
  (append
   (doom-ts-lang 'javascript #:tree-sitter? tree-sitter?)
   (doom-ts-lang 'json #:tree-sitter? tree-sitter?)))
#+end_src
****** Markdown
#+begin_src scheme
(define* (doom-markdown)
  (list
   (doom-service
    'markdown
    #:modules `((#:lang
                 markdown)))))
#+end_src
****** XML and CSV
#+begin_src scheme
(define (doom-xml+csv)
  (list
   (doom-service
    'xml+csv
    #:modules `((#:lang
                 data)))))
#+end_src
****** Web
#+begin_src scheme
(define* (doom-web #:key tree-sitter?)
  (append
   (doom-ts-lang 'web #:tree-sitter? tree-sitter?)
   (doom-javascript #:tree-sitter? tree-sitter?)

   (list
    (doom-service
     'rest
     #:modules `((#:lang
                  (rest +jq)))))))
#+end_src
***** Libraries
****** Dash
#+begin_src scheme
(define (doom-dash)
  (list
   (doom-service
    'dash
    #:packages
    '((package! dash :pin "0ac1ecf6b56eb67bb81a3cf70f8d4354b5782341"))
    #:config
    '((use-package! dash)))))
#+end_src
****** Transient
#+begin_src scheme
(define* (doom-transient #:key stateless?)
  (let ((name 'transient))
    (list
     (doom-service
      name
      #:config
      `((after! transient
                (setq transient-history-limit ,very-big-history))))

     (when stateless?
       (doom-stateless-service
        name
        #:state '(((#:path . ("transient/history" #:doom-base #:data))
                   (#:store . #:persist))))))))
#+end_src
*** Package management
#+begin_src scheme
(define stateless-ensure-profiles-gexp
  (with-imported-modules '((guix build utils))
    #~(lambda (profiles)
        (use-modules ((guix build utils) #:select (mkdir-p)))

        (let ((no-follow-file-exists? (lambda (file)
                                        (false-if-exception (lstat file)))))
          (for-each
           (lambda (i)
             (let ((link (car i))
                   (profile (cdr i)))
               (when (and (no-follow-file-exists? profile)
                          (not (no-follow-file-exists? link)))
                 (mkdir-p (dirname link))
                 (symlink profile link))))
           profiles)))))
#+end_src
**** Guix
#+begin_src scheme
(define* (he-guix #:key
                  stateless?
                  doom?
                  channels)
  (append
   (list
    (when channels
      (simple-service
       'guix-add-channels
       home-xdg-configuration-files-service-type
       `(("guix/channels.scm"
          ,channels)))))

   (if stateless?
       (let ((guix-profile ".guix-profile")
             (guix-current "guix/current"))
         (list
          (simple-service
           'guix-ensure-profiles
           home-activation-service-type
           #~(#$stateless-ensure-profiles-gexp
              (let ((user-profiles-dir (string-append "/var/guix/profiles/per-user/" (passwd:name (getpwuid (getuid))))))
                `((,(string-append (getenv "HOME") "/" #$guix-profile) . ,(string-append user-profiles-dir "/guix-profile"))
                  (,(string-append (getenv "XDG_CONFIG_HOME") "/" #$guix-current) . ,(string-append user-profiles-dir "/current-guix"))))))

          (home-stateless-service
           'guix
           #:state '(((#:path . ("guix/" #:xdg-base "XDG_CACHE_HOME"))
                      (#:store . #:machine)))
           #:ignore `(,guix-profile
                      (,guix-current #:xdg-base "XDG_CONFIG_HOME")))))
       '())

   (guile-services #:stateless? stateless?
                   #:doom? doom?)

   (if doom?
       (doom-guix #:stateless? stateless?) '())))
#+end_src
***** Guile
#+begin_src scheme
(define* (guile-services #:key
                         stateless?
                         doom?)
  (append
   (list
    ;; (simple-service
    ;;  'guile-add-packages
    ;;  home-profile-service-type
    ;;  (list guile))

    (simple-service
     'guile-add-config
     home-files-service-type
     `((".guile"
        ,(local-file (skeleton-file ".guile") "guile"))
       (".gdbinit"
        ,(local-file (skeleton-file ".gdbinit") "gdbinit"))))

    (home-stateless-service
     'guile
     #:state '(((#:path . ".guile_history")
                (#:store . #:persist))
               ((#:path . ("guile/" #:xdg-base "XDG_CACHE_HOME"))
                (#:store . #:machine)))))

   (if doom?
       (doom-guile #:stateless? stateless?) '())))
#+end_src
***** Doom Guile
#+begin_src scheme
(define* (doom-guile #:key stateless?)
  (append
   (let ((name 'guile))
     (list
      (doom-service
       name
       #:modules '((#:lang
                    (scheme +guile)))
       #:config
       '((after! scheme
                 (setq-hook! 'scheme-mode-hook indent-tabs-mode nil))

         ;; TODO Maybe do this if popping to the side is too annoying
         ;; (after! geiser-repl
         ;;   (setq geiser-repl-use-other-window nil))
         ))

      (when stateless?
        (doom-stateless-service
         name
         #:state '(((#:path . ("geiser-history.guile" #:doom-base #:cache))
                    (#:store . #:persist)))))))

   (doom-transient #:stateless? stateless?)))
#+end_src
***** Doom Guix :bindings:
#+begin_src scheme
(define* (doom-guix #:key stateless?)
  (append
   (let ((name 'guix))
     (list
      (doom-service
       name
       #:packages
       '((package! guix :pin "c9aef52121b458297e70bb50f49f7276b4a8d759")
         (package! build-farm :pin "5c268a3c235ace0d79ef1ec82c440120317e06f5") ; REVIEW trying out
         (package! guix-packaging ; REVIEW trying out
                   :recipe (:host github
                            :repo "ryanprior/emacs-guix-packaging"
                            :files (:defaults "snippets"))
                   :pin "5bbd1f1a268b3dfd813a75125ca88cbf0bef6529"))
       #:config
       '((after! guix
                 (set-popup-rules!
                  '(("^\\*Guix" :height 0.5))))
         (use-package! guix-devel
                       :hook (scheme-mode . guix-devel-mode))
         (use-package! guix-popup
                       :defer t
                       :init
                       (map! :leader
                             "l" #'guix))  ; REVIEW temporary binding?
         (use-package! guix-prettify
                       :hook (doom-first-buffer . global-guix-prettify-mode))

         ;; TODO once I'm done packaging Doom figure out how to enable this
         ;; (use-package! guix-contributing)

         (use-package! guix-packaging
                       :defer t
                       :init
                       (setq guix-packaging--data-dir (concat doom-cache-dir "guix-packaging")))))

      (when stateless?
        (doom-stateless-service
         name
         #:state '(((#:path . ("guix-packaging/" #:doom-base #:cache))
                    (#:store . #:machine)))))))

   (doom-guile #:stateless? stateless?)))
#+end_src
**** Nix
#+begin_src scheme
(define* (he-nix #:key
                 stateless?
                 doom?
                 doom-tree-sitter?
                 login-shell
                 (nix-channels (local-file "nix-channels"))
                 (nixpkgs-config (local-file "nixpkgs-config.nix")))
  (append
   (list
    (let ((name 'nix-source-profile)
          (source (local-file "source-nix-profile")))
      (case login-shell
        ((#:shell/bash)
         (simple-service name
                         home-bash-service-type
                         (home-bash-extension
                          (bash-profile
                           (list source)))))
        ;; ((#:shell/zsh)
        ;;  (simple-service name
        ;;                  home-zsh-service-type
        ;;                  (home-zsh-extension
        ;;                   (zprofile
        ;;                    (list source)))))
        ))

    (simple-service
     'nix-add-channels
     home-files-service-type
     `((".nix-channels"
        ,nix-channels)))

    (simple-service
     'nix-add-nixpkgs-config
     home-xdg-configuration-files-service-type
     `(("nixpkgs/config.nix"
        ,nixpkgs-config))))

   (if stateless?
       (let ((nix-profile ".nix-profile")
             (nix-channels ".nix-defexpr/channels"))
         (list
          (simple-service
           'stateless-nix-ensure-profiles
           home-activation-service-type
           #~(#$stateless-ensure-profiles-gexp
              (let ((user-profiles-dir (string-append "/nix/var/nix/profiles/per-user/" (passwd:name (getpwuid (getuid))))))
                `((,(string-append (getenv "HOME") "/" #$nix-profile) . ,(string-append user-profiles-dir "/profile"))
                  (,(string-append (getenv "HOME") "/" #$nix-channels) . ,(string-append user-profiles-dir "/channels"))))))

          (home-stateless-service
           'nix
           #:state '(((#:path . ("nix/" #:xdg-base "XDG_CACHE_HOME"))
                      (#:store . #:machine)))
           #:ignore (list nix-profile
                          nix-channels))))
       '())

   (if doom?
       (doom-nix #:stateless? stateless?
                 #:tree-sitter? doom-tree-sitter?)
       '())))
#+end_src
***** Source Nix profile
#+begin_src sh :tangle (meta-in-dir "source-nix-profile")
if [ -f /run/current-system/profile/etc/profile.d/nix.sh ]; then
  . /run/current-system/profile/etc/profile.d/nix.sh
fi
#+end_src
***** Nix channels
#+begin_src conf :tangle (meta-in-dir "nix-channels")
https://nixos.org/channels/nixpkgs-unstable nixpkgs
#+end_src
***** Nixpkgs config
#+begin_src nix :tangle (meta-in-dir "nixpkgs-config.nix")
{ allowUnfree = true; }
#+end_src
***** Doom Nix
#+begin_src scheme
(define* (doom-nix #:key
                   stateless?
                   tree-sitter?)
  (append
   (doom-ts-lang 'nix #:tree-sitter? tree-sitter?)
   (doom-transient #:stateless? stateless?)))
#+end_src
***** Setup instructions
#+begin_src sh :tangle no
nix-channel --update

# nix-env --install google-chrome
# ...
#+end_src
**** Flatpak
I might need to run apps specially for Wayland, see [[https://github.com/swaywm/sway/wiki/Running-programs-natively-under-Wayland#flatpak][Running programs natively under Wayland  swaywm/sway Wiki  GitHub (Flatpak)]]
#+begin_src scheme
(define* (he-flatpak #:key
                     stateless?
                     wayland?)
  (list
   (simple-service
    'flatpak-add-packages
    home-profile-service-type
    (append
     (list flatpak)
     (if wayland?
         (list xdg-desktop-portal
               xdg-desktop-portal-wlr)
         '())))

   (simple-service
    'flatpak-exports
    home-environment-variables-service-type
    `(("XDG_DATA_DIRS" . "$XDG_DATA_DIRS${XDG_DATA_DIRS:+:}$XDG_DATA_HOME/flatpak/exports/share")))

   (when stateless?
     (home-stateless-service
      'flatpak
      #:state '(((#:path . ("flatpak/" #:xdg-base "XDG_DATA_HOME"))
                 (#:store . #:machine)
                 (#:mode . #o700)))))))
#+end_src
***** Setup instructions
#+begin_src sh :tangle no
flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
# flatpak remote-add --user --if-not-exists flathub-beta https://flathub.org/beta-repo/flathub-beta.flatpakrepo

# flatpak install --user flathub com.discordapp.Discord
# flatpak install --user flathub-beta com.obsproject.Studio
# ...
#+end_src
*** Console
**** KMonad
#+begin_src scheme
(define* (he-kmonad #:key
                    doom?
                    (device "/dev/input/by-id/usb-Apple_Inc._Apple_Internal_Keyboard___Trackpad-event-kbd")
                    ;; (kbd (local-file "config.kbd"))
                    (kbd (local-file "../mine.kbd")))
  (list
   (simple-service
    'kmonad
    home-shepherd-service-type
    (kmonad-shepherd-service kbd))

   (when doom?
     (doom-service
      'kmonad
      #:packages '((package! kbd-mode
                             :recipe (:host github
                                      :repo "kmonad/kbd-mode")
                             :pin "4a26abcbfc04208f437fd6b6a5bf3217b124db84"))))))

(define (kmonad-shepherd-service kbd)
  (list
   (shepherd-service
    (provision '(kmonad))
    (start #~(make-forkexec-constructor
              (list #$(file-append kmonad "/bin/kmonad") #$kbd)
              #:log-file (string-append
                          (or (getenv "XDG_LOG_HOME")
                              (format #f "~a/.local/var/log"
                                      (getenv "HOME")))
                          "/kmonad.log")))
    (stop #~(make-kill-destructor)))))
#+end_src
*** Desktop
#+begin_src scheme
(define* (ini-file name config
                   #:key (ini-serialize ini-serialize))
  (apply mixed-text-file name (ini-serialize config)))

(define (font-specification font)
  (string-join
   (list
    (assoc-ref font #:font/name)
    (number->string
     (assoc-ref font #:font/size)))
   " "))

(define wallpaper (local-file "alucard_bg.png"))
#+end_src
**** Pipewire
#+begin_src scheme
(define* (he-pipewire #:key
                      stateless?
                      dbus?
                      sway?)
  (append
   (pipewire-services #:stateless? stateless?
                      #:sway? sway?)
   (wireplumber-services #:stateless? stateless?
                         #:sway? sway?)))

(define* (pipewire-services #:key
                            stateless?
                            dbus?
                            sway?)
  (list
   (simple-service
    'pipewire-add-package
    home-profile-service-type
    (list pipewire-0.3))

   (simple-service
    'pipewire-add-shepherd-daemons
    home-shepherd-service-type
    (list
     (shepherd-service
      (provision '(pipewire))
      (requirement (if dbus?
                       '(dbus) '()))
      (start #~(make-forkexec-constructor
                (list #$(file-append pipewire-0.3 "/bin/pipewire"))
                #:log-file (string-append
                            (or (getenv "XDG_LOG_HOME")
                                (format #f "~a/.local/var/log"
                                        (getenv "HOME")))
                            "/pipewire.log")
                #:environment-variables
                (append (list "DISABLE_RTKIT=1")
                        (default-environment-variables))))
      (stop  #~(make-kill-destructor))
      (auto-start? #f))
     (shepherd-service
      (provision '(pipewire-pulse pulseaudio))
      (requirement '(pipewire pipewire-media-session))
      (start #~(make-forkexec-constructor
                (list #$(file-append pipewire-0.3 "/bin/pipewire-pulse"))
                #:log-file (string-append
                            (or (getenv "XDG_LOG_HOME")
                                (format #f "~a/.local/var/log"
                                        (getenv "HOME")))
                            "/pipewire-pulse.log")
                #:environment-variables
                (append (list "DISABLE_RTKIT=1")
                        (default-environment-variables))))
      (stop  #~(make-kill-destructor))
      (auto-start? #f))))

   (simple-service
    'pipewire-add-alsa-config
    home-xdg-configuration-files-service-type
    `(("alsa/asoundrc"
       ,(mixed-text-file
         "asoundrc"
         "<" (file-append pipewire-0.3 "/share/alsa/alsa.conf.d/50-pipewire.conf") ">" "\n"
         "<" (file-append pipewire-0.3 "/share/alsa/alsa.conf.d/99-pipewire-default.conf") ">" "\n"
         "\n"
         "pcm_type.pipewire {" "\n"
         "  lib " (file-append pipewire-0.3 "/lib/alsa-lib/libasound_module_pcm_pipewire.so") "\n"
         "}" "\n"
         "\n"
         "ctl_type.pipewire {" "\n"
         "  lib " (file-append pipewire-0.3 "/lib/alsa-lib/libasound_module_ctl_pipewire.so") "\n"
         "}" "\n"))))

   (when sway?
     (simple-service
      'pipewire-sway-start
      home-sway-service-type
      '((exec herd start pipewire)
        (exec herd start pipewire-pulse))))

   (when stateless?
     (home-stateless-service
      'pipewire
      #:state '(((#:path . ("pulse/cookie" #:xdg-base "XDG_CONFIG_HOME"))
                 (#:store . #:machine)
                 (#:parent-dir-perms . ((#:mode . #o700)))))))))
#+end_src
***** Wireplumber
#+begin_src scheme
(define* (wireplumber-services #:key
                               stateless?
                               sway?)
  (list
   (simple-service
    'wireplumber-add-package
    home-profile-service-type
    (list wireplumber))

   (simple-service
    'wireplumber-add-shepherd-daemon
    home-shepherd-service-type
    (list
     (shepherd-service
      (provision '(wireplumber pipewire-media-session))
      (requirement '(pipewire))
      (start #~(make-forkexec-constructor
                (list #$(file-append wireplumber "/bin/wireplumber"))
                #:log-file (string-append
                            (or (getenv "XDG_LOG_HOME")
                                (format #f "~a/.local/var/log"
                                        (getenv "HOME")))
                            "/wireplumber.log")
                #:environment-variables
                (append (list "DISABLE_RTKIT=1")
                        (default-environment-variables))))
      (stop  #~(make-kill-destructor))
      (auto-start? #f))))

   (when sway?
     (simple-service
      'wireplumber-sway-start
      home-sway-service-type
      '((exec herd start wireplumber))))

   (when stateless?
     (home-stateless-service
      'wireplumber
      #:state '(((#:path . ("wireplumber/" #:xdg-base "XDG_STATE_HOME"))
                 (#:store . #:machine)
                 (#:mode . #o700)))))))
#+end_src
**** Colors
#+begin_src scheme
;; Nothing here yet.
(define light-colors
  '())

(define dark-colors
  '((#:color/fg . "#dee2f8")
    (#:color/bg . "#31343f")
    (#:color/base0 . "#1e1f27")
    (#:color/base8 . "#eef0fb") ; (doom-lighten "#dee2f8" 0.5)
    (#:color/accent . "#8496ff")
    (#:color/red . "#fb8578")
    (#:color/orange . "#fdce5f")
    (#:color/green . "#9fed9c")
    (#:color/yellow . "#eddc91")
    (#:color/blue . "#7db9fe")
    (#:color/magenta . "#e29bf7")
    (#:color/violet . "#aeb9f3")
    (#:color/cyan . "#75e0f9")))
#+end_src
**** Fonts
#+begin_src scheme
(define* (he-fonts #:key
                   stateless?
                   fonts
                   extra-font-packages)
  (list
   (simple-service
    'fonts-add-packages
    home-profile-service-type
    (append
     (map (lambda (font)
            (assoc-ref font #:font/package))
          fonts)
     extra-font-packages))

   (when stateless?
     (home-stateless-service
      'fonts
      #:state '(((#:path . ("fontconfig/" #:xdg-base "XDG_CACHE_HOME"))
                 (#:store . #:machine)))))))

(define font-size 10)

(define font-mono
  `((#:font/name . "Source Code Pro")
    (#:font/size . ,font-size)
    (#:font/weight . ,'medium)
    (#:font/package . ,font-adobe-source-code-pro)))

(define font-sans
  `((#:font/name . "Iosevka Aile")
    (#:font/size . ,font-size)
    (#:font/package . ,font-iosevka-aile)))

(define font-serif
  `((#:font/name . "Iosevka Etoile")
    (#:font/package . ,font-iosevka-etoile)))

(define font-unicode
  `((#:font/name . "Unifont")
    (#:font/package . ,font-gnu-unifont)))

(define useful-font-packages
  (list font-noto-color-emoji
        font-liberation))
#+end_src
***** TODO [#D] Alternative fonts
- =font-unifont-gnu= sucks, find a replacement?
- Try out =font-adobe-source-sans-pro= in place of =font-iosevka-aile=?
***** Source Code Pro :package:version:
#+begin_src scheme :tangle (meta-in-dir "packages/fonts.scm")
(define-module (phrenetic packages fonts)
  #:use-module ((gnu packages fonts) #:select (font-adobe-source-code-pro) #:prefix fonts:)
  #:use-module (phrenetic utils))

(define-public font-adobe-source-code-pro
  (with-git-version
   fonts:font-adobe-source-code-pro
   #:version "2.038R-ro-1.058R-it-1.018R-VAR"
   #:commit "2.038R-ro/1.058R-it/1.018R-VAR"
   #:hash "00h4v3rmxyyaxni6nywacxvjnji2g2pi0b4js1yx0g67fvrv2gag"))
#+end_src
**** Date/time formats
#+begin_src scheme
(define date-format "%a %b %-d")

(define time-format "%-I:%M %p")
#+end_src
**** Doom themes and fonts
#+begin_src scheme
(define* (he-doom-themes+fonts #:key
                               theme
                               light-colors
                               dark-colors
                               font
                               font-variable-pitch
                               font-unicode
                               font-serif)
  (append
   (doom-themes #:theme theme
                #:light-colors light-colors
                #:dark-colors dark-colors)
   (doom-fonts #:font font
               #:font-variable-pitch font-variable-pitch
               #:font-unicode font-unicode
               #:font-serif font-serif)))
#+end_src
***** Themes
#+begin_src scheme
(define* (doom-themes #:key
                      theme
                      light-colors
                      dark-colors)
  (let ((light-theme-name 'doom-one-light)
        (dark-theme-name 'doom-nuclear))
    (list
     (doom-service
      'themes
      #:config
      `((setq doom-theme ',(case theme
                             ((#:theme/light) light-theme-name)
                             ((#:theme/dark) dark-theme-name))))
      #:themes
      (append
       (doom-light-theme #:name light-theme-name
                         #:colors light-colors)
       (doom-dark-theme #:name dark-theme-name
                        #:colors dark-colors))))))
#+end_src
****** Light
#+begin_src scheme
;; Nothing here yet.
(define* (doom-light-theme #:key name colors)
  `())
#+end_src
****** Dark
Some colors from the original Atom theme on which I based mine that might be useful:
- ~#363b4e~
  Dark with a bluish tint. Was previously used as the line highlight color.
- ~#666d7a~
#+begin_src scheme
(define* (doom-dark-theme #:key name colors)
  (let ((clr (lambda (color)
               (assoc-ref colors color))))
    `((,name
       ((fg        '(,(clr #:color/fg)      "#bfbfbf" "brightwhite"))
        (bg        '(,(clr #:color/bg)      "black"   "black"))

        (fg-alt    '("#63677f"              "#2d2d2d" "white"))
        (bg-alt    '("#262831"              "black"   "black"))

        (base0     '(,(clr #:color/base0)   "black"   "black"))
        (base1     '("#202229"              "#1e1e1e" "brightblack")) ; (doom-darken "#262831" 0.15)
        (base2     '("#22242c"              "#2e2e2e" "brightblack")) ; (doom-darken "#262831" 0.10)
        (base3     '("#24262e"              "#262626" "brightblack")) ; (doom-darken "#262831" 0.05)
        (base4     '("#484b5b"              "#3f3f3f" "brightblack"))
        (base5     `(,(car fg-alt)          "#525252" "brightblack"))
        (base6     '("#7c82a0"              "#6b6b6b" "brightblack")) ; (doom-darken "#939abd" 0.15)
        (base7     '("#939abd"              "#979797" "brightblack"))
        (base8     '(,(clr #:color/base8)   "#dfdfdf" "white"))

        (grey      base4)
        (red       '(,(clr #:color/red)     "#ff6655" "red"))
        (orange    '(,(clr #:color/orange)  "#dd8844" "brightred"))
        (green     '(,(clr #:color/green)   "#99bb66" "green"))
        (teal      '("#fec0cb"              "#44b9b1" "brightgreen"))
        (yellow    '(,(clr #:color/yellow)  "#ECBE7B" "yellow"))
        (blue      '(,(clr #:color/blue)    "#51afef" "brightblue" ))
        (dark-blue '("#5f68de"              "#2257A0" "blue"))
        (magenta   '(,(clr #:color/magenta) "#c678dd" "brightmagenta"))
        (violet    '(,(clr #:color/violet)  "#a9a1e1" "magenta"))
        (cyan      '(,(clr #:color/cyan)    "#46D9FF" "brightcyan"))
        (dark-cyan '("#cf8191"              "#5699AF" "cyan"))

        (highlight      ,(clr #:color/accent))
        (vertical-bar   base0)
        (selection      dark-blue)
        (builtin        blue)
        (comments       base5)
        (doc-comments   base7)
        (constants      yellow)
        (functions      blue)
        (keywords       magenta)
        (methods        teal)
        (operators      cyan)
        (type           orange)
        (strings        green)
        (variables      red)
        (numbers        dark-cyan)
        (region         `(,(doom-lighten (car bg-alt) 0.15) ,@(doom-lighten (cdr base1) 0.35)))
        (error          red)
        (warning        yellow)
        (success        green)
        (vc-modified    orange)
        (vc-added       green)
        (vc-deleted     red))

       ;; Doom base theme overrides.
       ((cursor :background "#fdd94a")
        ((font-lock-comment-delimiter-face &override) :foreground base7)
        ((font-lock-doc-face &override) :foreground violet)
        ((line-number-current-line &override) :foreground violet)
        (mode-line :background base1 :foreground fg)
        (mode-line-inactive :background base3 :foreground base6)
        (org-block :background (doom-lighten bg-alt 0.02))
        (rainbow-delimiters-depth-1-face :foreground fg)
        (rainbow-delimiters-depth-2-face :foreground magenta)
        (rainbow-delimiters-depth-3-face :foreground blue)
        (rainbow-delimiters-depth-4-face :foreground cyan)
        (rainbow-delimiters-depth-5-face :foreground green)
        (rainbow-delimiters-depth-6-face :foreground yellow)
        (rainbow-delimiters-depth-7-face :foreground orange)
        (rainbow-delimiters-depth-8-face :foreground red)
        (rainbow-delimiters-depth-9-face :foreground teal)

        ;; Custom faces.
        (clojure-character-face :foreground teal :weight 'bold)
        (doom-modeline-bar :background highlight)
        (doom-modeline-buffer-file :inherit 'mode-line-buffer-id :weight 'bold)
        (doom-modeline-buffer-path :inherit 'mode-line-emphasis :weight 'bold)
        (doom-modeline-buffer-project-root :foreground green :weight 'bold)
        (solaire-mode-line-face :inherit 'mode-line :background base0)
        (solaire-mode-line-inactive-face :inherit 'mode-line-inactive :background base2)

        ;; These are present in the `doom-one' theme on which mine is based but I'm not sure if I need or want them. I'm keeping them around for now.
        (css-proprietary-property :foreground orange)
        (css-property :foreground green)
        (css-selector :foreground blue)
        (font-latex-math-face :foreground green)
        (markdown-markup-face :foreground base5)
        (markdown-header-face :inherit 'bold :foreground red)
        ((markdown-code-face &override) :background (doom-lighten base3 0.05))
        (rjsx-tag :foreground red)
        (rjsx-attr :foreground orange))))))
#+end_src
***** Fonts
#+begin_src scheme
(define* (doom-fonts #:key
                     font
                     font-variable-pitch
                     font-unicode
                     font-serif)
  (append
   (list
    (doom-service
     'fonts
     #:config
     `((defun biome--set-font-safe (sym font)
         (when (find-font font)
           (set sym font)))

       (biome--set-font-safe
        'doom-font
        (font-spec ;; :family ,(assoc-ref font #:font/name)
                   ;; Work around what I suspect is a PGTK issue. It's fixed in Emacs 29.
                   :family ,(if (equal? (assoc-ref font #:font/weight) 'medium)
                                (string-append (assoc-ref font #:font/name) " Medium")
                                (assoc-ref font #:font/name))
                   :size ,(+ (assoc-ref font #:font/size) 2)
                   :weight ',(or (assoc-ref font #:font/weight) 'normal)))

       (-each '((doom-variable-pitch-font ,(assoc-ref font-variable-pitch #:font/name))
                (doom-unicode-font ,(assoc-ref font-unicode #:font/name))
                (doom-serif-font ,(assoc-ref font-serif #:font/name)))
              (-lambda ((font-sym family))
                       (biome--set-font-safe
                        font-sym
                        (font-spec :family family)))))))

   (doom-dash)))
#+end_src
**** XDG
#+begin_src scheme
(define* (he-xdg
          #:key
          stateless?
          (desktop "$HOME/desktop")
          (documents "$HOME/docs")
          (download "$HOME/dl")
          (music "$HOME/music")
          (pictures "$HOME/pics")
          (publicshare "$HOME/public")
          (templates "$HOME/templates")
          (videos "$HOME/vids"))
  (list
   (simple-service
    'xdg-add-packages
    home-profile-service-type
    (list xdg-utils
          xdg-user-dirs ; I don't think I need this (the only reason would be if programs ever call the `xdg-user-dir' shell command and this package isn't an input to theirs).
          desktop-file-utils)) ; I don't think I need this at all but it adds elisp code (a mode for editing .desktop files). Andrew Tropin has it, I'll keep it just in case.

   (service
    home-xdg-user-directories-service-type
    (home-xdg-user-directories-configuration
     (desktop desktop)
     (documents documents)
     (download download)
     (music music)
     (pictures pictures)
     (publicshare publicshare)
     (templates templates)
     (videos videos)))

   (when stateless?
     (home-stateless-service
      'xdg
      #:state
      (append
       '(((#:path . ("Trash/" #:xdg-base "XDG_DATA_HOME"))
          (#:store . #:machine)
          (#:mode . #o700))
         ;; `XDG_LOG_HOME' isn't officially part of the XDG specification ("at least not yet", according to Andrew Tropin).
         ((#:path . (#:xdg-base "XDG_LOG_HOME"))
          (#:store . #:machine)))
       (let ((normalize
              (lambda (dir)
                (as-> dir $
                      (let ((home-prefix "$HOME/"))
                        (if (string-prefix? home-prefix $)
                            (string-drop $ (string-length home-prefix))
                            $))
                      (string-append $ "/")))))
         `(,@(map (lambda (dir)
                    `((#:path . ,(normalize dir))
                      (#:store . #:persist)))
                  (list desktop
                        documents
                        music
                        pictures
                        publicshare
                        templates
                        videos))
           ((#:path . ,(normalize download))
            (#:store . #:machine)))))))))
#+end_src
**** Mesa
#+begin_src scheme
(define* (he-mesa #:key stateless?)
  (list
   (when stateless?
     (home-stateless-service
      'mesa
      #:state '(((#:path . ("mesa_shader_cache/" #:xdg-base "XDG_CACHE_HOME"))
                 (#:store . #:machine)))))))
#+end_src
**** D-Bus
#+begin_src scheme
(define (he-dbus)
  (list
   (simple-service
    'dbus-set-address-env-var
    home-environment-variables-service-type
    '(("DBUS_SESSION_BUS_ADDRESS" . "unix:path=$XDG_RUNTIME_DIR/bus")))

   (simple-service
    'dbus-add-shepherd-daemon
    home-shepherd-service-type
    (list
     (shepherd-service
      (provision '(dbus))
      (start #~(make-forkexec-constructor
                (list #$(file-append dbus "/bin/dbus-daemon")
                      "--nofork"
                      "--session"
                      (string-append
                       "--address=" "unix:path="
                       (getenv "XDG_RUNTIME_DIR") "/bus"))
                #:log-file (string-append
                            (or (getenv "XDG_LOG_HOME")
                                (format #f "~a/.local/var/log"
                                        (getenv "HOME")))
                            "/dbus.log")))
      (stop  #~(make-kill-destructor)))))))
#+end_src
**** Login management
***** Login managers
****** GDM
#+begin_src scheme
(define* (he-gdm #:key stateless?)
  (list
   (when stateless?
     (home-stateless-service
      'gdm
      #:state '(((#:path . ("gdm/" #:xdg-base "XDG_CACHE_HOME"))
                 (#:store . #:machine)
                 (#:mode . #o700)))))))
#+end_src
***** Desktop TTY
#+begin_src scheme
(define* (he-desktop-tty #:key start-cmd)
  (list
   (simple-service
    'desktop-tty-default-session-start
    home-profile-service-type
    (list (default-session-start start-cmd)))))

(define (default-session-start cmd)
  (package
    (inherit blank-package)
    (name "default-session-start")
    (source cmd)
    (build-system trivial-build-system)
    (arguments
     `(#:builder
       ,#~(begin
            (let* ((bin (string-append #$output "/bin")))
              (mkdir #$output)
              (mkdir bin)
              (symlink #$source (string-append bin "/default-session-start"))))))))
#+end_src
**** Sessions
#+begin_src scheme
(define* (session-start exe #:rest content)
  (package
    (inherit blank-package)
    (name (string-append "session-" exe))
    (source (apply mixed-text-file exe content))
    (build-system trivial-build-system)
    (arguments
     `(#:builder
       ,#~(begin
            (let* ((bin (string-append #$output "/bin"))
                   (f (string-append bin "/" #$exe)))
              (mkdir #$output)
              (mkdir bin)
              (copy-file #$source f)
              (chmod f #o555)))))))

(define (xdg-current-desktop-env-var val)
  `("XDG_CURRENT_DESKTOP" . ,val)) ; "Normally" provided by a login manager.

(define xdg-session-type-wayland-env-var
  '("XDG_SESSION_TYPE" . "wayland")) ; "Normally" provided by a login manager.

;; I think these should really be set in packages / package program wrappers but this is easier and Andrew Tropin does it this way so I'll leave it as-is for now.
(define* (wayland-env-vars #:key pipewire?)
 ;; Copied from RDE: I don't know what all of these do. For some explanation see https://github.com/swaywm/sway/wiki/Running-programs-natively-under-Wayland.
 (append
  '(("SDL_VIDEODRIVER" . "wayland")
    ("MOZ_ENABLE_WAYLAND" . "1") ; The nongnu `firefox-wayland' package sets this in a program wrapper so it's probably not necessary unless I'm using some other Mozilla thing (e.g. `icecat') and even then it'd be better to add it to a wrapper.
    ("CLUTTER_BACKEND" . "wayland")
    ("ELM_ENGINE" . "wayland_egl")
    ("ECORE_EVAS_ENGINE" . "wayland-egl")
    ("QT_QPA_PLATFORM" . "wayland-egl") ; Might not be necessary since I set `XDG_SESSION_TYPE=wayland', see https://github.com/swaywm/sway/wiki/Running-programs-natively-under-Wayland#qt5
    ("_JAVA_AWT_WM_NONREPARENTING" . "1"))
  (if pipewire?
      '(("RTC_USE_PIPEWIRE" . "true")) '()))) ; Might not be necessary: as far as I can tell this is only relevant to Chromium (equivalent to toggling on chrome://flags/#enable-webrtc-pipewire-capturer) and the Guix already sets `rtc_use_pipewire=true' in the ungoogled-chromium configure flags.
#+end_src
***** Desktop environments
****** GNOME
#+begin_src scheme
(define* (he-gnome #:key stateless?)
  (list
   (simple-service
    'gnome-add-packages
    home-profile-service-type
    (list (gnome-start-package)
          gnome))

   ;; (when stateless?
   ;;   (home-stateless-service
   ;;    'gnome
   ;;    #:state ...))
   ))

(define (gnome-start)
  (file-append (gnome-start-package) "/bin/" gnome-start-exe))

(define gnome-start-exe "gnome-start")

(define (gnome-start-package)
  (session-start
   gnome-start-exe
   (environment-variable-shell-definitions
    (list xdg-session-type-wayland-env-var))
   "exec " (file-append gnome-session "/bin/gnome-session")))
#+end_src
***** Window managers
****** Common
#+begin_src scheme
(define* (he-wm-common #:key sway?)
  (wm-common-applets #:sway? sway?))

(define* (wm-common-applets #:key sway?)
  (list
   ;; The only one I know for sure needs to be installed is gammastep (the applet can't find its icon otherwise) but install the rest too just in case.
   (simple-service
    'wm-common-applet-add-packages
    home-profile-service-type
    (list network-manager-applet
          gammastep
          udiskie))
   (when sway?
     (simple-service
      'sway-start-applets
      home-sway-service-type
      `((exec ,(file-append network-manager-applet "/bin/nm-applet") --indicator)
        ;; (exec ,(file-append gammastep "/bin/gammastep-indicator") -l 44:-123) ; TODO Don't hardcode lat/long (use geoclue?) or make it a parameter.
        (exec ,(file-append udiskie "/bin/udiskie") --tray
              ;; --file-manager ,(file-append xdg-utils "/bin/xdg-open")
              ))))))
#+end_src
****** Sway
#+begin_src scheme
(define* (he-sway #:key
                  doom?
                  pipewire?
                  (sway-mod 'Mod1)
                  kb-layout
                  (kb-repeat-delay 200)
                  (kb-repeat-rate 40)
                  (xwayland? #t)
                  (screen-locker #~(string-append #$(file-append elogind "/bin/loginctl") " lock-session"))
                  idle-manager
                  application-launcher
                  default-terminal
                  (backup-terminal default-terminal)
                  (bg-image wallpaper)
                  extra-config)
  (list
   (simple-service
    'sway-add-packages
    home-profile-service-type
    (list (sway-start-package #:pipewire? pipewire?)
          qtwayland ; Copied from RDE. I don't know what this is for. It seems like a build, not runtime, dependency.
          swayhide ; TODO I'm pretty sure this isn't required for anything. I'm keeping it around for now so I can try it out, though.
          xdg-desktop-portal
          xdg-desktop-portal-wlr
          slurp)) ; This might be necessary to make xdg-desktop-portal-wlr screencasting work. See "xdpw will try to use the first chooser found in the list of hardcoded choosers..." in https://man.archlinux.org/man/xdg-desktop-portal-wlr.5.

   (service
    home-sway-service-type
    (home-sway-configuration
     (package sway) ; Remove this when I'm not using `sway-latest` any more.
     (config
      `((xwayland ,(if xwayland? 'enable 'disable))

        (input type:keyboard
               ,(append
                 (if kb-layout
                     (append
                      `((xkb_layout ,(keyboard-layout-name kb-layout)))
                      (if-let ((variant (keyboard-layout-variant kb-layout)))
                              `((xkb_variant ,variant)) '())
                      (if-let ((model (keyboard-layout-model kb-layout)))
                              `((xkb_model ,model)) '())
                      (let ((options (keyboard-layout-options kb-layout)))
                        (if (null? options)
                            '()
                            `((xkb_options ,(string-join
                                             (keyboard-layout-options kb-layout) ","))))))
                     '())
                 `((repeat_delay ,kb-repeat-delay))
                 `((repeat_rate ,kb-repeat-rate))))

        (input type:touchpad
               ((natural_scroll enabled)
                (tap enabled)))

        (set $mod ,sway-mod)
        (set $term ,default-terminal)
        (set $backup-term ,backup-terminal)
        (set $menu ,application-launcher)
        (set $lock ,screen-locker)

        (floating_modifier $mod normal)

        (bindsym --to-code $mod+Shift+r reload)

        ;; Some of these might not be necessary. To be safe I'm using a combination of those in RDE and suggested here:
        ;; - https://github.com/swaywm/sway/wiki#gtk-applications-take-20-seconds-to-start
        ;; - https://lists.sr.ht/~abcdw/rde-discuss/%3C87bku5ozzn.fsf%40bruun.xyz%3E
        ;; - https://github.com/emersion/xdg-desktop-portal-wlr#running
        (exec ,(file-append dbus "/bin/dbus-update-activation-environment")
              DISPLAY WAYLAND_DISPLAY XDG_CURRENT_DESKTOP SWAYSOCK)

        ;; Launching external applications.
        (bindsym $mod+Control+Shift+Return exec $backup-term)
        (bindsym $mod+Return exec $term)
        (bindsym --to-code $mod+Shift+d exec $menu)
        (bindsym --to-code $mod+Control+Shift+l exec $lock)

        ;; Manipulating windows.
        (bindsym --to-code $mod+Shift+c kill)
        (bindsym --to-code $mod+Shift+f fullscreen)
        (bindsym $mod+Shift+space floating toggle)
        (bindsym $mod+Control+space focus mode_toggle)
        (bindsym $mod+h focus left)
        (bindsym $mod+j focus down)
        (bindsym $mod+k focus up)
        (bindsym $mod+l focus right)
        (bindsym $mod+Shift+h move left)
        (bindsym $mod+Shift+j move down)
        (bindsym $mod+Shift+k move up)
        (bindsym $mod+Shift+l move right)

        ;; Moving around workspaces.
        (bindsym $mod+tab workspace back_and_forth)
        ,@(append-map
           (lambda (x)
             `((bindsym ,(format #f "$mod+~a" (modulo x 10))
                        workspace number ,x)
               (bindsym ,(format #f "$mod+Shift+~a" (modulo x 10))
                        move container to workspace number ,x)))
           (iota 10 1))

        ;; Scratchpad settings.
        (bindsym --to-code $mod+Shift+minus move scratchpad)
        (bindsym --to-code $mod+minus scratchpad show)

        (default_border pixel)
        (default_floating_border pixel)
        (gaps inner 8)

        (exec ,idle-manager)

        ,@(let* ((step 10)
                 (step->symbol (lambda (op)
                                 (symbol-append (string->symbol (number->string step)) '% op)))
                 (brightnessctl (file-append brightnessctl "/bin/brightnessctl")))
            `((bindsym --locked XF86MonBrightnessUp exec ,brightnessctl set ,(step->symbol '+))
              (bindsym --locked XF86MonBrightnessDown exec ,brightnessctl set ,(step->symbol '-))))

        ,@(let* ((step 5)
                 (step->symbol (lambda (op)
                                 (symbol-append op (string->symbol (number->string step)) '%)))
                 (pactl (file-append pulseaudio "/bin/pactl")))
            `((bindsym --locked XF86AudioRaiseVolume "\\\n"
                       exec ,pactl set-sink-mute @DEFAULT_SINK@ "false; \\\n"
                       exec ,pactl set-sink-volume @DEFAULT_SINK@ ,(step->symbol '+))
              (bindsym --locked XF86AudioLowerVolume "\\\n"
                       exec ,pactl set-sink-mute @DEFAULT_SINK@ "false; \\\n"
                       exec ,pactl set-sink-volume @DEFAULT_SINK@ ,(step->symbol '-))
              (bindsym --locked XF86AudioMute
                       exec ,pactl set-sink-mute @DEFAULT_SINK@ toggle)
              (bindsym --locked XF86AudioMicMute
                       exec ,pactl set-source-mute @DEFAULT_SOURCE@ toggle)))

        ,@(let ((playerctl (file-append playerctl "/bin/playerctl")))
            `((bindsym --locked XF86AudioPlay exec ,playerctl play-pause)
              (bindsym --locked XF86AudioPrev exec ,playerctl previous)
              (bindsym --locked XF86AudioNext exec ,playerctl next)))

        ,@(if bg-image
              `((output * bg ,bg-image fill)) '())

        (bindsym $mod+Shift+b splith)
        (bindsym $mod+Shift+v splitv)
        (bindsym $mod+Shift+s layout stacking)
        (bindsym $mod+Shift+w layout tabbed)
        (bindsym $mod+Shift+e layout toggle split)
        (bindsym $mod+Shift+a focus parent)
        (bindsym $mod+Shift+q exec ,(file-append sway "/bin/swaynag")
                 -t warning -m "'You pressed the exit shortcut. Do you really want to exit sway?'"
                 -B "'Yes, exit sway'" ,#~(format #f "'~a exit'" #$(file-append sway "/bin/swaymsg")))
        (gaps left 78) ; To accommodate the crack in my screen.

        ,@(or extra-config '())))))

   (simple-service
    'sway-reload-config-on-change
    home-run-on-change-service-type
    `(("files/.config/sway/config"
       ,#~(system* #$(file-append sway "/bin/swaymsg") "reload"))))

   (sway-screenshot-service)

   (when doom?
     (doom-service
      'sway
      #:packages '((package! i3wm-config-mode :pin "188e3978807ec39eba3cb69d973c0062af324215"))))))

(define* (sway-start #:key pipewire?)
  (file-append (sway-start-package #:pipewire? pipewire?) "/bin/" sway-start-exe))

(define sway-start-exe "sway-start")

(define* (sway-start-package #:key pipewire?)
  (session-start
   sway-start-exe
   (environment-variable-shell-definitions
    (cons* (xdg-current-desktop-env-var "sway")
           xdg-session-type-wayland-env-var ; Seems to be set even without this but relying on that might be a brittle, see https://www.reddit.com/r/swaywm/comments/skdt2b/comment/hvk8m8o
           (wayland-env-vars #:pipewire? pipewire?)))
   "exec " (file-append sway "/bin/sway")))
#+end_src
******* Sway screenshot
#+begin_src scheme
(define (sway-screenshot-service)
  (simple-service
   'sway-screenshot
   home-sway-service-type
   `((bindsym $mod+grave exec ,shot-output)
     (bindsym $mod+Control+grave exec ,swappy-clipboard)
     (bindsym $mod+Shift+grave exec ,shot-window-or-selection))))

(define subject-output
  #~(format #f "~a -t get_outputs | ~a -r '.[] | select(.focused) | .name'"
            #$(file-append sway "/bin/swaymsg")
            #$(file-append jq "/bin/jq")))

(define subject-window-or-selection
  #~(format #f "~a -t get_tree | ~a -r '.. | select(.pid? and .visible?) \
| .rect | \"\\(.x),\\(.y) \\(.width)x\\(.height)\"' | ~a -b ~a -B ~a"
            #$(file-append sway "/bin/swaymsg")
            #$(file-append jq "/bin/jq")
            #$(file-append slurp "/bin/slurp")
            "303030AA"
            "303030AA"))

(define* (shot-script subject #:key output geom (file "-"))
  (program-file
   (string-append "sway-shot-" subject)
   #~(system
      (format #f "~a ~a~a~a | ~a"
              #$(file-append grim "/bin/grim")
              #$(if output #~(string-append "-o \"$(" #$output ")\" ") "")
              #$(if geom #~(string-append "-g \"$(" #$geom ")\" ") "")
              #$file
              #$(file-append wl-clipboard "/bin/wl-copy")))))

(define shot-output
  (shot-script "output" #:output subject-output))

(define shot-window-or-selection
  (shot-script "window-or-selection" #:geom subject-window-or-selection))

(define swappy-clipboard
  (program-file
   "sway-swappy-clipboard"
   #~(system
      (format #f "~a | ~a -f -"
              #$(file-append wl-clipboard "/bin/wl-paste")
              #$(file-append swappy "/bin/swappy")))))
#+end_src
***** Screen lockers
****** Swaylock
#+begin_src scheme
(define* (he-swaylock #:key
                      colors
                      font
                      time-format
                      date-format
                      ;; TODO `serialize-swaylock-config` doesn't presently allow gexps.
                      ;; (image "/home/pharcosyle/work/phrenetic/phrenetic/alucard_bg.png")
                      (image "/.persist/home/pharcosyle/work_for_now/phrenetic/phrenetic/alucard_bg.png")
                      ;; (image wallpaper)
                      extra-config)
  (list
   (service
    home-swaylock-service-type
    (home-swaylock-configuration
     (swaylock swaylock-effects)
     (config
      (let ((clr (lambda* (color #:optional alpha)
                   (as-> color $
                         (assoc-ref colors $)
                         (string-drop $ 1)
                         (string-append $ (or alpha ""))))))
        `((daemonize)

          (font . ,(assoc-ref font #:font/name))
          (image . ,image)

          (indicator)
          (indicator-idle-visible)
          (indicator-caps-lock)
          (indicator-radius . "150")
          (indicator-thickness . "10")

          (key-hl-color . ,(clr #:color/green))
          (bs-hl-color . ,(clr #:color/yellow))
          (inside-color . ,(clr #:color/bg "7F"))

          (ring-color . ,(clr #:color/bg))
          (ring-clear-color . ,(clr #:color/bg "7F"))
          (ring-ver-color . ,(clr #:color/bg "7F"))
          (ring-wrong-color . ,(clr #:color/bg "7F"))

          (text-clear-color . ,(clr #:color/orange))
          (text-ver-color . ,(clr #:color/blue))
          (text-wrong-color . ,(clr #:color/red))
          (inside-clear-color . ,(clr #:color/orange))
          (inside-ver-color . ,(clr #:color/blue))
          (inside-wrong-color . ,(clr #:color/red))

          (text-color . ,(clr #:color/violet))
          (separator-color . "00000000")
          (line-uses-ring)

          ;; Effects

          (grace . "15")
          (effect-blur . 7x5)
          (fade-in . "2")

          (clock)
          (timestr . ,time-format)
          (datestr . ,date-format)

          ,@(or extra-config '()))))))))

(define (swaylock-screen-locker)
  "/run/setuid-programs/swaylock")

(define (swaylock-screen-locker-immediate)
  #~(string-append #$(swaylock-screen-locker) " --grace=0"))
#+end_src
******* WAIT [#E] Change ~swaylock-screen-locker~ to a store path
According to Andrew Tropin this can happen once [[https://issues.guix.gnu.org/53468][{RFC PATCH} gnu: linux-pam: Change path to unix_chkpwd helper]] is merged (currently it's only on =core-updates=).
Does this also mean I won't have to add Swaylock at the system level (as a ~screen-locker-service~) as well? I likely won't have to figure it out myself, just see what happens in RDE after the fix is merged.
***** Idle managers
****** Swayidle
#+begin_src scheme
(define* (he-swayidle #:key
                      sway?
                      screen-locker
                      (lock-timeout 300)
                      extra-config)
  (list
   (service
    home-swayidle-service-type
    (home-swayidle-configuration
     (config
      `(,@(if screen-locker
              (let ((lock-cmd-quoted (format #f "'~a'" screen-locker)))
                `((lock ,lock-cmd-quoted)
                  (before-sleep ,lock-cmd-quoted)
                  (timeout ,lock-timeout ,lock-cmd-quoted)))
              '())
        ,@(or extra-config '())))))

   (when sway?
     (let* ((swaymsg (file-append sway "/bin/swaymsg"))
            (swaymsg-cmd (lambda (cmd)
                           #~(format #f "'~a \"~a\"'" #$swaymsg #$cmd)))
            (idle-timeout (+ lock-timeout 30)))
       (simple-service
        'swayidle-add-sway-dpms
        home-swayidle-service-type
        `((timeout ,idle-timeout ,(swaymsg-cmd "output * dpms off") resume ,(swaymsg-cmd "output * dpms on"))))))))

(define (swayidle-idle-manager)
  #~(string-append #$(file-append swayidle "/bin/swayidle") " -w"))
#+end_src
***** Notification daemons
****** Mako
#+begin_src scheme
(define* (he-mako #:key
                  sway?
                  menu
                  colors
                  font)
  (list
   (simple-service
    'mako-add-packages
    home-profile-service-type
    (list mako
          jq)) ; Required to use `makoctl menu'. Ideally this would be part of the Guix package. ; TODO Make a custom Mako package (perhaps just adding `jq` to the propagated inputs initially).

   (simple-service
    'mako-config
    home-xdg-configuration-files-service-type
    `(("mako/config"
       ,(ini-file
         "mako-config"
         (let ((clr (lambda* (color #:optional alpha)
                      (as-> color $
                            (assoc-ref colors $)
                            (string-append $ (or alpha ""))))))
           `((global ((font . ,(string->symbol (font-specification font)))
                      (max-icon-size . ,(string->symbol "32"))
                      (text-color . ,(string->symbol (clr #:color/fg)))
                      (background-color . ,(string->symbol (clr #:color/bg "1A"))) ; TODO why isn't the transparency working right?
                      (border-color . ,(string->symbol (clr #:color/accent)))
                      (border-size . ,(string->symbol "2"))
                      (border-radius . ,(string->symbol "8"))))
             (urgency=low ((border-color . ,(string->symbol (clr #:color/green)))))
             (urgency=high ((border-color . ,(string->symbol (clr #:color/red)))))))
         #:ini-serialize
         (lambda (config)
           (ini-serialize config #:equal-string "="))))))

   (when sway?
     (simple-service
      'mako-add-to-sway
      home-sway-service-type
      `((exec ,(file-append mako "/bin/mako"))
        ,@(let ((makoctl (file-append mako "/bin/makoctl")))
            `((bindsym $mod+m exec ,makoctl dismiss)
              (bindsym $mod+Shift+m exec ,makoctl restore)
              (bindsym $mod+Control+m exec ,makoctl menu ,menu "\"Notification action\""))))))))
#+end_src
***** Status bars
****** Waybar
#+begin_src scheme
(define* (he-waybar #:key
                    colors
                    font
                    sway?
                    modules
                    transitions?)
  (append
   (list
    (service
     home-waybar-service-type
     (home-waybar-configuration
      (config #(((position . top)
                 (name . main))))
      (style-css
       `(,#~#$(->> `(("fg" . #:color/fg)
                     ("bg" . #:color/bg)
                     ("bg-alt" . #:color/base0) ; TODO change this (previously I had it as lighter than bg, not darker)
                     ("accent" . #:color/accent)
                     ("green" . #:color/green)
                     ("orange" . #:color/orange)
                     ("red" . #:color/red))
                   (map (match-lambda
                          ((name . color)
                           (string-append "@define-color " name " " (assoc-ref colors color) ";\n"))))
                   (apply string-append))
              (*
               ((font-family . #(FontAwesome
                                 ,@(if font
                                       (list
                                        (-> font (assoc-ref #:font/name) string->symbol))
                                       '())))
                ,@(if transitions? '() '((transition . none)))
                (box-shadow . none)
                (text-shadow . none)
                (min-height . 0)))

              (tooltip
               ((border . (solid @bg-alt))
                (background . @bg)
                (opacity . 0.9)))

              ((tooltip label)
               ((color . @fg)
                (padding . 0)))

              (#{#waybar}#
               ((color . @fg)
                (background . @bg)))

              (#((.modules-right label)
                 (.modules-right image))
               ((margin . (0.4em 0.2em))
                (padding . (0 0.4em))
                (background . @bg-alt)
                (border-radius . 0.2em)))

              ;; To accommodate the crack in my screen.
              (.modules-left
               ((margin-left . 82px)))
              ;; (.modules-left
              ;;  ((margin-left . 0.2em)))

              (.modules-right
               ((margin-right . 0.2em))))))))

   modules

   (list
    (simple-service
     'waybar-add-font-package
     home-profile-service-type
     (list font-awesome))

    (simple-service
     'waybar-reload-config-on-change
     home-run-on-change-service-type
     (let ((reload-cmd #~(system* #$(file-append psmisc "/bin/killall") "-SIGUSR2" "waybar")))
       `(("files/.config/waybar/style.css"
          ,reload-cmd)
         ("files/.config/waybar/config"
          ,reload-cmd))))

    ;; I could pass the waybar command to the sway module (like I do with the screen locker and idle manager) instead of making this module aware of Sway, however the the `bar' command can take other arguments (see https://man.archlinux.org/man/sway-bar.5.en) that I might perhaps need in the future (though I think they only apply to swaybar, not waybar).
    (when sway?
      (simple-service
       'waybar-add-to-sway
       home-sway-service-type
       `((bar swaybar_command ,(file-append waybar "/bin/waybar"))
         (bindsym $mod+backslash exec ,(file-append psmisc "/bin/killall") -SIGUSR1 waybar)))))))

(define* (waybar-modules #:key
                         sway?
                         date-format
                         time-format)
  (append
   (list
    (waybar-clock #:date-format date-format
                  #:time-format time-format))
   (if sway?
       (list
        (waybar-sway-workspaces)
        (waybar-sway-window))
       '())
   (let ((show-percentage? #f))
     (list
      (waybar-tray)
      (waybar-idle-inhibitor)
      (waybar-volume #:show-percentage? show-percentage?)
      (waybar-microphone #:show-percentage? show-percentage?)
      (waybar-backlight #:show-percentage? show-percentage?)
      (waybar-cpu)
      (waybar-memory)
      (waybar-battery #:show-percentage? #t)))))
#+end_src
******* Modules
#+begin_src scheme
(define* (waybar-module name
                        #:optional
                        config
                        style
                        #:key
                        (placement 'modules-right)
                        (bar-id 'main))
  (simple-service
   (symbol-append 'waybar-module- name)
   home-waybar-service-type
   (home-waybar-extension
    (config `#(((name . ,bar-id)
                (,placement . #(,name))
                (,name . ,(if config
                              config '())))))
    (style-css (if style
                   style '())))))
#+end_src
******** Backlight
#+begin_src scheme
(define* (waybar-backlight #:key show-percentage?)
  (waybar-module
   'backlight
   `((format . ,(string-append
                 "{icon} "
                 (if show-percentage? "{percent}" "")))
     (fomat-icons . #(    )))))
#+end_src
******** Battery
#+begin_src scheme
(define* (waybar-battery #:key show-percentage?)
  (waybar-module
   'battery
   (let ((base-format (string-append
                       "{icon} "
                       (if show-percentage? "{capacity}%" ""))))
     `((format . ,base-format)
       (format-charging . ,(string-append " " base-format))
       (states . ((empty . 10)
                  (low . 20)
                  (half-low . 40)
                  (half . 60)
                  (high . 90)
                  (full . 100)))
       (format-icons . ((empty . )
                        (low . )
                        (half-low . )
                        (half . )
                        (high . )
                        (full . )))
       (tooltip-format . "Current capacity: {capacity}%\n\n{timeTo}")))
   `((#{#battery.discharging.empty}#
      ((color . @red)))
     (#{#battery.discharging.low}#
      ((color . @orange)))
     (#{#battery.full}#
      ((color . @green))))))
#+end_src
******** Clock
#+begin_src scheme
(define* (waybar-clock #:key
                       date-format
                       time-format)
  (waybar-module
   'clock
   `((tooltip-format . "<big>{:%Y %B}</big>\n<tt><small>{calendar}</small></tt>")
     ;; Workarounds for https://github.com/Alexays/Waybar/issues/1452.
     (format . ,(string-append "{:"
                               ((@ (ice-9 string-fun) string-replace-substring) date-format "%-d" "%d")
                               "  "
                               ((@ (ice-9 string-fun) string-replace-substring) time-format "%-I" "%I")
                               "}")))
   '()
   #:placement 'modules-left))
#+end_src
******** CPU
#+begin_src scheme
(define (waybar-cpu)
  (waybar-module
   'cpu
   '((format . " {usage}%"))))
#+end_src
******** Idle inhibitor
#+begin_src scheme
(define (waybar-idle-inhibitor)
  (waybar-module
   'idle_inhibitor
   '((format . {icon})
     (format-icons . ((activated . )
                      (deactivated . ))))))
#+end_src
******** Memory
#+begin_src scheme
(define (waybar-memory)
  (waybar-module
   'memory
   '((format . " {}%"))))
#+end_src
******** Microphone
#+begin_src scheme
(define* (waybar-microphone #:key show-percentage?)
  (waybar-module
   'pulseaudio#source
   `((format . "{format_source}")
     (format-source . ,(string-append
                        (if show-percentage? "{volume}% " "")
                        ""))
     (format-source-muted . "")
     (tooltip-format . "{source_desc} is on {source_volume}%")
     (on-click . ,#~(let ((cmd (string-append #$(file-append pavucontrol "/bin/pavucontrol") " --tab=4")))
                      (string-append "\"" cmd "\""))))))
#+end_src
******** Tray
#+begin_src scheme
(define (waybar-tray)
  (waybar-module
   'tray
   `()
   `(((#{#tray}# menu)
      ((color . @fg)
       (background . @bg)
       (border . (solid 1px))
       (border-color . @bg-alt)))

     ((#{#tray}# menu menuitem)
      ((padding-top . 0px)
       (padding-bottom . 0px)
       (margin-top . 0.1em)
       (margin-bottom . 0em)))

     ((#{#tray}# menu menuitem:hover)
      ((background . none)))

     ((#{#tray}# menu separator)
      ((background . @bg-alt)
       (padding-top . 1px)
       (margin-top . 0.2em)
       (margin-bottom . 0.2em))))))
#+end_src
******** Volume
#+begin_src scheme
(define* (waybar-volume #:key show-percentage?)
  (waybar-module
   'pulseaudio#sink
   (let ((base-format (string-append
                       (if show-percentage? "{volume}% " "")
                       "{icon}")))
     `((format . ,base-format)
       (format-muted . "")
       (format-bluetooth . ,(string-append base-format ""))
       (format-icons . ((default . #(   ))))
       (tooltip-format . "{desc} is on {volume}%")
       (on-click . ,#~(let ((cmd #$(file-append pavucontrol "/bin/pavucontrol")))
                        (string-append "\"" cmd "\"")))))))
#+end_src
******** Sway
********* Sway window
#+begin_src scheme
(define (waybar-sway-window)
  (waybar-module
   'sway/window
   `()
   `((#{#window}#
      ((margin-left . 1em)
       (margin-right . 1em))))
   #:placement 'modules-center))
#+end_src
********* Sway workspaces
#+begin_src scheme
(define* (waybar-sway-workspaces
          #:key
          persistent-workspaces
          (format-icons '(("1" . )
                          ("2" . )
                          ("3" . )
                          ("4" . )
                          ("5" . )
                          ("6" . ) ; 
                          ("7" . )  ; 
                          ("8" . )
                          ("9" . )
                          ("10" . )
                          ("urgent" . )
                          ("focused" . )
                          ("default" . ))))
  (waybar-module
   'sway/workspaces
   `((disable-scroll . #t)
     (format . {icon})
     (format-icons . ,format-icons)
     (persistent_workspaces . ,(if persistent-workspaces
                                   persistent-workspaces '())))
   `(((#{#workspaces}# button)
      ((background . none)
       (border-radius . 0.2em)
       (margin . (0.4em 0.2em))
       (padding . (0.1em 0.2em))
       (color . @fg)))

     ((#{#workspaces}# button:hover)
      ((background . none)
       (border-color . @accent)))

     ((#{#workspaces}# button.focused)
      ((background . @bg-alt)
       (color . @accent)))

     ((#{#workspaces}# button.urgent)
      ((color . @red))))
   #:placement 'modules-left))
#+end_src
***** Display configuration
****** Kanshi
#+begin_src scheme
(define* (he-kanshi #:key extra-config)
  (list
   (service
    home-kanshi-service-type
    (home-kanshi-configuration
     (config
      `(,@(or extra-config '())))))))
#+end_src
*** Programs
**** AWS
#+begin_src scheme
(define (he-aws)
  (list
   (simple-service
    'aws-add-package
    home-profile-service-type
    (list awscli-2))))
#+end_src
***** AWS CLI 2 :package:version:upstream:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "packages/aws.scm")
:END:
- TODO
  - generate the autocompletion index
    As described here:
    [[https://github.com/aws/aws-cli/tree/v2#cli-dev-version][GitHub - aws/aws-cli at v2 (cli dev version)]]
    [[https://github.com/NixOS/nixpkgs/blob/nixos-unstable/pkgs/tools/admin/awscli2/default.nix#L95][nixpkgs/default.nix at nixos-unstable  NixOS/nixpkgs  GitHub]]
  - set up command completion
    [[https://github.com/aws/aws-cli/tree/v2#command-completion][GitHub - aws/aws-cli at v2 (command completion)]]
  - [2022-04-13 Wed] dependencies don't need to be propagated?
    [[https://github.com/guix-mirror/guix/commit/fc89b50b7bb2edbc38b20adf8c899934dedcb6c3][gnu: awscli: Do not propagate inputs.  guix-mirror/guix@fc89b50  GitHub]]
    This is for v1, might not apply here. At the time of this writing, this commit is only two hours old, see if there's any follow-up.
#+begin_src scheme
(define-module (phrenetic packages aws)
  #:use-module (guix build-system python)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages check) #:select (python-mock python-pytest python-coverage python-pytest-cov python-pytest-xdist))
  #:use-module ((gnu packages cmake) #:select (cmake))
  #:use-module ((gnu packages groff) #:select (groff))
  #:use-module ((gnu packages python-web) #:select (awscli) #:prefix python-web:)
  #:use-module ((gnu packages python-web) #:select (python-urllib3))
  #:use-module ((gnu packages python-xyz) #:select (python-prompt-toolkit) #:prefix python:)
  #:use-module ((gnu packages python-xyz) #:select (python-colorama-for-awscli python-docutils-0.15 python-wcwidth python-distro python-jmespath python-boto3 python-botocore python-six python-jsonschema))
  #:use-module ((gnu packages python-crypto) #:select (python-cryptography) #:prefix python-crypto:)
  #:use-module ((gnu packages serialization) #:select (python-ruamel.yaml))
  #:use-module ((gnu packages time) #:select (python-dateutil)))

(define-public awscli-2
  (package
    (inherit python-web:awscli)
    (version "2.4.23")
    (source
     (origin
       (method git-fetch)
       (uri (git-reference
             (url "https://github.com/aws/aws-cli")
             (commit version)))
       (sha256
        (base32
         "1xdgj6w6ibfiwpzd85g9lhk106nxrw06c9bdcrmfr68zaa32k6ff"))
       (file-name (git-file-name (package-name python-web:awscli) version))))
    (arguments
     (substitute-keyword-arguments (package-arguments python-web:awscli)
       ;; A few tests fail at present but I'm not gonna sweat it. A number more error but I think that's mostly due to the lack of network access. The vast majority pass:
       ;; Total tests ~7000 (failures=3, errors=222, skipped=6)
       ((#:tests? _) #f)))
    (propagated-inputs
     (list python-colorama-for-awscli
           python-docutils-0.15
           python-cryptography
           python-ruamel.yaml-0.15
           python-wcwidth
           python-prompt-toolkit
           python-distro-1.5
           python-awscrt
           python-dateutil
           python-jmespath
           python-urllib3))
    (native-inputs
     (list groff
           ;; For tests.
           python-jsonschema
           python-mock
           python-pytest
           python-coverage
           python-pytest-cov
           python-pytest-xdist))))
#+end_src
****** Deps :package:version:
#+begin_src scheme
(define python-awscrt
  (package
    (name "python-awscrt")
    (version "0.12.4")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "awscrt" version))
       (sha256
        (base32 "1cmfkcv2zzirxsb989vx1hvna9nv24pghcvypl0zaxsjphv97mka"))))
    (build-system python-build-system)
    (native-inputs
     (list
      cmake
      ;; For tests.
      python-boto3))
    (home-page "https://github.com/awslabs/aws-crt-python")
    (synopsis "A common runtime for AWS Python projects")
    (description "This package provides a common runtime for AWS Python projects")
    (license license:asl2.0)))

(define python-cryptography
  (package
    (inherit python-crypto:python-cryptography)
    (version "3.3.2")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "cryptography" version))
       (sha256
        (base32
         "1vcvw4lkw1spiq322pm1256kail8nck6bbgpdxx3pqa905wd6q2s"))))))

(define python-ruamel.yaml-0.15
  (package
    (inherit python-ruamel.yaml)
    (version "0.15.100")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "ruamel.yaml" version))
       (sha256
        (base32
         "1r5j9n2jdq48z0k4bdia1f7krn8f2x3y49i9ba9iks2rg83g6hlf"))))))

(define python-prompt-toolkit
  (package
    (inherit python:python-prompt-toolkit)
    (version "3.0.28")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "prompt_toolkit" version))
       (sha256
        (base32
         "0l0nnm9fvs8lklk2qq8mylb9jrlxvlqzpmqr4n7rdhl63rmx274z"))))))

(define python-distro-1.5
  (package
    (inherit python-distro)
    (version "1.5.0")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "distro" version))
       (sha256
        (base32
         "14nz51cqlnxmgfqqilxyvjwwa5xfivdvlm0d0b1qzgcgwdm7an0f"))))))
#+end_src
**** Clojure
#+begin_src scheme
(define* (he-clojure #:key
                     stateless?
                     doom?
                     (jdk (list openjdk17 "jdk"))) ; Newest LTS release.
  (append
   (list
    (simple-service
     'clojure-add-packages
     home-profile-service-type
     (list clojure-tools
           jdk
           clj-kondo))

    (when stateless?
      (home-stateless-service
       'clojure
       #:state '(((#:path . ".m2/")
                  (#:store . #:machine))))))

   (if doom?
       (doom-clojure #:stateless? stateless?) '())))
#+end_src
***** Clojure tools :package:
#+begin_src scheme :tangle (meta-in-dir "packages/clojure.scm")
(define-module (phrenetic packages clojure)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages clojure) #:select (clojure-tools) #:prefix clojure:))

(define (with-man-pages clojure-tools)
  (package
    (inherit clojure-tools)
    (arguments
     (substitute-keyword-arguments (package-arguments clojure-tools)
       ((#:install-plan install-plan)
        #~(append #$install-plan '(("clojure.1" "/share/man/man1/")
                                   ("clj.1" "/share/man/man1/"))))))))

(define-public clojure-tools
  (with-man-pages clojure:clojure-tools))
#+end_src
***** Doom Clojure
#+begin_src scheme
(define* (doom-clojure #:key stateless?)
  (append
   (let ((name 'clojure))
     (list
      (doom-service
       name
       #:modules '((#:lang
                    clojure))
       #:config
       `((use-package! clojure-mode
                       :defer t
                       :init
                       (setq clojure-refactor-map-prefix (kbd "s-M r")) ; Has to be set before clojure-mode loads. ; REVIEW temporary binding
                       :config
                       (set-ligatures! 'clojure-mode :lambda "fn"))

         (use-package! cider
                       :defer t
                       :init
                       (-each '((cider-preferred-build-tool symbolp)
                                (cider-default-cljs-repl symbolp)
                                (cider-shadow-default-options stringp)
                                (cider-offer-to-open-cljs-app-in-browser booleanp)
                                (cider-clojure-cli-global-options stringp)
                                (cider-clojure-cli-global-options booleanp))
                              (-lambda ((sym f))
                                       (put sym 'safe-local-variable f)))
                       :config
                       (setq cider-repl-history-size ,very-big-history
                             cider-print-options '(("length" 100)))) ; TODO Upstream this fix. Also re-evaluate if it's necessary?

         ;; REVIEW make sure this is still working after nesting in `after!'
         (after! cider-repl
                 (add-hook! 'cider-repl-mode-hook
                            #'goto-address-prog-mode
                            #'highlight-numbers-mode
                            #'rainbow-delimiters-mode
                            #'yas-minor-mode-on
                            #'biome-sp-strict-h))

         (after! clj-refactor
                 (cljr-add-keybindings-with-prefix "s-M R")))) ; REVIEW temporary binding

      (when stateless?
        (doom-stateless-service
         name
         #:state '(((#:path . ("cider-repl-history" #:doom-base #:cache))
                    (#:store . #:persist)))))))

   (doom-xml+csv)
   (doom-dash)))
#+end_src
**** Datomic
#+begin_src scheme
(define (he-datomic)
  (list
   (simple-service
    'datomic-add-package
    home-profile-service-type
    (list datomic-cli-tools))))
#+end_src
***** Datomic CLI tools :package:version:upstream:
#+begin_src scheme :tangle (meta-in-dir "packages/datomic.scm")
(define-module (phrenetic packages datomic)
  #:use-module (guix build-system copy)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((gnu packages compression) #:select (unzip))
  #:use-module ((nonguix licenses) #:prefix license:))

(define-public datomic-cli-tools
  (package
    (name "datomic-cli-tools")
    (version "1.0.91")
    (source
     (origin
       (method url-fetch)
       (uri (string-append "https://datomic-releases-1fc2183a.s3.amazonaws.com/tools/datomic-cli/datomic-cli-" version ".zip"))
       (sha256
        (base32
         "1xicmbsig8f1p5r9rxkhndi0f9l9w421zf49rbx44yc6v0db523b"))))
    (build-system copy-build-system)
    (arguments
     `(#:install-plan
       '(("." "bin" #:include-regexp ("^\\./datomic")) ; Files that start with "datomic" are the scripts. Restrict to this subset to automatically pick up any added in the future without being too inclusive about what we add to bin.
         ("README.txt" "share/doc/datomic/"))
       #:phases
       ,#~(modify-phases %standard-phases
            (add-after 'install 'make-scripts-executable
              (lambda _
                (for-each (lambda (f) (chmod f #o555))
                          (find-files (string-append #$output "/bin"))))))))
    (native-inputs
     (list unzip))
    (home-page "https://docs.datomic.com/cloud/index.html")
    (synopsis "CLI tools for Datomic")
    (description synopsis)
    (license (license:nonfree "https://www.datomic.com/cloud-eula.html"))))
#+end_src
**** Doom calendar
#+begin_src scheme
(define* (he-doom-calendar #:key
                           stateless?
                           org?)
  (append
   (list
    (doom-service
     'calendar
     #:modules '((#:app
                  calendar))))

   (if org?
       (doom-org-gcal #:stateless? stateless?) '())))

(define* (doom-org-gcal #:key stateless?)
  (append
   (let ((name 'org-gcal))
     (list
      (doom-service
       name
       #:modules '((#:app
                    calendar))
       #:config
       '((after! org-gcal
                 (setq org-gcal-client-id "446729771716-pp79934q99aro2h8v3iki1fejcodbdoo.apps.googleusercontent.com"
                       org-gcal-client-secret (-> (auth-source-search :host org-gcal-client-id) car (plist-get :secret) funcall)
                       org-gcal-recurring-events-mode 'nested))))

      (when stateless?
        (doom-stateless-service
         name
         #:state '(((#:path . ("org-gcal/token.gpg" #:doom-base #:cache))
                    (#:store . #:machine))
                   ((#:path . ("persist/org-gcal--sync-tokens" #:doom-base #:data))
                    (#:store . #:machine)))))))

   (doom-dash)))

;; TODO
;; - This comonent no longers depens on doom-user so don't rely on user-mail-address?
;; - nb: also it uses `org-directory'
;; '((after! org-gcal
;;           (setq ;; TODO `elisp-serialize' doesn't like the unquotes.
;;                 ;; org-gcal-fetch-file-alist (let ((cal-dir concat org-directory "/cal"))
;;                 ;;                             `((user-mail-address . ,(concat cal-dir "/" user-mail-address ".org"))
;;                 ;;                               ("addressbook%23contacts@group.v.calendar.google.com" . ,(concat cal-dir "/contacts.org"))
;;                 ;;                               ("en.usa%23holiday@group.v.calendar.google.com" . ,(concat cal-dir "/holidays.org"))))
;;                 )))
#+end_src
**** Doom org :bindings:
#+begin_src scheme
(define* (he-doom-org #:key
                      stateless?
                      evil?)
  (let ((org-dir "org"))
    (append
     (doom-org #:evil? evil?
               #:org-dir org-dir)

     (list
      (when stateless?
        (home-stateless-service
         'org
         #:state `(((#:path . ,(string-append org-dir "/"))
                    (#:store . #:persist)))))))))

(define* (doom-org #:key
                   stateless?
                   evil?
                   org-dir)
  (append
   (let ((name 'org))
     (list
      (doom-service
       name
       #:modules '((#:lang
                    (org +journal)))
       #:config
       (append
        `((use-package! org
                        :defer t
                        :init
                        (setq org-directory ,(string-append "~/" org-dir))
                        :config
                        (setq org-log-done 'time
                              org-priority-lowest ?E
                              org-priority-default ?C
                              org-priority-faces
                              (-map (-lambda ((priority color))
                                             (cons priority (doom-color color)))
                                    '((?A red)
                                      (?B orange)
                                      (?C blue)
                                      (?D yellow)
                                      (?E green)))))

          (after! ob
                  (setq org-babel-noweb-error-all-langs t)))

        (if evil?
            '((after! evil-org
                      (map! :map evil-org-mode-map
                            :nv "C-j" #'outline-forward-same-level
                            :nv "C-k" #'outline-backward-same-level)))
            '())))

      (when stateless?
        (doom-stateless-service
         name
         #:state '(((#:path . ("org-clock-save.el" #:doom-base #:data))
                    (#:store . #:persist))
                   ((#:path . ("org/persist/" #:doom-base #:cache))
                    (#:store . #:machine)))))))

   (doom-dash)))
#+end_src
**** Direnv
#+begin_src scheme
(define* (he-direnv #:key
                    doom?
                    shells)
  (append
   (list
    (simple-service
     'direnv-add-package
     home-profile-service-type
     (list direnv))

    (simple-service
     'direnv-rc
     home-xdg-configuration-files-service-type
     `(("direnv/direnvrc" ,(local-file "direnvrc")))))

   (map (lambda (shell)
          (let ((direnv-hook
                 (lambda (shell-name)
                   (let ((direnv-bin (file-append direnv "/bin/direnv")))
                     (mixed-text-file
                      "direnv-hook"
                      "command -v " direnv-bin " > /dev/null && eval \"$(" direnv-bin " hook " shell-name ")\"")))))
            (case shell
              ;; ((#:shell/bash) (simple-service
              ;;                  'direnv-bash-hook
              ;;                  home-bash-service-type
              ;;                  (home-bash-extension
              ;;                   (bashrc
              ;;                    (list (direnv-hook "bash"))))))
              ((#:shell/zsh) (simple-service
                              'direnv-zsh-hook
                              home-zsh-service-type
                              (home-zsh-extension
                               (zshrc
                                (list (direnv-hook "zsh")))))))))
        shells)

   (list
    (when doom?
      (doom-service
       'direnv
       #:modules '((#:tools
                    direnv)))))))
#+end_src
***** Direnvrc
#+begin_src sh :tangle (meta-in-dir "direnvrc")
use_guixs() {
	LOCK_FILE=channels-lock

	if [ -f $LOCK_FILE ]; then
		eval "$(guix time-machine --channels=$LOCK_FILE -- shell --search-paths "$@")"
	else
		eval "$(guix shell --search-paths "$@")"
	fi
}
#+end_src
***** Whitelist service
#+begin_src scheme
(define direnv-whitelist-service-type
  (service-type
   (name 'direnv-whitelist)
   (extensions
    (list (service-extension home-xdg-configuration-files-service-type
                             (lambda (whitelist-entries)
                               `(("direnv/direnv.toml"
                                  ,(toml-file
                                    "direnv-config"
                                    (if (null? whitelist-entries)
                                        '()
                                        `((whitelist ((exact . ,(serialize-toml-array whitelist-entries)))))))))))))
   (compose concatenate)
   (extend (lambda (_ whitelist-entries)
             whitelist-entries))
   (default-value #f)
   (description "Whitelist for Direnv.")))
#+end_src
****** TOML serialization
#+begin_src scheme
(define (toml-file name config)
  (ini-file name config))

(define (serialize-toml-array elements)
  (as-> elements $
        (map (lambda (element)
               (string-append "\"" element "\""))
             $)
        (string-join $ ", ")
        (string-append "[ " $ " ]")
        (string->symbol $)))
#+end_src
**** Nano
#+begin_src scheme
;; (define (he-nano)
;;   (list
;;    ;; (simple-service
;;    ;;  'nano-add-package
;;    ;;  home-profile-service-type
;;    ;;  (list nano))

;;    (simple-service
;;     'nano-add-config
;;     home-xdg-configuration-files-service-type
;;     `(("nano/nanorc"
;;        ,(local-file (skeleton-file ".config/nano/nanorc")))))))
#+end_src
**** Node
#+begin_src scheme
(define* (he-node #:key
                  stateless?
                  doom?
                  doom-tree-sitter?)
  (append
   (list
    (simple-service
     'node-add-package
     home-profile-service-type
     (list node))

    ;; (when stateless?
    ;;   (home-stateless-service
    ;;    'node
    ;;    #:state '(((#:path . ".npm/")
    ;;               (#:store . #:machine)))))
    )

   (if doom?
       (doom-javascript #:tree-sitter? doom-tree-sitter?) '())))
#+end_src
**** Proton VPN
#+begin_src scheme
(define* (he-protonvpn #:key stateless?)
  (list
   (simple-service
    'protonvpn-add-package
    home-profile-service-type
    (list protonvpn-cli))

   (when stateless?
     (home-stateless-service
      'protonvpn
      #:state '(((#:path . ".pvpn-cli/")
                 (#:store . #:machine)))))))
#+end_src
**** SSH
#+begin_src scheme
(define (he-ssh)
  (list
   (service home-openssh-service-type)))
#+end_src
**** File managers
***** Doom dired
#+begin_src scheme
(define* (he-doom-dired #:key
                        stateless?
                        icons?)
  (let ((dirvish? #t))
    (append
     (let ((name 'dired))
       (list
        (doom-service
         name
         #:modules `((#:emacs
                      (dired ,@(if icons? '(+icons) '())
                             ,@(if dirvish? '(+dirvish) '())))))

        (when (and stateless? dirvish?)
          (doom-stateless-service
           name
           #:state '(((#:path . ("dirvish/" #:doom-base #:cache))
                      (#:store . #:machine)))))))

     (if dirvish?
         (doom-transient) '()))))
#+end_src
**** Menus and launchers
***** Doom app launcher
#+begin_src scheme
(define (he-doom-app-launcher)
  (list
   (doom-service
    'app-launcher
    #:packages
    '((package! app-launcher
                :recipe (:host github
                         :repo "SebastienWae/app-launcher")
                :pin "d5015e394b0a666a8c7c4d4bdf786266e773b145")))))
#+end_src
***** Rofi
#+begin_src scheme
(define* (he-rofi #:key
                  stateless?
                  wayland?
                  colors
                  font)
  (list
   (service
    home-rofi-service-type
    (home-rofi-configuration
     (rofi (get-rofi wayland?))
     ;; TODO Trying out Andrew Tropin's confguration as-is for now, revisit later.
     (config-rasi
      `((configuration
         ((modi . "run,ssh,drun")
          (drun-show-actions . #t)
          (show-icons . #t)
          (font . ,(font-specification font))

          (kb-row-tab . "")
          (kb-row-select . "Tab")
          (kb-secondary-paste . "Control+y")
          (kb-remove-word-forward . "Alt+d")
          (kb-remove-word-back . "Control+w,Control+BackSpace")
          (kb-clear-line . "Control+slash")
          (kb-page-next . "Control+v")
          (kb-page-prev . "Alt+v")))

        ,#~"@theme \"paper-float\""
        ;; ,@(let ((clr (lambda* (color #:optional alpha)
        ;;                (as-> color $
        ;;                      (assoc-ref colors $)
        ;;                      (string-append $ (or alpha ""))))))
        ;;     `((*
        ;;        (;; (white . ,(clr #:color/fg))
        ;;         ;; (black . ,(clr #:color/bg))
        ;;         ;; (grey . ,(clr #:color/...))
        ;;         ;; (blue . ,(clr #:color/blue))
        ;;         (background . "#000000BF")))))
        ;; (window
        ;;  ((transparency . "real")))
        ))))

   (when stateless?
     (home-stateless-service
      'rofi
      #:state '(((#:path . ("rofi3.druncache" #:xdg-base "XDG_CACHE_HOME"))
                 (#:store . #:persist)))))))

(define* (rofi-menu #:key wayland?)
  #~(string-append #$(file-append (get-rofi wayland?) "/bin/rofi") " -dmenu -p"))

(define* (rofi-application-launcher #:key wayland?)
  #~(string-append #$(file-append (get-rofi wayland?) "/bin/rofi") " -show drun"))

(define (get-rofi wayland?)
  (if wayland?
      rofi-wayland
      rofi))
#+end_src
**** Trash
***** Doom trash
#+begin_src scheme
(define (he-doom-trash)
  (list
   (doom-service
    'trash
    #:packages
    '((package! trashed :pin "ddf5830730544435a068f2dc9ac75a81ea69df1d")))))
#+end_src
**** Version control
***** Git
#+begin_src scheme
(define* (he-git #:key
                 stateless?
                 doom?
                 email
                 sign-commits? ; TODO make this (sign-commits? #t) once I have my gpg stuff set up and I'm passing a gpg-sign-key.
                 gpg-sign-key
                 ;; git-send-email?
                 extra-config)
  (append
   (list
    ;; (when git-send-email?
    ;;   (simple-service
    ;;    'git-send-email-package
    ;;    home-profile-service-type
    ;;    (list (list git "send-email"))))
    (service
     home-git-service-type
     (home-git-configuration
      (config
       `((user
          ((email . ,email)
           ,@(if sign-commits?
                 `((signingkey . ,gpg-sign-key)) '())))
         ;; TODO stuff from feature-git, figure it out later
         ;; (merge
         ;;  ;; diff3 makes it easier to solve conflicts with smerge, zdiff3
         ;;  ;; should make a conflict scope smaller, but guile-git fails if
         ;;  ;; this option is set.
         ;;  ((conflictStyle . diff3)))
         ;; (diff
         ;;  ;; histogram should be smarter about diff generation.
         ;;  ((algorithm . histogram)))
         (commit
          (,@(if sign-commits?
                 '((gpgsign . #t)) '())))
         ;; (sendemail
         ;;  ((annotate . #t)))
         ;;  TODO these two (http and gpg) sections were in the RDE example home environment (but notably not in the rde feature-git). Figure out what they're for after I do gpg.
         ;; (http "https://weak.example.com"
         ;;       ((ssl-verify . #f)))
         ;; (gpg
         ;;  ((program . ,(file-append gnupg "/bin/gpg"))))
         ,@(or extra-config '()))))))

   (if doom?
       (doom-git #:stateless? stateless?) '())))
#+end_src
****** Doom Git
#+begin_src scheme
(define* (doom-git #:key stateless?)
  (append
   (doom-version-control)

   (list
    (doom-service
     'git
     #:modules '((#:tools
                  (magit +forge)))
     #:config
     '((after! magit
               (setq git-commit-style-convention-checks '(non-empty-second-line))
               (setq magit-revision-show-gravatars '("^Author:     " . "^Commit:     "))))))

   (doom-transient #:stateless? stateless?)))
#+end_src
******* Doom version control
#+begin_src scheme
(define (doom-version-control)
  (list
   (doom-service
    'version-control
    #:modules '((#:emacs
                 vc)
                (#:ui
                 (vc-gutter +pretty)))))) ; I tried `+diff-hl' but it was kind of buggy so wait on this. See https://github.com/doomemacs/doomemacs/commit/27a448b0.
#+end_src
**** Miscellaneous
#+begin_src scheme
(define (he-miscellaneous)
  (list
   (simple-service
    'miscellaneous-add-packages
    home-profile-service-type
    (list curl
          zip
          unzip))))
#+end_src
**** Apps
***** PulseAudio Volume Control
#+begin_src scheme
(define* (he-pavucontrol #:key
                         stateless?
                         gtk-services)
  (append
   (list
    (simple-service
     'pavucontrol-add-package
     home-profile-service-type
     (list pavucontrol))

    (when stateless?
      (home-stateless-service
       'pavucontrol
       #:state '(((#:path . ("pavucontrol.ini" #:xdg-base "XDG_CONFIG_HOME"))
                  (#:store . #:machine))))))

   (or gtk-services '())))
#+end_src
***** Image processing
****** GIMP
#+begin_src scheme
(define* (he-gimp #:key
                  stateless?
                  gtk-services)
  (append
   (list
    (simple-service
     'gimp-add-package
     home-profile-service-type
     (list gimp))

    (when stateless?
      (home-stateless-service
       'gimp
       #:state '(((#:path . ("gimp/" #:xdg-base "XDG_CACHE_HOME"))
                  (#:store . #:machine))
                 ((#:path . ("GIMP/" #:xdg-base "XDG_CONFIG_HOME"))
                  (#:store . #:machine))))))

   (or gtk-services '())))
#+end_src
***** Terminals
****** Alacritty
#+begin_src scheme
(define* (he-alacritty #:key
                       colors
                       font)
  (list
   (service
    home-alacritty-service-type
    (home-alacritty-configuration
     (config
      `((window . ((padding . ((x . 5)
                               (y . 5)))))
        (background_opacity . 0.75) ; Change this to window.opacity when Guix updates Alacritty version.
        ,@(if font
              `((font . ((normal . ,(append
                                     `((family . ,(assoc-ref font #:font/name)))
                                     (if-let ((weight (assoc-ref font #:font/weight)))
                                             `((style . ,(font-weight->style weight))) '())))
                         (size . ,(- (assoc-ref font #:font/size) 1)))))
              '())
        ,@(let ((clr (lambda (color)
                       (assoc-ref colors color))))
            `((colors . ((primary . ((background . ,(clr #:color/bg))
                                     (foreground . ,(clr #:color/fg))))
                         (normal . ((black . ,(clr #:color/base0))
                                    (white . ,(clr #:color/base8))
                                    (red . ,(clr #:color/red))
                                    (green . ,(clr #:color/green))
                                    (yellow . ,(clr #:color/yellow))
                                    (blue . ,(clr #:color/blue))
                                    (magenta . ,(clr #:color/magenta))
                                    (cyan . ,(clr #:color/cyan))))))))))))))

(define (font-weight->style weight)
  (->> weight
       symbol->string
       (string-delete #\-)
       string-capitalize))

(define (alacritty-terminal)
  (file-append alacritty "/bin/alacritty"))
#+end_src
****** Doom vterm
Does this belong in [[*Apps][Apps]]?
#+begin_src scheme
(define* (he-doom-vterm #:key setup-zsh?)
  (list
   (doom-service
    'vterm
    #:modules '((#:term
                 vterm)))

   (when setup-zsh?
     (simple-service
      'doom-vterm-zsh
      home-zsh-service-type
      (home-zsh-extension
       (zshrc
        (list (local-file "zsh-vterm"))))))))
#+end_src
******* Configure zsh for vterm
- TODO Changed the org source block type to "org" from "sh" because there's a fontification error. Maybe use zsh as the babel language instead of sh/bash, if it exists?
#+begin_src org :tangle (meta-in-dir "zsh-vterm")
vterm_printf(){
    if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ] ); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    elif ([ "${TERM%%-*}" = "eterm" ] || [ "${TERM%%-*}" = "dumb" ]); then
        # Do nothing for Emacs' term and ansi-term, and other dumb terminals.
    else
        printf "\e]%s\e\\" "$1"
    fi
}

vterm_prompt_end() {
    # USERNAME=$(whoami)
    # HOSTNAME=$(hostname)
    vterm_printf "51;A$USER@$HOST:$(pwd)";
}
setopt PROMPT_SUBST
PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'
#+end_src
***** Web browsers
If =ungoogled-chromium= had a wrapper script that added ~--ozone-platform-hint=auto~ it would avoid the necessity of having two different packages for X/Wayland.
****** Chromium
#+begin_src scheme
(define* (he-chromium #:key
                      stateless?
                      wayland?
                      gtk-services
                      flavors)
  (append
   (list
    (when (chromium? flavors)
      (simple-service
       'chromium-add-packages
       home-profile-service-type
       (append
        (if (member #:ungoogled-chromium flavors)
            (list (if wayland?
                      ungoogled-chromium/wayland
                      ungoogled-chromium))
            '())
        (if (member #:chromium flavors)
            (list chromium+drm)
            '())
        (list ublock-origin/chromium))))

    (when stateless?
      (home-stateless-service
       'chromium
       #:state (append
                (if (chromium? flavors)
                    '(((#:path . ("chromium/" #:xdg-base "XDG_CACHE_HOME"))
                       (#:store . #:machine)
                       (#:mode . #o700))
                      ((#:path . ("chromium/" #:xdg-base "XDG_CONFIG_HOME"))
                       (#:store . #:machine)
                       (#:mode . #o700)))
                    '())
                (if (chrome? flavors)
                    '(((#:path . ("google-chrome/" #:xdg-base "XDG_CACHE_HOME"))
                       (#:store . #:machine)
                       (#:mode . #o700))
                      ((#:path . ("google-chrome/" #:xdg-base "XDG_CONFIG_HOME"))
                       (#:store . #:machine)
                       (#:mode . #o700)))
                    '())
                '(((#:path . ".pki/nssdb/")
                   (#:store . #:machine)
                   (#:mode . #o700)
                   (#:parent-dir-perms . ((#:mode . #o700)))))))))

   (or gtk-services '())))

(define (chromium? flavors)
  (or (member #:ungoogled-chromium flavors)
      (member #:chromium flavors)))

(define (chrome? flavors)
  (member #:google-chrome flavors))

(define chromium-flavors '(#:ungoogled-chromium
                           #:google-chrome))
#+end_src
******* Setup instructions
It might be possible to configure some of these in a file or with command-line flags. Ungoogled Chromium -specific features might not be configurable the same way as Chromium ones (just through flags or not at all).
******** Chromium
- Settings > Appearance > Use GTK+ theme
- Settings > On startup, check "Continue where you left off"
- Right-click on the Bookmarks bar and uncheck "Show bookarks bar"
********* Ungoogled Chromium
- Settings > Manage search engines, make google the default
  It might not appear under "Other Search Engines" until you search something on google.com
- chrome://settings/cookies > uncheck "Clear cookies and site data when you close all windows"
******** uBlock extension
chrome://extensions > uBlock Origin > Details > Allow in Incognito
****** Firefox
If I want to statically configure Firefox (or one of its relatives) check out =gnu/home-services/web-browsers.scm= for ideas.
#+begin_src scheme
(define* (he-firefox #:key
                     stateless?
                     wayland?
                     gtk-services)
  (append
   (list
    (simple-service
     'firefox-add-package
     home-profile-service-type
     (list (if wayland?
               firefox/wayland
               firefox)))

    (when stateless?
      (home-stateless-service
       'firefox
       #:state '(((#:path . ("mozilla/firefox/" #:xdg-base "XDG_CACHE_HOME"))
                  (#:store . #:machine)
                  (#:mode . #o700)
                  (#:parent-dir-perms . ((#:mode . #o700))))
                 ((#:path . ".mozilla/firefox")
                  (#:store . #:machine)
                  (#:mode . #o700)
                  (#:parent-dir-perms . ((#:mode . #o700))))
                 ((#:path . ".mozilla/extensions")
                  (#:store . #:machine)
                  (#:mode . #o700)
                  (#:parent-dir-perms . ((#:mode . #o700))))))))

   (or gtk-services '())))
#+end_src
****** Nyxt
- TODO Add ~gtk-services~ param if Nyxt uses gtk settings (font, light/dark theme).
#+begin_src scheme
(define* (he-nyxt #:key
                  stateless?
                  doom?)
  (list
   (simple-service
    'nyxt-add-packages
    home-profile-service-type
    (list nyxt
          ;; gst-libav
          ;; gst-plugins-bad
          ;; gst-plugins-base
          ;; gst-plugins-good
          ;; gst-plugins-ugly
          ))

   ;; (when stateless?
   ;;   (home-stateless-service
   ;;    'nyxt
   ;;    #:state '(((#:path . ("nyxt/" #:xdg-base "XDG_CACHE_HOME"))
   ;;               (#:store . #:machine))
   ;;              ((#:path . ("webkitgtk/" #:xdg-base "XDG_DATA_HOME"))
   ;;               (#:store . #:machine)))))

   (when doom?
     (doom-service
      'nyxt
      #:modules '((#:lang
                   common-lisp))))))
#+end_src
***** Video
****** VLC
#+begin_src scheme
(define* (he-vlc #:key
                 stateless?
                 qt-services)
  (append
   (list
    (simple-service
     'vlc-add-package
     home-profile-service-type
     (list vlc))

    (when stateless?
      (home-stateless-service
       'vlc
       #:state '(((#:path . ("vlc/" #:xdg-base "XDG_CONFIG_HOME"))
                  (#:store . #:machine))
                 ((#:path . ("vlc/" #:xdg-base "XDG_DATA_HOME"))
                  (#:store . #:machine))))))

   (or qt-services '())))
#+end_src
***** Graphical toolkits
****** GTK
It's not totally clear what parts of this are Wayland-specific or if it's necessary to put e.g. ~gtk-theme-name~ in =settings.ini= for non-Wayland (see [[https://github.com/swaywm/sway/wiki/GTK-3-settings-on-Wayland][GTK 3 settings on Wayland  swaywm/sway Wiki  GitHub]].
#+begin_src scheme
(define* (gtk-services #:key
                       stateless?
                       theme
                       font
                       font-monospace)
  (list
   (simple-service
    'gtk-add-packages
    home-profile-service-type
    (list arc-theme
          ;; I copied the following from Andrew Tropin's config. I'm not sure why I'd need or want all of them (perhaps as fallbacks and in the case of `gnome-themes-extra' as a fallback GTK 2 theme?). I might get rid of some of them later but for now I'll try having more than less.
          hicolor-icon-theme
          adwaita-icon-theme
          ;; papirus-icon-theme ; TODO Remove for now, it massively increases guix build time. Why?
          gnome-themes-extra))

   (simple-service
    'gtk-settings-and-dconf
    home-multi-xdg-configuration-files-service-type
    `(("gtk-3.0/settings.ini"
       ,(ini-file
         "gtk-3.0-settings.ini"
         `((Settings ((gtk-application-prefer-dark-theme . ,(equal? theme #:theme/dark)))))))
      ("dconf/user"
       ,(dconf-db
         "dconf-user"
         `((org/gnome/desktop/interface
            ((gtk-theme . ,(quoted-symbol
                            (case theme
                              ((#:theme/light) "Arc")
                              ((#:theme/dark) "Arc-Dark"))))
             (font-name . ,(quoted-symbol
                            (font-specification font)))
             (monospace-font-name . ,(quoted-symbol
                                      (font-specification font-monospace))))))))))

   (when stateless?
     (home-stateless-service
      'gtk
      #:state '(((#:path . ("recently-used.xbel" #:xdg-base "XDG_DATA_HOME"))
                 (#:store . #:machine)))))))

(define home-multi-xdg-configuration-files-service-type
  (service-type
   (inherit home-xdg-configuration-files-service-type)
   (compose
    (lambda (exts)
      (as-> exts $
            (delete-duplicates $ (lambda (a b)
                                   (equal? (car a) (car b))))
            (apply append $))))))

(define (dconf-db name settings)
  (computed-file
   name
   (with-imported-modules '((guix build utils))
     #~(begin
         (use-modules ((guix build utils) #:select (invoke)))
         (invoke
          #$(file-append dconf "/bin/dconf")
          "compile"
          #$output
          #$(file-union ; Target of `compile` must be a directory.
             "dconf-keyfiledir"
             `(("dconf-keyfile"
                ,(ini-file
                  "dconf-keyfile"
                  settings)))))))))

(define (quoted-symbol s)
  (string->symbol (string-append "'" s "'")))
#+end_src
****** Qt
#+begin_src scheme
(define* (qt-services #:key stateless?)
  (list
   (when stateless?
     (home-stateless-service
      'qt
      #:state '(((#:path . ("QtProject.conf" #:xdg-base "XDG_CONFIG_HOME"))
                 (#:store . #:machine)))))))
#+end_src
*** Projects
#+begin_src scheme
(define* (he-projects #:key
                      stateless?
                      projects)
  (let ((work-dir "work"))
    (append
     (if projects
         (append-map
          (match-lambda
            ((dir . opts)
             (let* ((dir* (string-append "/.persist/home/pharcosyle" "/" "work_for_now" "/" dir))
                    ;; (dir* (string-append (getenv "HOME") "/" work-dir "/" dir))
                    (proj-file (string-append dir* "/project.scm")))
               (if (file-exists? proj-file)
                   ;; TODO figure out the "add declarative" warning. Maybe rewrite to use `add-to-load-path'.
                   (apply (load proj-file) (->> opts
                                                (acons #:dir dir*)
                                                alist->list))
                   '()))))
          projects)
         '())

     (list
      (when stateless?
        (home-stateless-service
         'projects
         #:state `(((#:path . ,(string-append work-dir "/"))
                    (#:store . #:persist)))))))))
#+end_src
**** Project helpers
#+begin_src scheme
(define (services-only-packages svcs)
  (services-packages filter svcs))

(define (services-sans-packages svcs)
  (services-packages remove svcs))

(define (services-packages f svcs)
  (f (lambda (s)
       (equal? (service-kind s) home-profile-service-type))
     svcs))
#+end_src
** Templates
#+begin_src scheme
(define* (he-base #:key
                  stateless?
                  stateless-persist-dir
                  stateless-machine-dir
                  email
                  (interactive-shells '(#:shell/zsh))
                  doom?
                  doom-calendar?
                  doom-org?
                  doom-evil?
                  doom-tree-sitter?
                  console?
                  guix-channels
                  nix?
                  kmonad?
                  desktop?
                  pipewire?
                  login-manager
                  sessions
                  projects)
  (let ((login-shell #:shell/bash)
        (doom-icons? #:t))
    (append
     (if stateless?
         (he-stateless #:persist-dir stateless-persist-dir
                       #:machine-dir stateless-machine-dir)
         '())
     (he-shells #:stateless? stateless?
                #:doom? doom?
                #:doom-tree-sitter? doom-tree-sitter?
                #:login-shell login-shell
                #:interactive-shells interactive-shells)
     (he-emacs)
     (if doom?
         (he-doom #:stateless? stateless?
                  #:services (doom-main #:stateless? stateless?
                                        #:evil? doom-evil?
                                        #:icons? doom-icons?
                                        #:email email))
         '())
     (he-guix #:stateless? stateless?
              #:doom? doom?
              #:channels guix-channels)
     (if nix?
         (he-nix #:stateless? stateless?
                 #:doom? doom?
                 #:doom-tree-sitter? doom-tree-sitter?
                 #:login-shell login-shell)
         '())
     (he-direnv #:doom? doom?
                #:shells interactive-shells)
     (he-protonvpn #:stateless? stateless?)
     (he-ssh)
     (he-git #:stateless? stateless?
             #:doom? doom?
             #:email email)
     (if doom?
         (append
          (if doom-calendar?
              (he-doom-calendar #:stateless? stateless?
                                #:org? doom-org?)
              '())
          (if doom-org?
              (he-doom-org #:stateless? stateless?
                           #:evil? doom-evil?)
              '())
          (he-doom-dired #:stateless? stateless?
                         #:icons? doom-icons?)
          (he-doom-app-launcher)
          (he-doom-trash))
         '())
     (he-miscellaneous)
     (if console?
         (if kmonad?
             (he-kmonad #:doom? doom?) '())
         '())
     (if desktop?
         (let* ((theme #:theme/dark)
                (light-colors light-colors)
                (dark-colors dark-colors)
                (colors dark-colors)
                (font-mono font-mono)
                (font-sans font-sans)
                (font-serif font-serif)
                (font-unicode font-unicode)
                (font-variable-pitch font-sans)
                (dbus? (not login-manager))
                (wayland? #t)
                (sway? (member #:session/sway (or sessions '()))))
           (append
            (if pipewire?
                (he-pipewire #:stateless? stateless?
                             #:dbus? dbus?
                             #:sway? sway?)
                '())
            (he-flatpak #:stateless? stateless?
                        #:wayland? wayland?)
            (he-fonts #:stateless? stateless?
                      #:fonts (list font-mono
                                    font-sans
                                    font-serif
                                    font-unicode)
                      #:extra-font-packages useful-font-packages)
            (if doom?
                (he-doom-themes+fonts #:theme theme
                                      #:light-colors light-colors
                                      #:dark-colors dark-colors
                                      #:font font-mono
                                      #:font-variable-pitch font-variable-pitch
                                      #:font-unicode font-unicode
                                      #:font-serif font-serif)
                '())
            (he-xdg #:stateless? stateless?)
            (he-mesa #:stateless? stateless?)
            (if dbus?
                (he-dbus) '())
            (if login-manager
                (case login-manager
                  ((#:lm/gdm) (he-gdm #:stateless? stateless?)))
                (he-desktop-tty #:start-cmd (sway-start #:pipewire? pipewire?)))
            (if (member #:session/gnome (or sessions '()))
                (he-gnome #:stateless? stateless?) '())
            (if sway?
                (let ((date-format date-format)
                      (time-format time-format))
                  (append
                   (he-wm-common #:sway? sway?)
                   (he-sway #:doom? doom?
                            #:pipewire? pipewire?
                            #:kb-layout ((@ (gnu system keyboard) keyboard-layout) "us" #:model "macbook78")
                            #:screen-locker (swaylock-screen-locker-immediate)
                            #:idle-manager (swayidle-idle-manager)
                            #:application-launcher (rofi-application-launcher #:wayland? wayland?)
                            #:default-terminal (alacritty-terminal))
                   (he-swaylock #:colors colors
                                #:font font-variable-pitch
                                #:date-format date-format
                                #:time-format time-format)
                   (he-swayidle #:sway? sway?
                                #:screen-locker (swaylock-screen-locker))
                   (he-mako #:sway? sway?
                            #:menu (rofi-menu #:wayland? wayland?)
                            #:colors colors
                            #:font font-variable-pitch)
                   (he-waybar #:colors colors
                              #:font font-variable-pitch
                              #:sway? sway?
                              #:modules (waybar-modules #:sway? sway?
                                                        #:date-format date-format
                                                        #:time-format time-format))
                   ;; (he-kanshi)
                   ))
                '())
            (he-rofi #:stateless? stateless?
                     #:wayland? wayland?
                     #:colors colors
                     #:font font-variable-pitch)
            (let ((gtk (gtk-services #:stateless? stateless?
                                     #:theme theme
                                     #:font font-variable-pitch
                                     #:font-monospace font-mono))
                  ;; (qt (qt-services #:stateless? stateless?))
                  )
              (append
               (he-pavucontrol #:stateless? stateless?
                               #:gtk-services gtk)
               ;; (he-gimp #:stateless? stateless?
               ;;          #:gtk-services gtk)
               (he-alacritty #:colors colors
                             #:font font-mono)
               (if doom?
                   (he-doom-vterm #:setup-zsh? (member #:shell/zsh interactive-shells)) '())
               (he-chromium #:stateless? stateless?
                            #:wayland? wayland?
                            #:gtk-services gtk
                            #:flavors chromium-flavors)
               (he-firefox #:stateless? stateless?
                           #:wayland? wayland?
                           #:gtk-services gtk)
               (he-nyxt #:stateless? stateless?
                        #:doom? doom?)
               ;; (he-vlc #:stateless? stateless?
               ;;         #:qt-services qt)
               ))))
         '())
     (he-projects #:stateless? stateless?
                  #:projects projects))))
#+end_src
* Common
:PROPERTIES:
:meta-dir+: /phrenetic
:END:
** Packages
:PROPERTIES:
:meta-dir+: /packages
:END:
*** KMonad :package:version:upstream:
#+begin_src scheme :tangle (meta-in-dir "haskell-apps.scm")
(define-module (phrenetic packages haskell-apps)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages haskell-apps) #:select (kmonad) #:prefix haskell-apps:)
  #:use-module ((gnu packages haskell-check) #:select (ghc-hspec hspec-discover))
  #:use-module (phrenetic utils))

(define-public kmonad
  (let ((commit "cbdace2bb7b27e47c2397e662265a28a1030b7c7"))
    (with-git-commit
     (package
       (inherit haskell-apps:kmonad)
       (arguments
        (substitute-keyword-arguments (package-arguments haskell-apps:kmonad)
          ((#:phases phases '%standard-phases)
           #~(modify-phases #$phases
               (add-after 'unpack 'patch-git-revision
                 (lambda _
                   (substitute* "src/KMonad/Args/Cmd.hs"
                     (("\\$\\(gitHash\\)") (string-append "\"" #$commit "\"")))))))))
       (inputs
        (modify-inputs (package-inputs haskell-apps:kmonad)
                       (prepend ghc-hspec
                                hspec-discover))))
     #:commit commit
     #:hash "1kgnf0yv7h8scfacwdj3l1lrmjibjri5ybbnyw5m8wn6sjxbpaab")))
#+end_src
** Stateless
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "stateless.scm")
:END:
#+begin_src scheme
(define-module (phrenetic stateless)
  #:use-module (guix build-system trivial)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module (gnu services)
  #:use-module (phrenetic utils)
  #:export (service-fn
            extend-proc
            activate-gexp
            diff-tool-package))

(define state-dir-lookup
  #~(lambda (persist-dir machine-dir)
      (lambda (k)
        (case k
          ((#:persist) persist-dir)
          ((#:machine) machine-dir)))))

(define symlink-to-state?
  (with-imported-modules '((guix build utils))
    #~(lambda (state-dirs)
        (lambda (file)
          (use-modules ((guix build utils) #:select (symbolic-link?))
                       ((srfi srfi-1) #:select (any)))

          (and (symbolic-link? file)
               (any (lambda (state-dir)
                      (string-prefix? state-dir (readlink file)))
                    state-dirs))))))
#+end_src
*** Services
**** Service extension
#+begin_src scheme
(define (service-fn service-type)
  (lambda* (name #:key state ignore)
    (simple-service
     (symbol-append name '-stateless)
     service-type
     `((#:state . ,state)
       (#:ignore . ,ignore)))))
#+end_src
**** Extend procedure
#+begin_src scheme
(define (extend-proc config additional)
  (let ((additional* (apply merge-with append additional)))
    (->> (apply list->alist config)
         (acons #:state (assoc-ref additional* #:state))
         (acons #:ignore (assoc-ref additional* #:ignore)))))
#+end_src
*** Activate
#+begin_src scheme
(define (activate-gexp state
                       backup-base-dir
                       persist-dir
                       machine-dir)
  (with-imported-modules '((guix build utils))
    #~(begin
        (use-modules ((guix build utils) #:select (copy-recursively delete-file-recursively find-files mkdir-p)))

        (define (mkdirp-perms dir perms)
          (mkdir-p dir)
          (chown dir
                 (let ((user (assoc-ref perms #:user)))
                   (if user
                       (passwd:uid (getpwnam user)) -1))
                 (let ((group (assoc-ref perms #:group)))
                   (if group
                       (group:gid (getgrnam group)) -1)))
          (let ((mode (assoc-ref perms #:mode)))
            (when mode
              (chmod dir mode))))

        (define (no-follow-file-exists? file)
          (false-if-exception (lstat file)))

        (define timestamp (current-time))

        (define (cleanup-and-migrate target state-file state-dir)
          (let ((migrate-file
                 (lambda (source dest)
                   (copy-recursively source dest)
                   (delete-file-recursively source)))
                (backup-file
                 (lambda (file)
                   (let* ((backup-dir (string-append
                                       state-dir
                                       #$backup-base-dir
                                       "/stateless-backup-" (number->string timestamp)))
                          (backup-file (string-append
                                        backup-dir "/"
                                        (let* ((string-drop-prefix (lambda (s prefix)
                                                                     (string-drop s (string-length prefix))))
                                               (without-state-dir (lambda (file)
                                                                    (string-drop-prefix file state-dir)))
                                               (without-base-dir (lambda (file)
                                                                   (string-drop-prefix file #$backup-base-dir))))
                                          ((compose without-base-dir
                                                    without-state-dir)
                                           file)))))
                     (mkdir-p (dirname backup-file))
                     (rename-file file backup-file)))))
            (when (no-follow-file-exists? target)
              (if ((#$symlink-to-state? (list #$persist-dir
                                              #$machine-dir))
                   target)
                  (delete-file target)
                  (begin
                    (when (no-follow-file-exists? state-file)
                      (if (nil? (find-files state-file))
                          (delete-file-recursively state-file)
                          (backup-file state-file)))
                    (migrate-file target state-file))))))

        (define (process-state-entry i)
          (let* ((path (assoc-ref i #:path))
                 (directory-target? (string-suffix? "/" path))
                 (target (if directory-target?
                             (string-drop-right path 1) path))
                 (state-dir ((#$state-dir-lookup #$persist-dir #$machine-dir)
                             (assoc-ref i #:store))))
            (let ((parent-dir (dirname path))
                  (parent-dir-perms (assoc-ref i #:parent-dir-perms)))
              (mkdirp-perms (string-append state-dir parent-dir) parent-dir-perms)
              (mkdirp-perms parent-dir parent-dir-perms))
            (let ((state-file (string-append state-dir target)))
              (cleanup-and-migrate target state-file state-dir)
              (when directory-target?
                (mkdirp-perms state-file i))
              (when (no-follow-file-exists? state-file)
                (symlink state-file target)))))

        (for-each process-state-entry #$state))))
#+end_src
*** Diff tool
**** Program
#+begin_src scheme
(define* (diff-tool-program state
                            ignore
                            base-dir
                            persist-dir
                            machine-dir
                            #:key
                            additional-known)
  (program-file
   "diff-tool"
   (with-imported-modules '((guix build utils))
     #~(begin
         (use-modules ((guix build utils) #:select (store-file-name? symbolic-link?))
                      ((ice-9 ftw) #:select (file-system-fold))
                      ((srfi srfi-1) #:select (any)))

         (define* (find-diff dir known)
           (let* ((check-path
                   (lambda (path result)
                     (let ((pred (assoc-ref known path)))
                       (if (and pred (pred path))
                           result
                           (cons path result)))))
                  (results
                   (file-system-fold
                    (let ((known-paths (map car known)))
                      (lambda (dir _ _*)
                        (and (not (member (string-append dir "/") known-paths))
                             (any (lambda (known-path)
                                    (string-prefix? dir known-path))
                                  known-paths))))
                    (lambda (file _ result)
                      (check-path file result))
                    (lambda (_ _* result)
                      result)
                    (lambda (_ _* result)
                      result)
                    (lambda (dir _ result)
                      (check-path (string-append dir "/") result))
                    (lambda (path _ errno result)
                      (format (current-error-port) "~a: ~a~%" path (strerror errno))
                      result)
                    '()
                    dir)))
             (sort results string<?)))

         (define (make-known files pred)
           (map (lambda (file)
                  (cons file pred))
                files))

         (define (make-known-files+dirs paths)
           (map (let ((directory?
                       (lambda (path)
                         (equal? (stat:type (lstat path)) 'directory))))
                  (lambda (path)
                    (cons path
                          (if (string-suffix? "/" path)
                              directory?
                              (negate directory?)))))
                paths))

         (define (state->paths state)
           (map (lambda (entry)
                  (assoc-ref entry #:path))
                state))

         (define (symlink-to-store? file)
           (and (symbolic-link? file)
                (store-file-name? (readlink file))))

         (define (diff-live)
           (find-diff
            #$base-dir
            (append
             (make-known (map (lambda (path)
                                (if (string-suffix? "/" path)
                                    (string-drop-right path 1) path))
                              (state->paths #$state))
                         (#$symlink-to-state? (list #$persist-dir
                                                    #$machine-dir)))
             (make-known-files+dirs #$ignore)
             (or #$additional-known '()))))

         (define (diff-state)
           (let ((finder
                  (lambda (store state)
                    (let ((state-dir ((#$state-dir-lookup #$persist-dir #$machine-dir)
                                      store)))
                      (find-diff
                       (string-append state-dir #$base-dir)
                       (make-known-files+dirs
                        (let ((state-in-store
                               (filter (lambda (entry)
                                         (equal? (assoc-ref entry #:store) store))
                                       #$state)))
                          (map (lambda (path)
                                 (string-append state-dir path))
                               (state->paths state-in-store)))))))))
             (append
              (finder #:persist #$state)
              (finder #:machine #$state))))

         (define (run-mode)
           (string->symbol
            (or
             (false-if-exception (cadr (command-line)))
             "active")))

         (for-each
          (lambda (path)
            (display (string-append path "\n")))
          (case (run-mode)
            ((active) (diff-live))
            ((state) (diff-state))))))))
#+end_src
**** Package
#+begin_src scheme
(define* (diff-tool-package bin-name #:rest opts)
  (package
    (inherit blank-package)
    (name "stateless-diff-tool")
    (source (apply diff-tool-program opts))
    (build-system trivial-build-system)
    (arguments
     `(#:builder
       ,#~(begin
            (let* ((bin (string-append #$output "/bin")))
              (mkdir #$output)
              (mkdir bin)
              (symlink #$source (string-append bin "/" #$bin-name))))))))
#+end_src
* Utils
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "phrenetic/utils.scm")
:END:
#+begin_src scheme
(define-module (phrenetic utils)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module (gnu services)
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:use-module ((srfi srfi-1) #:select (append-map fold take drop))
  #:export (when-let
            if-let
            when-not
            if-not
            ->
            ->>
            as->
            list->alist
            alist->list
            merge-with
            update-keys
            update-vals
            blank-package
            with-git-version
            with-git-commit
            with-git-url))
#+end_src
** Branching
#+begin_src scheme
(define-syntax when-let
  (syntax-rules ()
    ((_ ((var expr)) body ...)
     (let ((var expr))
       (when var body ...)))))

(define-syntax if-let
  (syntax-rules ()
    ((_ ((var expr)) then else)
     (let ((var expr))
       (if var then else)))))

(define-syntax when-not
  (syntax-rules ()
    ((_ test body ...)
     (when (not test) body ...))))

(define-syntax if-not
  (syntax-rules ()
    ((_ test then else)
     (if (not test) then else))))
#+end_src
** Threading
#+begin_src scheme
(define-syntax ->
  (syntax-rules ()
    ((_ x) x)
    ((_ x (f args ...) expr ...) (-> (f x args ...) expr ...))
    ((_ x f expr ...) (-> (f x) expr ...))))

(define-syntax ->>
  (syntax-rules ()
    ((_ x) x)
    ((_ x (f args ...) expr ...) (->> (f args ... x) expr ...))
    ((_ x f expr ...) (->> (f x) expr ...))))

(define-syntax as->
  (lambda (x)
    (syntax-case x ()
      ((_ exp name) #'exp)
      ((_ exp name form form* ...)
       (with-syntax ((x (datum->syntax #'form (syntax->datum #'name))))
         #'(let ((x exp))
             (as-> form name form* ...)))))))
#+end_src
** Alists
#+begin_src scheme
(define* (list->alist #:rest kvs)
  (let loop ((res '())
             (more kvs))
    (if (null? more)
        res
        (loop (cons (as-> more $
                          (take $ 2)
                          (apply cons $))
                    res)
              (drop more 2)))))

(define (alist->list alist)
  (append-map
   (match-lambda
     ((k . v)
      (list k v)))
   alist))

(define* (merge-with f #:rest alists)
  (fold
   (lambda (a res)
     (map
      (lambda (k)
        (cons k
              (let ((res-v (assoc-ref res k))
                    (v (assoc-ref a k)))
                (if (and res-v v)
                    (f res-v v)
                    (or res-v v)))))
      (let ((keys (lambda (alist)
                    (map car alist))))
        (append (keys res)
                (filter (lambda (k)
                          (not (member k (keys res))))
                        (keys a))))))
   '()
   alists))

(define (update-keys alist f)
  (map (match-lambda
         ((k . v)
          (cons (f k) v)))
       alist))

(define (update-vals alist f)
  (map (match-lambda
         ((k . v)
          (cons k (f v))))
       alist))
#+end_src
** Guix
#+begin_src scheme
(define blank-package
  (package
    (name #f)
    (version "0")
    (source #f)
    (build-system #f)
    (synopsis #f)
    (description #f)
    (home-page #f)
    (license #f)))

(define* (with-git pkg
                   #:key
                   upstream-version
                   revision
                   commit
                   hash)
  (package
    (inherit pkg)
    (version (if revision
                 (git-version upstream-version revision commit)
                 upstream-version))
    (source
     (origin
       (inherit (package-source pkg))
       (uri (git-reference
             (inherit (-> pkg package-source origin-uri))
             (commit commit)))
       (sha256
        (base32
         hash))
       (file-name (git-file-name (package-name pkg) version))))))

(define* (with-git-version pkg #:key version commit hash)
  (with-git pkg
            #:upstream-version version
            #:commit commit
            #:hash hash))

(define* (with-git-commit pkg
                          #:key
                          (upstream-version (package-version pkg))
                          (revision "0")
                          commit
                          hash)
  (with-git pkg
            #:upstream-version upstream-version
            #:revision revision
            #:commit commit
            #:hash hash))

(define (with-git-url pkg url)
  (package
    (inherit pkg)
    (source
     (origin
       (inherit (package-source pkg))
       (uri (git-reference
             (inherit (-> pkg package-source origin-uri))
             (url url)))))))
#+end_src
* Configurations
:PROPERTIES:
:meta-dir+: /phrenetic/configs
:END:
** Frostfire
#+begin_src scheme :tangle (meta-in-dir "frostfire.scm") :noweb yes
(define-module (phrenetic configs frostfire)
  #:use-module ((guix gexp) #:select (local-file))
  #:use-module ((phrenetic home) #:prefix he:)
  #:use-module (phrenetic install)
  #:use-module ((phrenetic system) #:prefix os:)
  #:use-module (phrenetic utils)
  #:use-module ((srfi srfi-1) #:select (delete-duplicates))
  #:export (frostfire
            installer
            primary
            aux
            guest))

(define* (os-base #:key
                  primary-name
                  aux-name
                  guest-name
                  bluetooth?
                  auto-login?
                  auto-login-user
                  sessions)
  (apply
   os:os-base
   os:blank-os
   #:source? #t
   #:source-path "/.persist/home/pharcosyle/work_for_now/phrenetic"
   #:users-info `(((#:name . ,primary-name)
                   (#:comment . "Krzysztof Baranowski")
                   (#:admin? . #t)
                   (#:password . "mellon")) ; TODO remove this
                  ((#:name . ,aux-name)
                   (#:comment . "Phil Coulson")
                   (#:admin? . #t)
                   (#:password . "mellon")) ; TODO remove this
                  ((#:name . ,guest-name)
                   (#:comment . "Speak Friend and Enter")
                   (#:password . "mellon")
                   (#:admin? . #t))) ; TODO remove this
   #:kmonad? #t
   #:kmonad-users (list primary-name)
   #:bluetooth? bluetooth?
   #:bluetooth-users (list primary-name
                           aux-name
                           guest-name)
   #:auto-login? auto-login?
   #:auto-login-user auto-login-user
   #:sessions sessions
   os+he-shared-opts))


(define stateless? #t)


(define* (primary-he)
  (he:create-he
   (apply
    he:he-base
    #:email "pharcosyle@gmail.com"
    #:kmonad? #t
    #:sessions primary-he-sessions
    #:projects `(("phrenetic" . ((#:doom? . ,doom?)))
                 ("Krush/hyperdrive" . ((#:stateless? . ,stateless?)
                                        (#:doom? . ,doom?)
                                        (#:doom-org? . ,doom-org?)
                                        (#:doom-tree-sitter? doom-tree-sitter?))))
    he-shared-opts)))

(define primary-he-sessions '(#:session/sway))

(define (aux-he)
  (he:create-he
   (apply
    he:he-base
    #:email "pharcosyle@gmail.com"
    #:sessions aux-he-sessions
    he-shared-opts)))

(define aux-he-sessions primary-he-sessions)

(define (guest-he)
  (he:create-he
   (apply
    he:he-base
    #:sessions guest-he-sessions
    he-shared-opts)))

(define guest-he-sessions '(;; #:session/gnome
                            #:session/sway))


(define nix? #t)
(define stateless-persist-dir os:stateless-persist-dir)
(define stateless-machine-dir os:stateless-machine-dir)

(define os+he-shared-opts
  `(#:stateless? ,stateless?
    #:nix? ,nix?
    #:console? #t
    #:desktop? #t
    #:pipewire? #t
    ;; #:login-manager #:lm/gdm
    ))

(define he-shared-opts
  (append
   os+he-shared-opts
   `(#:stateless-persist-dir ,stateless-persist-dir
     #:stateless-machine-dir ,stateless-machine-dir
     #:doom? doom?
     #:doom-calendar? doom-calendar?
     #:doom-org? doom-org?
     #:doom-evil? doom-evil?
     #:doom-tree-sitter? doom-tree-sitter?
     ;; #:guix-channels (local-file "frostfire-channels-lock") ; TODO Not working (or working sporadically) for some reason. Very, very strange.
     )))


(define doom? #t)
(define doom-calendar? doom?)
(define doom-org? doom?)
(define doom-evil? doom?)
(define doom-tree-sitter? doom?)


(define efi? #t)
(define boot-label os:boot-label)
(define boot-target os:efi-boot-target)
(define filesystem #:filesystem/btrfs)
(define root-label os:root-label)
(define mountables (os:stateless-mountables
                    #:persist-dir stateless-persist-dir
                    #:machine-dir stateless-machine-dir))
(define btrfs-mount-flags os:btrfs-mount-flags)
(define btrfs-mount-options os:btrfs-mount-options)
(define disk-encryption? #t)
(define luks-label os:luks-label)


(define frostfire
  (let ((primary-name "pharcosyle")
        (aux-name "pcoulson")
        (guest-name "gandalf")
        (bluetooth? #t))
    (-> (os-base #:primary-name primary-name
                 #:aux-name aux-name
                 #:guest-name guest-name
                 #:bluetooth? bluetooth?
                 #:auto-login? disk-encryption?
                 #:auto-login-user primary-name
                 #:sessions (->> (list primary-he-sessions
                                       aux-he-sessions
                                       guest-he-sessions)
                                 (apply append)
                                 delete-duplicates))
        (os:with-host-info #:host-name "frostfire"
                           #:timezone "America/Los_Angeles")
        (os:with-bootloader #:efi? efi?
                            #:boot-label boot-label
                            #:boot-target boot-target)
        (os:with-filesystems #:filesystem filesystem
                             #:root-label root-label
                             #:mountables mountables
                             #:btrfs-mount-flags btrfs-mount-flags
                             #:btrfs-mount-options btrfs-mount-options
                             #:disk-encryption? disk-encryption?
                             #:luks-label luks-label
                             #:stateless? stateless?
                             #:stateless-persist-dir stateless-persist-dir
                             #:stateless-machine-dir stateless-machine-dir
                             #:stateless-users `((,primary-name . ,(primary-he))
                                                 (,aux-name . ,(aux-he))
                                                 (,guest-name . ,(guest-he)))
                             #:nix? nix?)
        (os:with-macbook-hardware #:bluetooth? bluetooth?))))

(define installer
  (installer-package #:os-name "frostfire"
                     #:efi? efi?
                     #:boot-label boot-label
                     #:boot-target boot-target
                     #:root-label root-label
                     #:disk-encryption? disk-encryption?
                     #:luks-label luks-label
                     #:filesystem filesystem
                     #:mountables mountables
                     #:btrfs-mount-flags btrfs-mount-flags
                     #:btrfs-mount-options btrfs-mount-options))

(define primary (primary-he))
(define aux (aux-he))
(define guest (guest-he))

frostfire
#+end_src
*** Channels
#+begin_src scheme :tangle (meta-in-dir "frostfire-channels")
(cons* (channel
        (name 'rde)
        (url "https://git.sr.ht/~abcdw/rde")
        (introduction
         (make-channel-introduction
          "257cebd587b66e4d865b3537a9a88cccd7107c95"
          (openpgp-fingerprint
           "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
       (channel
        (name 'nonguix)
        (url "https://gitlab.com/nonguix/nonguix")
        (introduction
         (make-channel-introduction
          "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
          (openpgp-fingerprint
           "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
       (channel
        (name 'guix-chromium)
        (url "https://gitlab.com/mbakke/guix-chromium"))
       %default-channels)
#+end_src
**** COMMENT From project channel
#+begin_src scheme :tangle (meta-in-dir "frostfire-channels")
(cons* (channel
        (name 'phrenetic)
        (url "https://github.com/pharcosyle/phrenetic")
        (branch "tangled"))
       %default-channels)
#+end_src
**** COMMENT From project channel (local)
#+begin_src scheme :tangle (meta-in-dir "frostfire-channels")
(cons* (channel
        (name 'phrenetic)
        (url "file:///home/pharcosyle/work/phrenetic")
        (branch "tangled"))
       %default-channels)
#+end_src
*** Channels lock :version:
#+begin_src scheme :tangle (meta-in-dir "frostfire-channels-lock")
(list (channel
       (name 'guix)
       (url "https://git.savannah.gnu.org/git/guix.git")
       (branch "master")
       (commit
        "1ee2d117d8fa9e2e0d4ec46cc5555497bb5e6337")
       (introduction
        (make-channel-introduction
         "9edb3f66fd807b096b48283debdcddccfea34bad"
         (openpgp-fingerprint
          "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA"))))
      (channel
       (name 'rde)
       (url "https://git.sr.ht/~abcdw/rde")
       (branch "master")
       (commit
        "77bf57ba4f977af437fbaabff5e14bc09fb2eccd")
       (introduction
        (make-channel-introduction
         "257cebd587b66e4d865b3537a9a88cccd7107c95"
         (openpgp-fingerprint
          "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
      (channel
       (name 'nonguix)
       (url "https://gitlab.com/nonguix/nonguix")
       (branch "master")
       (commit
        "5a76529aff40107fbc03f293a0a332c839059815")
       (introduction
        (make-channel-introduction
         "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
         (openpgp-fingerprint
          "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
      (channel
       (name 'guix-chromium)
       (url "https://gitlab.com/mbakke/guix-chromium")
       (branch "master")
       (commit
        "3bc21255be98efb7a0e4b8de060c27bf60ae44f7")))
#+end_src
**** COMMENT From project channel
#+begin_src scheme :tangle (meta-in-dir "frostfire-channels-lock")
(list (channel
       (name 'guix)
       (url "https://git.savannah.gnu.org/git/guix.git")
       (branch "master")
       (commit
        "1ee2d117d8fa9e2e0d4ec46cc5555497bb5e6337")
       (introduction
        (make-channel-introduction
         "9edb3f66fd807b096b48283debdcddccfea34bad"
         (openpgp-fingerprint
          "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA"))))
      (channel
       (name 'phrenetic)
       (url "https://github.com/pharcosyle/phrenetic")
       (branch "tangled")
       (commit
        "bbc78abdfee8daf0e43b4348b7452ffe9340fb5c")))
#+end_src
**** COMMENT From project channel (local)
#+begin_src scheme :tangle (meta-in-dir "frostfire-channels-lock")
(list (channel
       (name 'guix)
       (url "https://git.savannah.gnu.org/git/guix.git")
       (branch "master")
       (commit
        "1ee2d117d8fa9e2e0d4ec46cc5555497bb5e6337")
       (introduction
        (make-channel-introduction
         "9edb3f66fd807b096b48283debdcddccfea34bad"
         (openpgp-fingerprint
          "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA"))))
      (channel
       (name 'phrenetic)
       (url "file:///home/pharcosyle/work/phrenetic")
       (branch "tangled")
       (commit
        "bbc78abdfee8daf0e43b4348b7452ffe9340fb5c")))
#+end_src
* Guix channel
#+begin_src scheme :tangle (meta-in-dir ".guix-channel")
(channel
 (version 0)
 (dependencies
  (channel
   (name rde)
   (url "https://git.sr.ht/~abcdw/rde")
   (introduction
    (make-channel-introduction
     "257cebd587b66e4d865b3537a9a88cccd7107c95"
     (openpgp-fingerprint
      "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
  (channel
   (name nonguix)
   (url "https://gitlab.com/nonguix/nonguix")
   (introduction
    (make-channel-introduction
     "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
     (openpgp-fingerprint
      "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
  (channel
   (name 'guix-chromium)
   (url "https://gitlab.com/mbakke/guix-chromium"))))
#+end_src
* Github
** Readme
#+begin_src org :tangle (meta-in-dir "README.org")
,* Phrenetic
A configuration framework and collection of useful packages/services for [[https://guix.gnu.org/][GNU Guix]].

It's decent.
,* [[file:phrenetic.org][Browse the full source]]
,* Usage
Install as a [[https://guix.gnu.org/manual/devel/en/guix.html#Channels][Guix channel]] with the following declaration:
,#+begin_src scheme
(channel
 (name 'phrenetic)
 (url "https://github.com/pharcosyle/phrenetic")
 (branch "tangled"))
,#+end_src
,* Noteworthy features
Some stuff I haven't seen elsewhere folks might be interested in:
- Stateless service :: Configure your Guix to run with an ephemeral, in-memory root directory. Kind of like [[https://grahamc.com/blog/erase-your-darlings][Erase your darlings: immutable infrastructure for mutable systems]] but using Guix/Btrfs instead of NixOS/ZFS.
- Doom package and module :: [[https://github.com/doomemacs/doomemacs][Doom Emacs]] packaged for Guix and with patches to better organize Emacs state, a service to set up symlinks, etc.
- Guix integration for [[https://github.com/radian-software/straight.el][Straight.el]] :: Your Straight or Doom-based Emacs configuration can use Guix Emacs packages under hood (but with the revisions you, or Doom, specify). Get the best of both worlds! Still WIP.
- Miscellaneous packages :: Guix packages for stuff not upstream yet: Datomic CLI tools, the AWS CLI v2, etc.
,* A word about literate programming
I use Emacs' =org-mode= to structure my code as a single file that I can export ("tangle") into numerous source files. This allows me to annotate and organize related code in potentially different languages with different output paths together in a way that easy for humans to read and reason about. This does necessitate maintaining a separate =tangled= branch (set as the Github default) so others can use it easily, though.
,* Contributing
Pull requests welcome! Targeting =master= is ideal but if you aren't familiar with literate programming / Emacs / =org=mode= then making your changes on the =tangled= branch is also fine (I'll reverse-tangle it for you).
,* Acknowledgements
This project incorporates code from Andrew Tropin's excellent [[https://github.com/abcdw/rde][RDE]], many thanks to him.
#+end_src
** License
:PROPERTIES:
:VISIBILITY: folded
:END:
#+begin_src fundamental :tangle (meta-in-dir "LICENSE")
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
#+end_src
* Dev
** Git ignore
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
/*

!/meta.el

!/phrenetic/
/phrenetic/*
!phrenetic/alucard_bg.png
#+end_src
