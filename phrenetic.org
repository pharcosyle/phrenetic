#+TITLE: Phrenetic
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args:elisp :lexical t

* Table of Contents :TOC:
- [[#meta][Meta]]
  - [[#path-hierarchy][Path hierarchy]]
  - [[#dev][Dev]]
- [[#installation][Installation]]
  - [[#create-bootable-usb][Create bootable USB]]
  - [[#install][Install]]
- [[#system][System]]
  - [[#components][Components]]
  - [[#base-os][Base OS]]
- [[#home][Home]]
  - [[#packages][Packages]]
  - [[#components-1][Components]]
  - [[#base-he][Base HE]]
- [[#union][Union]]
- [[#utils][Utils]]
  - [[#branching][Branching]]
  - [[#functions][Functions]]
  - [[#association-lists][Association lists]]
  - [[#guix][Guix]]
- [[#auxillary][Auxillary]]
  - [[#packages-1][Packages]]
- [[#configurations][Configurations]]
  - [[#frostfire][Frostfire]]
  - [[#scripts-wip][Scripts WIP]]
- [[#channel][Channel]]
- [[#dev-1][Dev]]
  - [[#git-config][Git config]]
  - [[#git-ignore][Git ignore]]
  - [[#github][Github]]
- [[#dev-local][Dev local]]
  - [[#git-config-1][Git config]]
  - [[#emacs-directory-local-variables][Emacs directory-local variables]]

* Meta
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "meta.el")
:END:
- REVIEW depending on how I do per-project literate config, I may want/need to pull out this code for use in other projects
  - ideally capture file-wide properties as well
    ~mkdirp~ and ~lexical~ at the time of this writing
#+begin_src elisp
;;; -*- lexical-binding: t; -*-

(require 'dash)
#+end_src
** Path hierarchy
#+begin_src elisp
(setq meta--base-dir ".")

(defun meta-get-dir ()
  (concat meta--base-dir
          (when-let ((dirs (org-entry-get (point) "meta-dir" 'inherit)))
            (-> dirs (split-string " /") (string-join "/")))))

(defun meta-in-dir (sub-path)
  (concat (meta-get-dir) "/" sub-path))
#+end_src
** Dev
*** Git ignore
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
/meta.el
#+end_src
* Installation
** Create bootable USB
Download (or create) a Guix installation ISO
- I'm using the [[https://github.com/SystemCrafters/guix-installer/releases/latest][System Crafters Guix Installer]] since it's kept up-to-date which should speed things up a bit.
- Run ~lsblk~ to find the usb device.
#+begin_src sh
iso_file=guix-system-install-1.3.0.x86_64-linux.iso
usb_device=/dev/sdc
dd if=$iso_file of=$usb_device status=progress bs=4M
sync
#+end_src
** Install
Boot from the installation medium, select your language and country, and select "Install using the shell based process" when prompted.
*** Keyboard layout
This messed up the keyboard when I tried it on mac, not doing ~loadkeys~ at all was fine.
#+begin_src sh
# keysfile=mac-us
# loadkeys $keysfile
#+end_src
*** Networking
#+begin_src sh
# List network interfaces and find one to use.
ifconfig -a

# Is this necessary if the interface is already activated?
interface=usb0
ifconfig $interface up

dhclient -v $interface

# Test that networking is up and working.
ping -c 3 gnu.org
#+end_src
*** Partitioning
#+begin_src sh
# Check out the current block devices and partitions if you want.
lsblk

device=/dev/sda

# Make two partitions, partition types should be "EFI system partition" and "Linux x86-64 root (/)". For EFI I'm gonna do 1GB to be on the safe side, second should be remainder of free space.
cfdisk $device
parted $device set 1 esp on

efi_system_partition="$device"1
efi_label=genesis

mkfs.fat -F32 -n $efi_label $efi_system_partition

root_partition="$device"2
root_label=firmament
crypt_name=ciphered
crypt_mapping=/dev/mapper/$crypt_name

cryptsetup luksFormat $root_partition
cryptsetup open --type luks $root_partition $crypt_name

mkfs.btrfs -L $root_label $crypt_mapping
#+end_src
*** Set up subvolumes
#+begin_src sh
# I don't know if the type argument is necessary but that's how Andrew Tropin had it.
mount -t btrfs LABEL=$root_label /mnt

btrfs subvolume create /mnt/root
btrfs subvolume create /mnt/boot
btrfs subvolume create /mnt/guix-store
btrfs subvolume create /mnt/guix-var
btrfs subvolume create /mnt/log
btrfs subvolume create /mnt/home
btrfs subvolume create /mnt/persist
btrfs subvolume create /mnt/nix

# Take an empty readonly snapshot of the root subvolume (might be useful later for rolling back or comparison)
btrfs subvolume snapshot -r /mnt/root /mnt/root-blank

umount /mnt
#+end_src
*** Mount
NB: ~$crypt_mapping~ can/"should" be ~LABEL=$root_label~
#+begin_src sh
mount -o subvol=root,compress=zstd,autodefrag $crypt_mapping /mnt

mkdir /mnt/boot
mount -o subvol=boot,compress=zstd,autodefrag $crypt_mapping /mnt/boot
mkdir -p /mnt/gnu/store
mount -o subvol=guix-store,compress=zstd,autodefrag,noatime $crypt_mapping /mnt/gnu/store
mkdir -p /mnt/var/guix
mount -o subvol=guix-var,compress=zstd,autodefrag $crypt_mapping /mnt/var/guix
mkdir -p /mnt/var/log
mount -o subvol=log,compress=zstd,autodefrag $crypt_mapping /mnt/var/log
mkdir /mnt/home
mount -o subvol=home,compress=zstd,autodefrag $crypt_mapping /mnt/home
mkdir /mnt/.persist
mount -o subvol=persist,compress=zstd,autodefrag $crypt_mapping /mnt/.persist

mkdir -p /mnt/boot/efi
mount LABEL=$efi_label /mnt/boot/efi
#+end_src
*** Proceeding with installation
#+begin_src sh
herd start cow-store /mnt
#+end_src
*** System configuration
#+begin_src sh
# Grab my dotfiles, from github if I put them up at some point or maybe from a USB or another computer with `woof`, into the current directory (the one I'm already in, not `/mnt`).
# git clone https://github.com/pharcosyle/phrenetic
# guix environment --ad-hoc woof -- woof -U
# Important: `woof` didn't work for me over the local network, I had to have my other computer offer it over the public internet with localtunnel.

mkdir -p ~/.config/guix
cp ~/projects/phrenetic/exuberant/exuberant/he/solitude/solitude-channels-lock ~/.config/guix
guix pull
hash guix

# Find the LUKS UUID to update it in the system config. Make sure to update in the dotfiles upstream later.
cryptsetup luksUUID $root_partition

cd ~/projects/phrenetic
guix system --load-path=. init exuberant/exuberant/os/frostfire.scm /mnt
#+end_src
*** Post-installation
#+begin_src sh
# Reboot the system, take out the installation medium, and login as root when faced with a login prompt.

# Set the password for the root account.
passwd
# Set the password for my user.
my_user=pharcosyle
passwd $my_user

# Log out and log in to my user account.

# Grab my dotfiles again.

# Ensure my channels file is in `~/.config/guix` and update my channels.
guix pull

# Run a system reconfigure, home reconfigure, install manifests, and deploy `home-state.git`. Copy over all my old data.
#+end_src
* System
:PROPERTIES:
:meta-dir+: /ebullient/system
:END:
** Components
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "components.scm")
:END:
#+begin_src scheme
(define-module (ebullient system components)
  #:use-module ((guix modules) #:select (source-module-closure))
  #:use-module (guix gexp)
  #:use-module ((guix store) #:select (%default-substitute-urls))
  #:use-module (gnu bootloader)
  #:use-module (gnu bootloader grub)
  ;; #:use-module ((gnu packages bash) #:select (bash))
  #:use-module ((gnu packages certs) #:select (nss-certs))
  #:use-module ((gnu packages fonts) #:select (font-terminus))
  #:use-module ((gnu packages gnupg) #:select (guile-gcrypt))
  #:use-module ((gnu packages linux) #:select (brightnessctl pipewire-0.3))
  ;; #:use-module ((gnu packages shells) #:select (zsh))
  #:use-module ((gnu packages wm) #:select (swaylock))
  #:use-module (gnu services)
  #:use-module (gnu services base)
  #:use-module (gnu services desktop)
  #:use-module (gnu services nix)
  #:use-module (gnu services sound)
  #:use-module (gnu services xorg)
  #:use-module (gnu system)
  #:use-module (gnu system accounts)
  #:use-module (gnu system file-systems)
  #:use-module (gnu system keyboard)
  #:use-module (gnu system mapped-devices)
  #:use-module ((nongnu packages linux) #:select (linux-lts linux-firmware broadcom-sta broadcom-bt-firmware))
  #:use-module ((nongnu system linux-initrd) #:select (microcode-initrd))
  #:use-module ((rde packages) #:select ((sway-latest . sway)))
  #:use-module (ebullient utils)
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:use-module ((ice-9 rdelim) #:select (read-string))
  #:use-module ((srfi srfi-1) #:select (any remove iota))
  #:export (barebones-os
            host-info
            grub-efi
            base-services
            nss
            linux-nonfree
            disk-encryption
            stateless
            stateless-persist-dir
            btrfs
            btrfs-subvols
            accounts
            nonguix-substitutes
            nix
            console-keyboard-layouts
            hidpi-console-font
            desktop-services
            gdm
            gnome-desktop
            wm
            sway-wm
            macbook-wireless
            macbook-kbl))
#+end_src
#+begin_src scheme
(define-syntax-rule (system-comp os field ...)
  (operating-system
    (inherit os)
    field ...))

(define-syntax define-system-comp
  (lambda (x)
    (syntax-case x ()
      ((_ (name arg ...) field ...)
       (with-syntax ((os (datum->syntax x 'os)))
         #'(define* (name os arg ...)
             (system-comp os field ...)))))))
#+end_src
*** Barebones OS
#+begin_src scheme
(define barebones-os
  (operating-system
    (host-name #f)
    (timezone #f)
    (bootloader #f)
    (services '())
    (file-systems %base-file-systems)))
#+end_src
*** Host info
#+begin_src scheme
(define-system-comp (host-info #:key
                               host-name
                               timezone
                               locale)
  (host-name host-name)
  (timezone timezone)
  (locale (or locale "en_US.utf8")))
#+end_src
*** Boot
**** Grub
...
**** Grub EFI
#+begin_src scheme
(define-system-comp (grub-efi #:key
                              (label "genesis")
                              (target "/boot/efi"))
  (bootloader (bootloader-configuration
               (bootloader grub-efi-bootloader)
               (targets (list target))
               (timeout 1)))
  (file-systems
   (cons* (file-system
            (device (file-system-label label))
            (mount-point target)
            (type "vfat"))
          (operating-system-file-systems os))))
#+end_src
*** Base services
#+begin_src scheme
(define-system-comp (base-services)
  (services
   (append %base-services
           (operating-system-user-services os))))
#+end_src
*** NSS
#+begin_src scheme
(define-system-comp (nss)
  (packages
   (cons* nss-certs
          (operating-system-packages os))))
#+end_src
*** Linux nonfree
#+begin_src scheme
(define-system-comp (linux-nonfree)
  (kernel linux-lts) ; TODO make this just `linux` again once nonguix fixes the broadcom-sta patch.
  (initrd microcode-initrd)
  (firmware (cons* linux-firmware
                   (operating-system-firmware os))))
#+end_src
*** Disk encryption
#+begin_src scheme
(define* (disk-encryption os
                          #:key
                          source-uuid
                          (target "ciphered")
                          encrypted-mount-points)
  (let ((encrypted-device (mapped-device
                           (source (uuid source-uuid))
                           (targets (list target))
                           (type luks-device-mapping))))
    (system-comp
     os
     (mapped-devices
      (cons* encrypted-device
             (operating-system-mapped-devices os)))
     (file-systems
      (map (lambda (fs)
             (if (member (file-system-mount-point fs) encrypted-mount-points)
                 (file-system
                   (inherit fs)
                   (dependencies (cons* encrypted-device
                                        (file-system-dependencies fs))))
                 fs))
           (operating-system-file-systems os))))))
#+end_src
*** Stateless
The stateless service should come after base/desktop services (potentially others as well) so its state gets installed before theirs during activation. To this end the ~stateless-service-type~ is appended, not prepended, to operating system services. It also modifies file systems. All of this is to say: include it at the end of the component chain.
#+begin_src scheme
(define-system-comp (stateless #:key persist-dir bluetooth?)
  (initrd (lambda (file-systems . rest)
            (apply (operating-system-initrd os) file-systems
                   #:volatile-root? #t
                   rest)))
  (file-systems
   (map (lambda (fs)
          (if (member (file-system-mount-point fs)
                      `("/var/guix"
                        "/var/log"
                        ,persist-dir))
              (file-system
                (inherit fs)
                (needed-for-boot? #t))
              fs))
        (operating-system-file-systems os)))
  (services
   (append
    (operating-system-user-services os)
    (list
     (service stateless-service-type
              `((#:persist-dir . ,persist-dir)
                (#:paths . ,(append
                             '("/etc/machine-id"
                               "/var/lib/random-seed"
                               "/etc/NetworkManager/system-connections"
                               "/var/lib/NetworkManager/secret_key"
                               "/etc/guix/signing-key.pub"
                               "/etc/guix/signing-key.sec")
                             (if bluetooth?
                                 '("/var/lib/bluetooth") '())))))))))

(define stateless-persist-dir "/.persist")
#+end_src
**** HOLD [#D] Make stateless service more error-tolerant
Hold until I'm done with most of my other filesystem/btrfs tasks so I'm sure the stateless service won't undergo major changes because of them.
- At the very least wrap it in some sort of try/catch and print a warning.
  It needs to be visible. Make the warning big and/or sleep the process for ten-ish sections to make sure I see it?
- I don't want the =install.scm= code I depend on to change and that to mess things up.
  There might not be much I can do about it though. Maybe copy it in?
  - as of [2022-07-30 Sat] =install.scm= hasn't been modified in two years
**** Service
#+begin_src scheme
(define save-or-restore-users+groups
  #~(lambda (persist-dir save-or-restore)
      (for-each (lambda (path)
                  (let ((files (list path (string-append persist-dir path))))
                    (apply copy-file (case save-or-restore
                                       ((#:restore) (reverse files))
                                       ((#:save) files)))))
                '("/etc/group"
                  "/etc/passwd"
                  "/etc/shadow"))))

(define (populate-gexp config)
  (let ((persist-dir (assoc-ref config #:persist-dir)))
    (with-extensions (list guile-gcrypt)
      (with-imported-modules (source-module-closure
                              '((gnu build install)))
        #~(begin
            (use-modules ((gnu build install) #:select (populate-root-file-system)))

            (let* ((system-path "/var/guix/profiles/system")
                   (system-1-path "/var/guix/profiles/system-1-link")
                   (system-1-exists? (file-exists? system-1-path))
                   (system-link (readlink system-path))
                   (system-1-link (if system-1-exists?
                                      (readlink system-1-path)
                                      system-link)))
              (populate-root-file-system system-1-link ""
                                         #:extras `((,system-path -> ,system-link)))
              (unless system-1-exists?
                (delete-file system-1-path)))
            (#$save-or-restore-users+groups #$persist-dir #:restore))))))

(define (activate-state-gexp config)
  (let ((persist-dir (assoc-ref config #:persist-dir))
        (paths (assoc-ref config #:paths)))
    #~(begin
        (use-modules ((ice-9 match) #:select (match)))

        (define (install path)
          (let loop ((components (string-tokenize path (char-set-complement (char-set #\/))))
                     (base #$persist-dir)
                     (target-base ""))
            (match components
              ((head tail ...)
               (let* ((path (string-append base "/" head))
                      (target-path (string-append target-base "/" head)))
                 (if (null? tail)
                     ;; The Guix code makes a point of doing stuff like this atomically. I don't really know why but I will too.
                     (let ((pivot (string-append target-path ".new")))
                       (symlink path pivot)
                       (rename-file pivot target-path))
                     (begin
                       (catch 'system-error
                         (lambda ()
                           (mkdir target-path))
                         (lambda args
                           (unless (= EEXIST (system-error-errno args))
                             (apply throw args))))
                       (let ((st (lstat path)))
                         (chown target-path (stat:uid st) (stat:gid st))
                         (chmod target-path (stat:perms st)))
                       (loop tail path target-path))))))))

        (for-each install '#$paths)
        (#$save-or-restore-users+groups #$persist-dir #:save))))

(define stateless-service-type
  (service-type
   (name 'stateless)
   (extensions
    (list (service-extension boot-service-type
                             populate-gexp)
          (service-extension activation-service-type
                             activate-state-gexp)))
   (description "Initialize a stateless system.")))
#+end_src
*** File systems
**** Ext4
...
**** Btrfs
#+begin_src scheme
(define-system-comp (btrfs #:key
                           (label "firmament")
                           subvols)
  (file-systems
   (append
    (map (match-lambda
           ((subvol . mount-point)
            (file-system
              (device (file-system-label label))
              (mount-point mount-point)
              (type "btrfs")
              (options (string-append "subvol=" subvol ",compress=zstd,autodefrag")))))
         subvols)
    (operating-system-file-systems os))))

(define* (btrfs-subvols #:key stateless? persist-dir nix?)
  (append
   '(("root-blank" . "/")
     ("boot" . "/boot")
     ("guix-store" . "/gnu/store")
     ("guix-var" . "/var/guix")
     ("log" . "/var/log")
     ("home" . "/home"))
   (if stateless?
       `(("persist" . ,persist-dir)) '())
   (if nix?
       '(("nix" . "/nix")) '())))
#+end_src
*** Accounts
#+begin_src scheme
(define-system-comp (accounts #:key
                              users
                              bluetooth?)
  (users
   (append (map (lambda (user)
                  (apply account (->> user
                                      (acons #:bluetooth? bluetooth?)
                                      keyvals)))
                users)
           (operating-system-users os))))

(define* (account #:key
                  name
                  comment
                  shell
                  admin?
                  password
                  (salt "toosimple")
                  bluetooth?)
  (user-account
   (name name)
   (comment (or comment ""))
   (group "users")
   (supplementary-groups (append '("netdev" "audio" "video")
                                 (if admin? '("wheel") '())
                                 (if bluetooth? '("lp") '())))
   (shell (case shell
            ;; ((#:shell/bash) (file-append bash "/bin/bash"))
            ;; ((#:shell/zsh) (file-append zsh "/bin/zsh"))
            (else (default-shell))))
   (password (if password
                 (crypt password salt)
                 #f))))
#+end_src
*** Nonguix substitutes
This could be done using the new [[https://github.com/guix-mirror/guix/commit/fcad6226486b52e5d45531f60811d35eac34fa67][guix-extension]] but it works fine now so I won't change it.
#+begin_src scheme
(define-system-comp (nonguix-substitutes)
  (services
   (update-services
    (operating-system-user-services os)
    guix-service-type
    (lambda (config)
      (guix-configuration
       (inherit config)
       (substitute-urls
        (append (guix-configuration-substitute-urls config)
                (list "https://substitutes.nonguix.org")))
       (authorized-keys
        (append (guix-configuration-authorized-keys config)
                (list (local-file "substitutes.nonguix.org.pub")))))))))
#+end_src
**** Signing key
#+begin_src scheme :tangle (meta-in-dir "substitutes.nonguix.org.pub")
(public-key
 (ecc
  (curve Ed25519)
  (q #C1FD53E5D4CE971933EC50C9F307AE2171A2D3B52C804642A7A35F84F3A4EA98#)))
#+end_src
*** Nix
#+begin_src scheme
(define-system-comp (nix)
  (services
   (cons* (service nix-service-type)
          (operating-system-user-services os))))
#+end_src
*** Console
**** Console keyboard layouts
#+begin_src scheme
(define-system-comp (console-keyboard-layouts #:key keyboard-layout)
  (keyboard-layout keyboard-layout)
  (bootloader (bootloader-configuration
               (inherit (operating-system-bootloader os))
               (keyboard-layout keyboard-layout))))
#+end_src
**** HiDPI console font
#+begin_src scheme
(define-system-comp (hidpi-console-font)
  (services
   (update-services
    (operating-system-user-services os)
    console-font-service-type
    (lambda (config)
      (map (lambda (tty-and-font)
             (cons (car tty-and-font)
                   (file-append font-terminus "/share/consolefonts/ter-132n")))
           config)))))
#+end_src
*** Desktop
**** Desktop services
#+begin_src scheme
(define-system-comp (desktop-services #:key pipewire? bluetooth?)
  (services
   (as-> (operating-system-user-services os) $
     (append selective-desktop-services $)
     (if pipewire?
         (with-pipewire $) $)
     ;; (if bluetooth?
     ;;     (cons* (bluetooth-service #:auto-enable? #t) $))
     )))
#+end_src
***** Pipewire
#+begin_src scheme
(define (with-pipewire services)
  (as-> services $
    (remove-services $ (list pulseaudio-service-type
                             alsa-service-type))
    (cons* (udev-rules-service 'pipewire-add-udev-rules
                               pipewire-0.3)
           $)))
#+end_src
***** \
#+begin_src scheme
(define (remove-services services kinds)
  (remove (lambda (s)
            (member (service-kind s) kinds))
          services))

(define selective-desktop-services
  (remove-services %desktop-services
                   (append (map service-kind %base-services)
                           (list gdm-service-type
                                 screen-locker-service-type))))
#+end_src
**** Display managers
***** GDM
#+begin_src scheme
(define-system-comp (gdm #:key
                         (wayland? #t)
                         auto-login)
  (services
   (cons* (service gdm-service-type
                   (gdm-configuration
                    (auto-login? (if auto-login #t #f))
                    (default-user auto-login)
                    (wayland? wayland?)))
          (operating-system-user-services os))))
#+end_src
**** Desktop environments
***** Gnome
#+begin_src scheme
(define-system-comp (gnome-desktop)
  (services
   (cons* (service gnome-desktop-service-type)
          (operating-system-user-services os))))
#+end_src
**** Window managers
#+begin_src scheme
(define-system-comp (wm #:key package services)
  (packages
   (cons* package
          (operating-system-packages os)))
  (services
   (append services
           (operating-system-user-services os))))
#+end_src
***** Sway
#+begin_src scheme
(define* (sway-wm os #:key laptop?)
  (wm os
      #:package sway
      #:services (cons* swaylock-service
                        (if laptop?
                            (list brightnessctl-udev-rules) '()))))
#+end_src
**** Screen lockers
***** Swaylock
#+begin_src scheme
(define swaylock-service
  (screen-locker-service swaylock))
#+end_src
**** Backlight
***** Brightnessctl
#+begin_src scheme
(define brightnessctl-udev-rules
  (udev-rules-service 'brightnessctl-add-udev-rules brightnessctl))
#+end_src
*** Macbook
**** Wireless
I'm not sure if this requires the nonfree linux kernel and/or if the blacklist refers to kernel modules not present in linux-libre.
#+begin_src scheme
(define-system-comp (macbook-wireless #:key bluetooth?)
  (kernel-arguments (with-blacklist (operating-system-user-kernel-arguments os)
                                    "b43,b43legacy,ssb,bcm43xx,brcm80211,brcmfmac,brcmsmac,bcma"))
  (kernel-loadable-modules (cons* broadcom-sta
                                  (operating-system-kernel-loadable-modules os)))
  (firmware (append
             (if bluetooth? (list broadcom-bt-firmware) '())
             (operating-system-firmware os))))

(define (with-blacklist kernel-args new)

  (define blacklist-param "modprobe.blacklist")
  (define (blacklist? ka)
    (string-prefix? blacklist-param ka))

  (if (any blacklist? kernel-args)
      (update-list kernel-args blacklist? (lambda (blacklist)
                                            (string-append blacklist "," new)))
      (cons* (string-append blacklist-param "=" new) kernel-args)))
#+end_src
**** Keyboard layout
#+begin_src scheme
(define macbook-kbl
  (keyboard-layout "us" #:model "macbook78"))
#+end_src
** Base OS
#+begin_src scheme :tangle (meta-in-dir "base-os.scm")
(define-module (ebullient system base-os)
  #:use-module (ebullient system components)
  #:use-module (ebullient utils)
  #:export (base-os))

(define* (base-os #:key
                  host-name
                  timezone
                  locale
                  users
                  auto-login
                  disk-encryption?
                  luks-uuid
                  stateless?
                  nix?
                  console?
                  desktop?
                  pipewire?
                  bluetooth?
                  sessions
                  laptop?
                  macbook?
                  (kbl (if macbook?
                           macbook-kbl #f)))
  (-> barebones-os
      (host-info #:host-name host-name
                 #:timezone timezone
                 #:locale locale)
      grub-efi
      base-services
      nss
      (accounts #:users users
                #:bluetooth? bluetooth?)
      nonguix-substitutes
      linux-nonfree
      (as-> $
        (if nix?
            (nix $) $)
        (if console?
            (-> $
                (console-keyboard-layouts #:keyboard-layout kbl)
                hidpi-console-font)
            $)
        (if desktop?
            (-> $
                (desktop-services #:pipewire? pipewire?
                                  #:bluetooth? bluetooth?)
                (gdm #:auto-login (if disk-encryption?
                                      auto-login #f))
                (as-> $
                  (if (member #:session/gnome (or sessions '()))
                      (gnome-desktop $) $)
                  (if (member #:session/sway (or sessions '()))
                      (sway-wm $ #:laptop? laptop?) $)))
            $)
        (if macbook?
            (macbook-wireless $ #:bluetooth? bluetooth?) $)
        (let* ((persist-dir stateless-persist-dir)
               (subvols (btrfs-subvols #:stateless? stateless?
                                       #:persist-dir persist-dir
                                       #:nix? nix?)))
          (-> $
              (btrfs #:subvols subvols)
              (as-> $
                (if disk-encryption?
                    (disk-encryption $ #:source-uuid luks-uuid
                                     #:encrypted-mount-points (map cdr subvols))
                    $)
                (if stateless?
                    (stateless $ #:persist-dir persist-dir
                               #:bluetooth? bluetooth?)
                    $)))))))
#+end_src
* Home
:PROPERTIES:
:meta-dir+: /ebullient/home
:END:
** Packages
:PROPERTIES:
:meta-dir+: /packages
:END:
*** Fonts :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "fonts.scm")
:END:
#+begin_src scheme
(define-module (ebullient home packages fonts)
  #:use-module (guix build-system font)
  #:use-module (guix packages)
  #:use-module ((gnu packages fonts) #:select (font-adobe-source-code-pro font-awesome) #:prefix fonts:)
  #:use-module (ebullient utils))

(define-public font-adobe-source-code-pro
  (with-git-version
   fonts:font-adobe-source-code-pro
   #:version "2.038R-ro-1.058R-it-1.018R-VAR"
   #:commit "2.038R-ro/1.058R-it/1.018R-VAR"
   #:hash "00h4v3rmxyyaxni6nywacxvjnji2g2pi0b4js1yx0g67fvrv2gag"))

(define-public font-awesome
  (let ((version "6.1.2"))
    (with-git-version
     (package
       (inherit fonts:font-awesome)
       (build-system font-build-system)
       (arguments '()))
     #:version version
     #:commit version
     #:hash "0ikax3i6xkv6nrc8w543rfp9bs72mxz7zc0irq21y4jw8mqahpwq")))
#+end_src
** Components
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "components.scm")
:END:
#+begin_src scheme
(define-module (ebullient home components)
  #:use-module (guix gexp)
  #:use-module (gnu home services)
  #:use-module (gnu home services shells)
  #:use-module (gnu home services shepherd)
  #:use-module (gnu home services ssh)
  #:use-module (gnu home services xdg)
  #:use-module (gnu home-services terminals)
  #:use-module (gnu home-services version-control)
  ;; #:use-module ((gnu packages bash) #:select (bash))
  #:use-module ((gnu packages compression) #:select (zip unzip))
  #:use-module ((gnu packages curl) #:select (curl))
  #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages fonts) #:select (font-google-noto))
  #:use-module ((gnu packages freedesktop) #:select (udiskie xdg-utils xdg-user-dirs desktop-file-utils xdg-desktop-portal xdg-desktop-portal-wlr))
  #:use-module ((gnu packages glib) #:select (dbus))
  #:use-module ((gnu packages gnome) #:select (network-manager-applet))
  #:use-module ((gnu packages image) #:select (grim slurp swappy))
  #:use-module ((gnu packages linux) #:select (brightnessctl psmisc pipewire-0.3 wireplumber))
  #:use-module ((gnu packages music) #:select (playerctl))
  #:use-module ((gnu packages package-management) #:select (flatpak))
  #:use-module ((gnu packages pulseaudio) #:select (pulseaudio pavucontrol))
  #:use-module ((gnu packages qt) #:select (qtwayland))
  #:use-module ((gnu packages rust-apps) #:select (swayhide))
  #:use-module ((gnu packages shells) #:select (zsh))
  #:use-module ((gnu packages shellutils) #:select (direnv))
  #:use-module ((gnu packages terminals) #:select (alacritty))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module ((gnu packages web) #:select (jq))
  #:use-module ((gnu packages wm) #:select (swaylock swaylock-effects swayidle waybar))
  #:use-module ((gnu packages xdisorg) #:select (gammastep rofi wl-clipboard))
  #:use-module (gnu services)
  #:use-module (gnu services shepherd)
  #:use-module (rde home services wm)
  #:use-module (rde home services xdisorg)
  #:use-module ((rde packages) #:select (rofi-wayland (sway-latest . sway)))
  #:use-module ((ebullient home packages doom-emacs) #:select (doom-emacs))
  #:use-module ((ebullient home packages emacs) #:select (emacs-fully-loaded-pgtk))
  #:use-module ((ebullient home packages fonts) #:select (font-adobe-source-code-pro font-awesome))
  #:use-module (ebullient utils)
  #:use-module ((srfi srfi-1) #:select (append-map))

  #:export (he-packages
            he-shells
            he-fonts
            font-monospace
            he-nix
            he-emacs
            he-doom
            he-git
            he-ssh
            he-direnv
            he-xdg
            he-desktop-packages
            he-pipewire
            he-flatpak
            he-sway
            he-swaylock
            swaylock-screen-locker
            he-swayidle
            swayidle-idle-manager
            he-waybar
            he-rofi
            rofi-application-launcher
            he-alacritty
            alacritty-terminal
            gammastep-applet-service-type
            network-manager-applet-service-type
            udiskie-applet-service-type))

(define serialize-elisp-config (@@ (gnu home-services emacs) serialize-elisp-config))
#+end_src
*** Packages
#+begin_src scheme
(define* (he-packages #:key
                      (packages (list curl
                                      zip
                                      unzip)))
  (list
   (simple-service
    'packages-add
    home-profile-service-type
    packages)))
#+end_src
*** Shells
#+begin_src scheme
(define* (he-shells #:key
                    login-shell
                    interactive-shell
                    ;; (bashrc (local-file "bashrc"))
                    (zshrc (local-file "zshrc")))
  (let ((setup-shell? (lambda (shell)
                         (memq shell (list login-shell interactive-shell)))))
     (list
      (when (setup-shell? #:shell/bash)
        (service home-bash-service-type
                 ;; (home-bash-configuration
                 ;;  (bashrc
                 ;;   (list (local-file "bashrc"))))
                 ))
      (when (setup-shell? #:shell/zsh)
        (service home-zsh-service-type
                 (home-zsh-configuration
                  (zshrc
                   (list zshrc)))))
      (when-not (eq? login-shell interactive-shell)
        (simple-service
         'set-shell-env-var
         home-environment-variables-service-type
         `(("SHELL" . ,(case interactive-shell
                         ;; ((#:shell/bash) (file-append bash "/bin/bash"))
                         ((#:shell/zsh) (file-append zsh "/bin/zsh"))))))))))
#+end_src
**** Bash
***** Bashrc
...
**** Zsh
***** Zshrc
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "zshrc")
:END:
****** Andrew Tropin's zshrc
- TODO trying out Andrew Tropin's zsh configuration verbatim for now. Should I also try out vanilla zshell?
#+begin_src sh
# Prevent freezing output on ^s, needed for various isearches
hash stty 2> /dev/null && stty -ixon

# Completions and other stuff
autoload -U compinit
compinit -d ${XDG_CACHE_HOME:-$HOME/.cache}/.zcompdump

# Enable bash completion, requires to source them from somewhere
# autoload -U bashcompinit && bashcompinit

zstyle ':completion:*' menu select
zstyle ':completion:*' insert-tab false

# Automatically update cache of binaries avaliable in $PATH
zstyle ':completion:*' rehash true # Can have a performance penalty

# Approximate completion
# zstyle ':completion:::::' completer _complete _approximate
# zstyle ':completion:*:approximate:*' max-errors 2

# Fuzzy completion
# https://superuser.com/questions/415650/does-a-fuzzy-matching-mode-exist-for-the-zsh-shell
zstyle ':completion:*' matcher-list '' \
  'm:{a-z\-}={A-Z\_}' \
  'r:[^[:alpha:]]||[[:alpha:]]=** r:|=* m:{a-z\-}={A-Z\_}' \
  'r:|?=** m:{a-z\-}={A-Z\_}'

# Make kill completion smart
zstyle ':completion:*:*:*:*:processes' command "ps -u $USER -o pid,user,args -w -w"

# Colored completion for files and dirs according to LS_COLORS

hash dircolors 2> /dev/null && eval $(dircolors --sh) && \
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

# Prompt theme setup
clear_fn() {
#  zle reset-prompt
  zle kill-buffer
}

prompt_rde_precmd() {
  # Prevent killing prompt on ^C
  trap 'clear_fn' SIGINT
}

prompt_rde_setup() {
  if [[ $UID -eq 0 ]]; then
    user_part='%F{red}>%f'
  else
    user_part='%F{green}>%f'
  fi
  if [ -n "$GUIX_ENVIRONMENT" ]; then
    genv_part='%F{blue}>%f'
  fi
  # exit_code_part='%(?..[%?])'

  PS1="$user_part$genv_part "
  # RPS1="$exit_code_part"

  # Fish-like C-c behavior
  # add-zsh-hook precmd prompt_rde_precmd
}

# Load promptinit and set rde theme
autoload -Uz promptinit && promptinit
prompt_themes+=( rde )
prompt rde

setopt printexitvalue # Instead of using RPS1 for status code

echo -en "\033[6 q" # Make a cursor to be a vertical bar

# Remove slashes and dashes from wordchars to make M-b, M-f work
# correctly
WORDCHARS=""

# Configure history
# HISTSIZE=5000
# SAVEHIST=$HISTSIZE
HISTFILE=${XDG_CACHE_HOME:-$HOME/.cache}/.zhistory

#setopt incappendhistory # Save history to shared file, but not read
setopt sharehistory     # Share history across shell sessions
setopt histignorespace  # Ignore commands that start with space

# Configuring help (M-h to call it on current command/function)
autoload -Uz run-help
(( ${+aliases[run-help]} )) && unalias run-help
autoload -Uz run-help-git

# Delete, home, end buttons
bindkey  "^[[3~"  delete-char
bindkey  "^[[H"   beginning-of-line
bindkey  "^[[F"   end-of-line

# Launch $VISUAL or $EDITOR, for emacsclient if there is no server
# avaliable $ALTERNATE_EDITOR will be used.
autoload -z edit-command-line
zle -N edit-command-line
bindkey "^X^E" edit-command-line

alias help=run-help
alias try='guix shell man-db coreutils'
alias ls='ls -p --color=auto'
alias ll='ls -l'
alias grep='grep --color=auto'
#+end_src
****** History
#+begin_src sh
HISTSIZE=1000000
SAVEHIST=$HISTSIZE
#+end_src
*** Fonts
#+begin_src scheme
(define* (he-fonts #:key fonts)
  (list
   (simple-service
    'fonts-add-packages
    home-profile-service-type
    (map (lambda (font)
           (assoc-ref font #:font/package))
         fonts))))

(define font-monospace
  `((#:font/name . "Source Code Pro")
    (#:font/size . 12)
    (#:font/weight . ,'medium)
    (#:font/package . ,font-adobe-source-code-pro)))
#+end_src
*** Nix
#+begin_src scheme
(define* (he-nix #:key
                 (nix-channels (local-file "nix-channels"))
                 (nixpkgs-config (local-file "nixpkgs-config.nix")))
  (list
   (simple-service
    'nix-add-channels
    home-files-service-type
    `((".nix-channels"
       ,nix-channels)))

   (simple-service
    'nix-add-nixpkgs-config
    home-xdg-configuration-files-service-type
    `(("nixpkgs/config.nix"
       ,nixpkgs-config)))))
#+end_src
**** Load Nix environment
TODO and remove "tangle no"
#+begin_src sh :tangle no
if [ -f /run/current-system/profile/etc/profile.d/nix.sh ]; then
  . /run/current-system/profile/etc/profile.d/nix.sh
fi
#+end_src
**** Nix channels
#+begin_src conf :tangle (meta-in-dir "nix-channels")
https://nixos.org/channels/nixpkgs-unstable nixpkgs
#+end_src
**** Nixpkgs config
#+begin_src nix :tangle (meta-in-dir "nixpkgs-config.nix")
{ allowUnfree = true; }
#+end_src
**** Nix WIP
TODO and remove all the COMMENT keywords
Commands and stuff (like manifests install and upgrade and guix channel pull) plus a packages "manifest"
***** COMMENT Update channels
#+begin_src sh :results output silent :async
nix-channel --update
#+end_src
***** COMMENT "Manifest"
- TODO might want to / see if I can make this a simple bulleted list I pass with :var to source block(s)
#+name: nix-packages
#+begin_src org
google-chrome zoom-us
#+end_src
***** COMMENT Install packages
#+begin_src sh :results output silent :async :noweb yes
nix-env --install <<nix-packages>>
#+end_src
***** COMMENT Upgrade packages
#+begin_src sh :results output silent :async
nix-env --upgrade
#+end_src
***** how to pin packages?
Is [[https://nixos.wiki/wiki/FAQ/Pinning_Nixpkgs][this]] the right way? Maybe the new nix CLI will have a better option?
*** Emacs
#+begin_src scheme
(define* (he-emacs #:key
                   (emacs emacs-fully-loaded-pgtk)
                   zsh-vterm?)
  (list
   (simple-service
    'emacs-add-package
    home-profile-service-type
    (list emacs))

   (simple-service
    'emacs-set-editor-env-vars
    home-environment-variables-service-type
    `(("VISUAL" . ,(file-append emacs "/bin/emacsclient"))
      ("EDITOR" . "$VISUAL")))

   (when zsh-vterm?
     (simple-service
      'emacs-zsh-vterm
      home-zsh-service-type
      (home-zsh-extension
       (zshrc
        (list (local-file "zsh-vterm"))))))))
#+end_src
**** Configure zsh for vterm
#+begin_src sh :tangle (meta-in-dir "zsh-vterm")
vterm_printf(){
    if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ] ); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    elif ([ "${TERM%%-*}" = "eterm" ] || [ "${TERM%%-*}" = "dumb" ]); then
        # Do nothing for Emacs' term and ansi-term, and other dumb terminals.
    else
        printf "\e]%s\e\\" "$1"
    fi
}

vterm_prompt_end() {
    # USERNAME=$(whoami)
    # HOSTNAME=$(hostname)
    vterm_printf "51;A$USER@$HOST:$(pwd)";
}
setopt PROMPT_SUBST
PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'
#+end_src
**** Emacs packages
:PROPERTIES:
:meta-dir+: /packages
:header-args+: :tangle (meta-in-dir "emacs.scm")
:END:
#+begin_src scheme
(define-module (ebullient home packages emacs)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages compression) #:select (zstd))
  #:use-module ((gnu packages emacs) #:select (emacs emacs-next-pgtk))
  #:use-module ((gnu packages gcc) #:select (gcc-12))
  #:use-module (ebullient utils)
  #:export (;; emacs-fully-loaded
            emacs-fully-loaded-pgtk))

(define emacs-with-native-comp (@@ (flat packages emacs) emacs-with-native-comp))
#+end_src
***** Emacs latest :version:
Use the github mirror since the canonical repo (https://git.savannah.gnu.org/git/emacs.git) doesn't allow shallow fetches.
#+begin_src scheme
(define-public (with-emacs-latest emacs)
  (-> emacs
      (with-git-commit #:commit "d92fb1592a02f7e34fb82069fc8d61d85dac8a48"
                       #:hash "12xhfiikz349vndfj992mkm0hjvbarc8l4731sk8i76a17nnfkz5")
      (with-git-url "https://github.com/emacs-mirror/emacs")))
#+end_src
***** Wayland =Super= fix
#+begin_src scheme
(define-public (with-wayland-super-fix emacs)
  (package
    (inherit emacs)
    (source
     (origin
       (inherit (package-source emacs))
       (patches
        (cons "/home/pharcosyle/projects/phrenetic/ebullient/home/packages/patches/wayland-super-fix.patch" ; (local-file "patches/wayland-super-fix.patch") ; TODO why isn't this working with local-file?
              (-> emacs package-source origin-patches)))))))
#+end_src
****** WAIT [#E] Remove the Wayland =Super= fix
Once either:
- The issue [[https://gitlab.gnome.org/GNOME/gtk/-/issues/4913][GDK_SUPER_MASK is not set on Super key press events on Wayland / wlroots (#49...]] is resolved.
  As discussed in [[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=55362][#55362 - 29.0.50; Super key no longer works on Wayland - GNU bug report logs]].
- I find a workaround with KMonad after I start using it.
****** Patch
#+begin_src diff :tangle (meta-in-dir "patches/wayland-super-fix.patch")
diff --git src/pgtkterm.c src/pgtkterm.c
index 566fc1f03d..1cb4d5dac0 100644
--- a/src/pgtkterm.c
+++ b/src/pgtkterm.c
@@ -5207,7 +5207,7 @@ pgtk_gtk_to_emacs_modifiers (struct pgtk_display_info *dpyinfo, int state)
     mod |= mod_ctrl;
   if (state & GDK_META_MASK || state & GDK_MOD1_MASK)
     mod |= mod_meta;
-  if (state & GDK_SUPER_MASK)
+  if (state & GDK_SUPER_MASK || state & GDK_MOD4_MASK)
     mod |= mod_super;
   if (state & GDK_HYPER_MASK)
     mod |= mod_hyper;
@@ -5340,7 +5340,7 @@ key_press_event (GtkWidget *widget, GdkEvent *event, gpointer *user_data)
       /* While super is pressed, the input method will always always
 	 resend the key events ignoring super.  As a workaround, don't
 	 filter key events with super or hyper pressed.  */
-      if (!(event->key.state & (GDK_SUPER_MASK | GDK_HYPER_MASK)))
+      if (!(event->key.state & (GDK_SUPER_MASK | GDK_MOD4_MASK | GDK_HYPER_MASK)))
 	{
 	  if (pgtk_im_filter_keypress (f, &event->key))
 	    return TRUE;
@@ -5356,8 +5356,9 @@ key_press_event (GtkWidget *widget, GdkEvent *event, gpointer *user_data)
       /* make_lispy_event turns chars into control chars.
          Don't do it here because XLookupString is too eager.  */
       state &= ~GDK_CONTROL_MASK;
-      state &= ~(GDK_META_MASK
-		 | GDK_SUPER_MASK | GDK_HYPER_MASK | GDK_MOD1_MASK);
+      state &= ~(GDK_META_MASK | GDK_MOD1_MASK
+		 | GDK_SUPER_MASK | GDK_MOD4_MASK
+		 | GDK_HYPER_MASK);

       nbytes = event->key.length;
       if (nbytes > copy_bufsiz)
#+end_src
***** Native comp
#+begin_src scheme
(define-public (with-native-comp emacs)
  (emacs-with-native-comp emacs gcc-12 'full-aot))
#+end_src
***** Findable C source
#+begin_src scheme
(define-public (with-findable-C-source emacs)
  (package
    (inherit emacs)
    (arguments
     (substitute-keyword-arguments (package-arguments emacs)
       ((#:phases phases '%standard-phases)
        #~(modify-phases #$phases
            (add-after 'unpack 'patch-C-source-directory
              (lambda _
                (substitute* "lisp/emacs-lisp/find-func.el"
                  (("\\(expand-file-name \"src\" source-directory\\)")
                   (string-append "\"" #$(file-append (package-source emacs) "/src") "\"")))))))))))
#+end_src
***** =zstd=
#+begin_src scheme
(define-public (with-zstd emacs)
  (package
    (inherit emacs)
    (propagated-inputs
     (modify-inputs (package-propagated-inputs emacs)
       (prepend zstd)))))
#+end_src
****** TODO [#E] Add =zstd= to emacs program wrapper
i.e. by using ~wrap-program~ on the emacs executable instead of just adding it to the propagated inputs. It's a bit tricky (see the ~strip-double-wrap~ build phase in the emacs package definition) and I don't want to mess it up and introduce possibly subtle problems.
***** Path integration improvements
#+begin_src scheme
(define-public (with-path-integration-improvements emacs)
  (package
    (inherit emacs)
    (source
     (origin
       (inherit (package-source emacs))
       (snippet
        `(begin
           ,(origin-snippet (package-source emacs))
           (let ((wrap-in-quotes (lambda (s)
                                   (string-append "\"" s "\""))))
             (with-directory-excursion "lisp"
               (substitute* "net/tramp.el"
                 (("\\(tramp-default-remote-path" start-of-list)
                  (string-join
                   (cons start-of-list
                         (map wrap-in-quotes
                              (list "~/.config/guix/current/bin"
                                    "~/.guix-home/profile")))
                   " ")))
               (substitute* "man.el"
                 (("\"/usr/local/include\"" last-item)
                  (string-join
                   (list last-item
                         (wrap-in-quotes "~/.guix-home/profile/include"))
                   " ")))))))))))
#+end_src
***** Emacs fully loaded :package:
#+begin_src scheme
(define* (emacs-fully-loaded* #:key pgtk?)
  (-> (if pgtk?
          (-> emacs-next-pgtk
              with-emacs-latest
              with-wayland-super-fix)
          emacs)
      with-native-comp
      with-findable-C-source
      with-zstd
      with-path-integration-improvements))

;; (define emacs-fully-loaded (emacs-fully-loaded*))
(define emacs-fully-loaded-pgtk (emacs-fully-loaded* #:pgtk? #t))
#+end_src
*** Doom
#+begin_src scheme
(define* (he-doom #:key
                  (doom-private (local-file "doom-private" #:recursive? #t))
                  full-name
                  email
                  font)
  (list
   (simple-service
    'doom-add-packages
    home-profile-service-type
    (list `(,doom-emacs "bin")))

   (simple-service
    'doom-add-config
    home-xdg-configuration-files-service-type
    `(("emacs"
       ,doom-emacs)
      ("doom"
       ,(directory-union
         "doom-private-with-params"
         `(,doom-private
           ,(file-union
             "params-dir"
             `(("params.el"
                ,(mixed-text-file
                  "params.el"
                  (serialize-elisp-config
                   #f
                   `((setq param-full-name ,full-name)
                     (setq param-email ,email)
                     (setq param-font-name ,(assoc-ref font #:font/name))
                     (setq param-font-size ,(assoc-ref font #:font/size))
                     (setq param-font-weight ',(assoc-ref font #:font/weight)))))))))))))))
#+end_src
**** Doom Emacs :package:version:
:PROPERTIES:
:meta-dir+: /packages
:END:
#+begin_src scheme :tangle (meta-in-dir "doom-emacs.scm")
(define-module (ebullient home packages doom-emacs)
  #:use-module (guix build-system copy)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module ((gnu packages rust-apps) #:select (fd ripgrep))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module ((ebullient home packages all-the-icons-fonts) #:select (all-the-icons-fonts)))

(define-public doom-emacs
  (let ((commit "a71e757c8d14fbe0eb7187b9bd6d317edf302f27")
        (revision "0"))
    (package
      (name "doom-emacs")
      (version (git-version "3.0.0-dev" revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/doomemacs/doomemacs")
               (commit commit)))
         (sha256
          (base32
           "1nry7k7vm09rx4g1x1yqf5vy0r5n3qa1chi14lppcijj6isjz9c6"))
         (file-name (git-file-name name version))
         (patches
          (list (local-file "patches/change-paths.patch")
                ;; (local-file "patches/ligatures.patch")
                ))))
      (build-system copy-build-system) ; TODO LICENSE file gets installed to a "share/" folder, not hurting anything but maybe remove. More generally perhaps check to see what other changes there might be between a simple checkout of the repo and post- copy-build-system
      (arguments
       (list
        ;; #:install-plan
        ;; '(("." "share/doom-emacs/"))
        ;; #:tests? #t
        ;; #:test-command '("./bin/doom" "test")
        #:phases
        #~(modify-phases %standard-phases
            (add-after 'install 'symlink-bin
              (lambda _
                (mkdir #$output:bin)
                (symlink (string-append #$output "/bin")
                         (string-append #$output:bin "/bin")))))))
      (propagated-inputs
       (list git
             ripgrep
             fd
             all-the-icons-fonts))
      (outputs '("out" "bin"))
      (synopsis "An Emacs framework for the stubborn martian hacker")
      (description "Doom is a configuration framework for GNU Emacs tailored for
Emacs bankruptcy veterans who want less framework in their frameworks, a modicum
of stability (and reproducibility) from their package manager, and the
performance of a hand rolled config (or better).")
      (home-page "https://github.com/doomemacs/doomemacs")
      (license license:expat))))
#+end_src
***** WAIT Doom tests :wait_on_doom:
Nonfunctional at the moment ([[doom:core/core-cli.el::212][hlissner has them commented out]]) but once they're working determine if they make sense to run during packaging (if they can find places where my patches, substitutions, etc. can mess stuff up). I'm concerned they'll take too long to run or require network access (to download Straight dependencies). Make sure there aren't any side effect files that end up getting installed.
***** Emacs packages :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "emacs-xyz.scm")
:END:
#+begin_src scheme
(define-module (ebullient home packages emacs-xyz)
  #:use-module (guix build-system copy)
  #:use-module (guix build-system emacs)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages emacs-xyz) #:select (emacs-tldr) #:prefix emacs-xyz:)
  #:use-module ((gnu packages compression) #:select (unzip))
  #:use-module (ebullient utils))
#+end_src
****** guix-contributing
#+begin_src scheme
(define-public emacs-guix-contributing
  (package
    (name "emacs-guix-contributing")
    (version "0")
    (source
     (local-file "guix-contributing.el"))
    (build-system emacs-build-system)
    (arguments
     '(#:phases
       (modify-phases %standard-phases
         (add-after 'unpack 'patch-guix-source-path
           (lambda* (#:key inputs #:allow-other-keys)
             (make-file-writable "guix-contributing.el")
             (emacs-substitute-variables "guix-contributing.el"
               ("guix-contributing-source-path" (search-input-directory inputs "share/guix-emacs-development"))))))))
    (inputs
     (list guix-emacs-development))
    (home-page #f)
    (synopsis "Some Emacs integration to assist in contributing to Guix")
    (description "See https://guix.gnu.org/manual/en/guix.html#The-Perfect-Setup")
    (license license:gpl3+)))
#+end_src
******* Source
#+begin_src elisp :tangle (meta-in-dir "guix-contributing.el")
(defvar guix-contributing-source-path "~/src/guix")

(with-eval-after-load 'yasnippet
  (add-to-list 'yas-snippet-dirs (concat guix-contributing-source-path "/etc/snippets")))

(load-file (concat guix-contributing-source-path "/etc/copyright.el"))

(when (and user-full-name
           user-mail-address)
  (setq copyright-names-regexp (format "%s <%s>" user-full-name user-mail-address)))

(provide 'guix-contributing)
#+end_src
******* Guix's Emacs development code
Use the github mirror since the canonical repo doesn't allow shallow fetches.
#+begin_src scheme
(define guix-emacs-development*
  (let ((commit "bf0389a3806509650b7a8425973ac5aac722901a")
        (revision "0"))
    (package
      (name "guix-emacs-development")
      (version (git-version "1.3.0" revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://git.savannah.gnu.org/git/guix.git")
               (commit commit)))
         (sha256
          (base32
           "0x4mpw017q4l14aimlyzxxa68jz2rn6zb8m8l7s791fkkdn2paja"))))
      (build-system copy-build-system)
      (arguments
       `(#:install-plan
         '(("etc/copyright.el" "share/guix-emacs-development/etc/copyright.el")
           ("etc/snippets" "share/guix-emacs-development/etc/snippets"))))
      (home-page #f)
      (synopsis #f)
      (description #f)
      (license #f))))

(define guix-emacs-development
  (with-git-url guix-emacs-development* "https://github.com/guix-mirror/guix"))
#+end_src
****** tldr
#+begin_src scheme
(define-public emacs-tldr
  (package
    (inherit emacs-xyz:emacs-tldr)
    (arguments
     (substitute-keyword-arguments (package-arguments emacs-xyz:emacs-tldr)
       ((#:phases phases '%standard-phases)
        #~(modify-phases #$phases
            (add-after 'unpack 'patch-tldr-directory-path
              (lambda* (#:key inputs #:allow-other-keys)
                (emacs-substitute-variables "tldr.el"
                  ("tldr-directory-path" (search-input-directory inputs "share/tldr-pages")))))))))
    (inputs (modify-inputs (package-inputs emacs-xyz:emacs-tldr)
              (prepend tldr-pages)))))
#+end_src
******* tldr pages
#+begin_src scheme
(define tldr-pages
  (let ((commit "7ee7ed0f4afc90ef05b1dde87f6fec5b462a0394")
        (revision "0"))
    (package
      (name "tldr-pages")
      (version (git-version "1.5b" revision commit))
      (source
       (origin
         (method url-fetch/zipbomb)
         (uri (string-append "https://raw.githubusercontent.com/tldr-pages/tldr-pages.github.io/" commit "/assets/tldr.zip"))
         (sha256
          (base32
           "0a09ycfrxiaxv0hzjrkwi56l0ga5d7ydrlclmk4vd6ndb242vhgr"))))
      (build-system copy-build-system)
      (arguments
       `(#:install-plan
         '(("." "share/tldr-pages/"))))
      (home-page "https://tldr.sh")
      (synopsis "A collection of community-maintained help pages for command-line tools")
      (description synopsis)
      (license license:cc-by4.0))))
#+end_src
***** all-the-icons fonts :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "all-the-icons-fonts.scm")
:END:
#+begin_src scheme
(define-module (ebullient home packages all-the-icons-fonts)
  #:use-module (guix build-system font)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((gnu packages emacs-xyz) #:select (emacs-all-the-icons))
  #:use-module ((gnu packages fonts) #:select (font-google-material-design-icons))
  #:use-module ((ebullient home packages fonts) #:select (font-awesome))
  #:use-module (ebullient utils))

(define-public all-the-icons-fonts
  (let ((commit "6f876fa11ef64af20d9b2a44fdabac6446de51ba")
        (revision "0"))
    (package
      (name "all-the-icons-fonts")
      (version (git-version (package-version emacs-all-the-icons) revision commit))
      (source
       (origin
         (inherit (package-source emacs-all-the-icons))
         (uri (git-reference
               (inherit (-> emacs-all-the-icons package-source origin-uri))
               (commit commit)))
         (sha256
          (base32
           "1n975ziy5wyfnmmpak1vsj7nqzm5ciw811pcg7rdmc2ljlc90n5p"))
         (file-name (git-file-name name version))))
      (build-system font-build-system)
      (arguments
       `(#:phases
         (modify-phases %standard-phases
           (add-before 'install 'remove-unbundled-fonts
             (lambda _
               (with-directory-excursion "fonts"
                 (for-each delete-file
                           (list "fontawesome.ttf"
                                 "material-design-icons.ttf"))))))))
      (propagated-inputs
       (list font-awesome
             font-google-material-design-icons))
      (home-page (package-home-page emacs-all-the-icons))
      (synopsis (package-synopsis emacs-all-the-icons))
      (description (package-description emacs-all-the-icons))
      (license (package-license emacs-all-the-icons)))))
#+end_src
***** Patches
****** Change paths
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "patches/change-paths.patch")
:END:
******* Core
#+begin_src diff
diff --git a/lisp/doom.el b/lisp/doom.el
index 9811906..48fb274 100644
--- a/lisp/doom.el
+++ b/lisp/doom.el
@@ -209,7 +209,9 @@ downloaded/installed by packages. Must end in a slash.")
       (expand-file-name (file-name-as-directory localdir))
     (if doom-profile
         doom-profile-dir
-      (expand-file-name ".local/" doom-emacs-dir)))
+      (expand-file-name "doom-local/"
+                        (or (getenv-internal "XDG_STATE_HOME")
+                            "~/.local/state"))))
   "Root directory for local storage.

 Use this as a storage location for this system's installation of Doom Emacs.
@@ -217,10 +219,17 @@ Use this as a storage location for this system's installation of Doom Emacs.
 These files should not be shared across systems. By default, it is used by
 `doom-etc-dir' and `doom-cache-dir'. Must end with a slash.")

+(defconst doom-state-dir
+  (if-let (localdir (getenv-internal "DOOMLOCALDIR"))
+      (concat (expand-file-name (file-name-as-directory localdir)) "state/")
+    (expand-file-name "doom/"
+                      (or (getenv-internal "XDG_STATE_HOME")
+                          "~/.local/state"))))
+
 (defconst doom-etc-dir
   (if doom-profile
       doom-profile-data-dir
-    (concat doom-local-dir "etc/"))
+    (concat doom-state-dir "etc/"))
   "Directory for non-volatile local storage.

 Use this for files that don't change much, like server binaries, external
@@ -229,7 +238,7 @@ dependencies or long-term shared data. Must end with a slash.")
 (defconst doom-cache-dir
   (if doom-profile
       doom-profile-cache-dir
-    (concat doom-local-dir "cache/"))
+    (concat doom-state-dir "cache/"))
   "Directory for volatile local storage.

 Use this for files that change often, like cache files. Must end with a slash.")
@@ -246,7 +255,7 @@ autoloaded core functions (in lisp/lib/*.el).")
 (defconst doom-env-file
   (if doom-profile
       (expand-file-name "env" doom-profile-dir)
-    (concat doom-local-dir "env"))
+    (concat doom-state-dir "env"))
   "The location of your envvar file, generated by `doom env`.

 This file contains environment variables scraped from your shell environment,
@@ -294,7 +303,7 @@ users).")
 (when NATIVECOMP
   ;; Don't store eln files in ~/.emacs.d/eln-cache (where they can easily be
   ;; deleted by 'doom upgrade').
-  (add-to-list 'native-comp-eln-load-path (concat doom-cache-dir "eln/"))
+  (add-to-list 'native-comp-eln-load-path (concat doom-local-dir "eln/"))

   (with-eval-after-load 'comp
     ;; HACK Disable native-compilation for some troublesome packages
@@ -328,7 +337,7 @@ users).")

 ;; Allow the user to store custom.el-saved settings and themes in their Doom
 ;; config (e.g. ~/.doom.d/).
-(setq custom-file (expand-file-name "custom.el" doom-private-dir))
+(setq custom-file (expand-file-name "custom.el" doom-state-dir))

 ;; By default, Emacs stores `authinfo' in $HOME and in plain-text. Let's not do
 ;; that, mkay? This file stores usernames, passwords, and other treasures for
#+end_src
******* RSS module
#+begin_src diff
diff --git a/modules/app/rss/config.el b/modules/app/rss/config.el
index a8078d1..075a5c8 100644
--- a/modules/app/rss/config.el
+++ b/modules/app/rss/config.el
@@ -20,8 +20,8 @@ easier to scroll through.")
 (use-package! elfeed
   :commands elfeed
   :init
-  (setq elfeed-db-directory (concat doom-local-dir "elfeed/db/")
-        elfeed-enclosure-default-dir (concat doom-local-dir "elfeed/enclosures/"))
+  (setq elfeed-db-directory (concat doom-cache-dir "elfeed/db/")
+        elfeed-enclosure-default-dir (concat doom-cache-dir "elfeed/enclosures/"))
   :config
   (setq elfeed-search-filter "@2-week-ago "
         elfeed-show-entry-switch #'pop-to-buffer
#+end_src
****** Ligatures
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "patches/ligatures.patch")
:END:
Taken from this as-yet unmerged pull request: [[https://github.com/doomemacs/doomemacs/pull/5082][doomemacs/doomemacs#5082 feat(:ui ligatures): use ligature.el for Emacs28+ by...]]
******* README
#+begin_src diff
diff --git a/modules/ui/ligatures/README.org b/modules/ui/ligatures/README.org
index 66d969ff1..ed486dbf6 100644
--- a/modules/ui/ligatures/README.org
+++ b/modules/ui/ligatures/README.org
@@ -16,8 +16,10 @@
   - [[#mathematical-symbols-replacement][Mathematical symbols replacement]]
   - [[#coding-ligatures][Coding ligatures]]
 - [[#configuration][Configuration]]
-  - [[#setting-ligatures][Setting ligatures]]
-  - [[#changing-ligatures][Changing ligatures]]
+  - [[#setting-symbol-replacements][Setting symbol replacements]]
+  - [[#changing-symbol-replacements][Changing symbol replacements]]
+  - [[#setting-ligatures-for-specific-font-or-major-mode][Setting ligatures for specific font or major mode]]
+    - [[#overwriting-all-default-ligatures][Overwriting all default ligatures]]
 - [[#troubleshooting][Troubleshooting]]
 
 ,* Description
@@ -53,7 +55,7 @@ Harfbuzz support (which can compose ligatures natively), or b) Mitsuharu's
 ,#+end_quote
 
 ,** Plugins
-This module installs no packages.
+- [[https://github.com/mickeynp/ligature.el][ligature.el]] (on Emacs 28+ with Harfbuzz)
 
 ,* Prerequisites
 This module requires one of three setups for ligatures to work:
@@ -103,9 +105,9 @@ Even though harfbuzz has been included in emacs 27, there is currently a [[https
 emacs 27.
 
 ,* Configuration
-** Setting ligatures
-If you want to set ligatures for modules that don't have them by default you can
-use the ~set-ligatures!~ macro in your config el file
+** Setting symbol replacements
+If you want to set symbol replacements for modules that don't have them by
+default you can use the ~set-ligatures!~ macro in your config el file
 ,#+BEGIN_SRC emacs-lisp
 (after! PACKAGE
   (set-ligatures! 'MAJOR-MODE
@@ -167,7 +169,7 @@ If you have multiple versions of the same keyword you can set the symbol twice
   :null "none"
   :null "None")
 ,#+END_SRC
-** Changing ligatures
+** Changing symbol replacements
 if you don't like the symbols chosen you can change them by using...
 
 ,#+BEGIN_SRC emacs-lisp
@@ -212,5 +214,53 @@ if you don't like the symbols chosen you can change them by using...
   :dot           "")  ;; you could also add your own if you want
 ,#+END_SRC
 
+** Setting ligatures for specific font or major mode
+#+begin_quote
+You need Emacs 28+ with (MacOS or Harfbuzz) for EmacsLisp in this section to work.
+#+end_quote
+
+As the [[https://github.com/mickeynp/ligature.el][README]] for ligature.el states, you can manipulate the ligatures that you
+want to enable, specific for your font, or specific for the major modes that you
+want to use.
+
+#+begin_src elisp
+(after! ligature
+  (ligature-set-ligatures '(haskell-mode clojure-mode) '(">>=")))
+
+;; Alternatively
+(set-ligatures! '(haskell-mode clojure-mode)
+  :font-ligatures '(">>="))
+#+end_src
+
+This call will:
+- overwrite all preceding calls to =ligature-set-ligatures= or =set-ligatures!=
+  for =haskell-mode= and =clojure-mode= specifically, but
+- keep the inheritance to ligatures set for all modes, or parent modes like =prog-mode=
+
+*** Overwriting all default ligatures
+If you want to "start from scratch" and get control over all ligatures that
+happen in all modes, you can use
+
+#+begin_src elisp
+;; Set all your custom ligatures for all prog-modes here
+;; This section is *out of* the after! block
+;; Example: only get ligatures for "==" and "===" in programming modes
+;; by default, and get only "www" in all buffers by default.
+(setq +ligatures-prog-mode-list '("==" "===")
+      +ligatures-all-modes-list '("www"))
+;; Set any of those variables to nil to wipe all defaults.
+
+;; All mode specific configuration go in the `after!' block
+(after! ligature
+  ;; Set all your additional custom ligatures for other major modes here.
+  ;; Example: enable traditional ligature support in eww-mode, if the
+  ;; `variable-pitch' face supports it
+  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi")))
+
+;; Alternatively
+(set-ligatures! 'eww-mode
+  :font-ligatures '("ff" "fi" "ffi"))
+#+end_src
+
 ,* TODO Troubleshooting
  If you have any problems with this module, do get in touch!
#+end_src
******* Autoload
#+begin_src diff
diff --git a/modules/ui/ligatures/autoload/ligatures.el b/modules/ui/ligatures/autoload/ligatures.el
index 7856ff7c1..06486a4ec 100644
--- a/modules/ui/ligatures/autoload/ligatures.el
+++ b/modules/ui/ligatures/autoload/ligatures.el
@@ -9,17 +9,24 @@
   "Associates string patterns with icons in certain major-modes.
 
   MODES is a major mode symbol or a list of them.
-  PLIST is a property list whose keys must match keys in
-`+ligatures-extra-symbols', and whose values are strings representing the text
-to be replaced with that symbol. If the car of PLIST is nil, then unset any
-pretty symbols previously defined for MODES.
+  PLIST is a property list whose keys must either:
 
-This function accepts one special property:
+  - match keys in
+`+ligatures-extra-symbols', and whose values are strings representing the text
+to be replaced with that symbol, or
+ - be one of two special properties:
 
   :alist ALIST
     Appends ALIST to `prettify-symbols-alist' literally, without mapping text to
     `+ligatures-extra-symbols'.
 
+  :font-ligatures LIST
+    Sets the list of strings that should get transformed by the font into ligatures,
+    like \"==\" or \"-->\". LIST is a list of strings.
+
+If the car of PLIST is nil, then unset any
+pretty symbols and ligatures previously defined for MODES.
+
 For example, the rule for emacs-lisp-mode is very simple:
 
   (set-ligatures! 'emacs-lisp-mode
@@ -30,18 +37,32 @@ assicated with :lambda in `+ligatures-extra-symbols'.
 
 Pretty symbols can be unset for emacs-lisp-mode with:
 
-  (set-ligatures! 'emacs-lisp-mode nil)"
+  (set-ligatures! 'emacs-lisp-mode nil)
+
+Note that this will keep all ligatures in `+ligatures-prog-mode-list' active, as
+`emacs-lisp-mode' is derived from `prog-mode'."
   (declare (indent defun))
   (if (null (car-safe plist))
       (dolist (mode (doom-enlist modes))
-        (delq! mode +ligatures-extra-alist 'assq))
-    (let (results)
+        (delq! mode +ligatures-extra-alist 'assq)
+        (add-to-list 'ligature-ignored-major-modes mode))
+    (let ((results)
+          (font-ligatures))
       (while plist
         (let ((key (pop plist)))
-          (if (eq key :alist)
-              (prependq! results (pop plist))
+          (cond
+           ((eq key :alist)
+            (prependq! results (pop plist)))
+           ((eq key :font-ligatures)
+            (setq font-ligatures (pop plist)))
+           (t
             (when-let (char (plist-get +ligatures-extra-symbols key))
-              (push (cons (pop plist) char) results)))))
+              (push (cons (pop plist) char) results))))))
+      (when font-ligatures
+        (with-eval-after-load 'ligature
+          (dolist (mode (doom-enlist modes))
+            (setq ligature-ignored-major-modes (delete mode ligature-ignored-major-modes)))
+          (ligature-set-ligatures (doom-enlist modes) font-ligatures)))
       (dolist (mode (doom-enlist modes))
         (setf (alist-get mode +ligatures-extra-alist)
               (if-let (old-results (alist-get mode +ligatures-extra-alist))
#+end_src
******* Config
#+begin_src diff
diff --git a/modules/ui/ligatures/config.el b/modules/ui/ligatures/config.el
index 484945ceb..3958aefbd 100644
--- a/modules/ui/ligatures/config.el
+++ b/modules/ui/ligatures/config.el
@@ -47,44 +47,25 @@ font.")
 (defvar +ligatures-extra-alist '((t))
   "A map of major modes to symbol lists (for `prettify-symbols-alist').")
 
-(defvar +ligatures-composition-alist
-  '((?!  . "\\(?:!\\(?:==\\|[!=]\\)\\)")                                      ; (regexp-opt '("!!" "!=" "!=="))
-    (?#  . "\\(?:#\\(?:###?\\|_(\\|[#(:=?[_{]\\)\\)")                         ; (regexp-opt '("##" "###" "####" "#(" "#:" "#=" "#?" "#[" "#_" "#_(" "#{"))
-    (?$  . "\\(?:\\$>>?\\)")                                                  ; (regexp-opt '("$>" "$>>"))
-    (?%  . "\\(?:%%%?\\)")                                                    ; (regexp-opt '("%%" "%%%"))
-    (?&  . "\\(?:&&&?\\)")                                                    ; (regexp-opt '("&&" "&&&"))
-    (?*  . "\\(?:\\*\\(?:\\*[*/]\\|[)*/>]\\)?\\)")                            ; (regexp-opt '("*" "**" "***" "**/" "*/" "*>" "*)"))
-    (?+  . "\\(?:\\+\\(?:\\+\\+\\|[+:>]\\)?\\)")                              ; (regexp-opt '("+" "++" "+++" "+>" "+:"))
-    (?-  . "\\(?:-\\(?:-\\(?:->\\|[>-]\\)\\|<[<-]\\|>[>-]\\|[:<>|}~-]\\)\\)") ; (regexp-opt '("--" "---" "-->" "--->" "->-" "-<" "-<-" "-<<" "->" "->>" "-}" "-~" "-:" "-|"))
-    (?.  . "\\(?:\\.\\(?:\\.[.<]\\|[.=>-]\\)\\)")                             ; (regexp-opt '(".-" ".." "..." "..<" ".=" ".>"))
-    (?/  . "\\(?:/\\(?:\\*\\*\\|//\\|==\\|[*/=>]\\)\\)")                      ; (regexp-opt '("/*" "/**" "//" "///" "/=" "/==" "/>"))
-    (?:  . "\\(?::\\(?:::\\|[+:<=>]\\)?\\)")                                  ; (regexp-opt '(":" "::" ":::" ":=" ":<" ":=" ":>" ":+"))
-    (?\; . ";;")                                                              ; (regexp-opt '(";;"))
-    (?0  . "0\\(?:\\(x[a-fA-F0-9]\\).?\\)") ; Tries to match the x in 0xDEADBEEF
-    ;; (?x . "x") ; Also tries to match the x in 0xDEADBEEF
-    ;; (regexp-opt '("<!--" "<$" "<$>" "<*" "<*>" "<**>" "<+" "<+>" "<-" "<--" "<---" "<->" "<-->" "<--->" "</" "</>" "<<" "<<-" "<<<" "<<=" "<=" "<=<" "<==" "<=>" "<===>" "<>" "<|" "<|>" "<~" "<~~" "<." "<.>" "<..>"))
-    (?<  . "\\(?:<\\(?:!--\\|\\$>\\|\\*\\(?:\\*?>\\)\\|\\+>\\|-\\(?:-\\(?:->\\|[>-]\\)\\|[>-]\\)\\|\\.\\(?:\\.?>\\)\\|/>\\|<[<=-]\\|=\\(?:==>\\|[<=>]\\)\\||>\\|~~\\|[$*+./<=>|~-]\\)\\)")
-    (?=  . "\\(?:=\\(?:/=\\|:=\\|<[<=]\\|=[=>]\\|>[=>]\\|[=>]\\)\\)")         ; (regexp-opt '("=/=" "=:=" "=<<" "==" "===" "==>" "=>" "=>>" "=>=" "=<="))
-    (?>  . "\\(?:>\\(?:->\\|=>\\|>[=>-]\\|[:=>-]\\)\\)")                      ; (regexp-opt '(">-" ">->" ">:" ">=" ">=>" ">>" ">>-" ">>=" ">>>"))
-    (??  . "\\(?:\\?[.:=?]\\)")                                               ; (regexp-opt '("??" "?." "?:" "?="))
-    (?\[ . "\\(?:\\[\\(?:|]\\|[]|]\\)\\)")                                    ; (regexp-opt '("[]" "[|]" "[|"))
-    (?\\ . "\\(?:\\\\\\\\[\\n]?\\)")                                          ; (regexp-opt '("\\\\" "\\\\\\" "\\\\n"))
-    (?^  . "\\(?:\\^==?\\)")                                                  ; (regexp-opt '("^=" "^=="))
-    (?w  . "\\(?:wwww?\\)")                                                   ; (regexp-opt '("www" "wwww"))
-    (?{  . "\\(?:{\\(?:|\\(?:|}\\|[|}]\\)\\|[|-]\\)\\)")                      ; (regexp-opt '("{-" "{|" "{||" "{|}" "{||}"))
-    (?|  . "\\(?:|\\(?:->\\|=>\\||=\\|[]=>|}-]\\)\\)")                        ; (regexp-opt '("|=" "|>" "||" "||=" "|->" "|=>" "|]" "|}" "|-"))
-    (?_  . "\\(?:_\\(?:|?_\\)\\)")                                            ; (regexp-opt '("_|_" "__"))
-    (?\( . "\\(?:(\\*\\)")                                                    ; (regexp-opt '("(*"))
-    (?~  . "\\(?:~\\(?:~>\\|[=>@~-]\\)\\)"))                                  ; (regexp-opt '("~-" "~=" "~>" "~@" "~~" "~~>"))
-  "An alist of all ligatures used by `+ligatures-extras-in-modes'.
-
-The car is the character ASCII number, cdr is a regex which will call
-`font-shape-gstring' when matched.
-
-Because of the underlying code in :ui ligatures module, the regex should match a
-string starting with the character contained in car.
-
-This variable is used only if you built Emacs with Harfbuzz on a version >= 28")
+(defvar +ligatures-prog-mode-list
+  '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
+    ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
+    "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
+    "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
+    "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
+    "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
+    "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
+    "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
+    ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
+    "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
+    "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
+    "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
+    "\\\\" "://")
+  "A list of ligatures to enable in all `prog-mode' buffers.")
+
+(defvar +ligatures-all-modes-list
+  '()
+  "A list of ligatures to enable in all buffers.")
 
 (defvar +ligatures-in-modes
   '(not special-mode comint-mode eshell-mode term-mode vterm-mode Info-mode
@@ -182,15 +163,19 @@ and cannot run in."
  ((and EMACS28+
        (or (featurep 'ns)
            (string-match-p "HARFBUZZ" system-configuration-features))
-       (featurep 'composite))  ; Emacs loads `composite' at startup
-  (defvar +ligature--composition-table (make-char-table nil))
+       (featurep 'composite))           ; Emacs loads `composite' at startup
+
+  (use-package! ligature
+    :config
+    ;; Enable all `+ligatures-prog-mode-list' ligatures in programming modes
+    (ligature-set-ligatures 'prog-mode +ligatures-prog-mode-list)
+    (ligature-set-ligatures 't +ligatures-all-modes-list))
+
   (add-hook! 'doom-init-ui-hook :append
-    (defun +ligature-init-composition-table-h ()
-      (dolist (char-regexp +ligatures-composition-alist)
-        (set-char-table-range
-         +ligature--composition-table
-         (car char-regexp) `([,(cdr char-regexp) 0 font-shape-gstring])))
-      (set-char-table-parent +ligature--composition-table composition-function-table))))
+    (defun +ligature-enable-globally-h ()
+      "Enables ligature checks globally in all buffers.
+You can also do it per mode with `ligature-mode'."
+      (global-ligature-mode t))))
 
  ;; Fallback ligature support for certain, patched fonts. Install them with
  ;; `+ligatures/install-patched-font'
#+end_src
******* Packages
#+begin_src diff :noweb yes
diff --git a/modules/ui/ligatures/packages.el b/modules/ui/ligatures/packages.el
new file mode 100644
index 000000000..c710f766c
--- /dev/null
+++ b/modules/ui/ligatures/packages.el
@@ -0,0 +1,<<ligature-package-num-lines(4)>> @@
+(when (and EMACS28+
+           (or (featurep 'ns)
+               (string-match-p "HARFBUZZ" system-configuration-features))
+           (featurep 'composite))
+  <<ligature-package>>)
#+end_src
******** ligature.el package :version:
:PROPERTIES:
:header-args+: :tangle no
:END:
#+name: ligature-package
#+begin_src elisp
(package! ligature
  :recipe (:host github
           :repo "mickeynp/ligature.el"
           :files ("*.el"))
  :pin "9357156a917a021a87b33ee391567a5d8e44794a")
#+end_src

#+name: ligature-package-num-lines
#+begin_src elisp :var initial=""
(let ((num-lines
       (-> (-second-item (org-babel-lob--src-info "ligature-package"))
           (split-string (rx "\n"))
           length)))
  (+ initial num-lines))
#+end_src
***** \
- TODO write a command that shows me the git diff like doom-upgrade does and use it in my eventual dotfiles upgrade script
  https://github.com/doomemacs/doomemacs/compare/fca8bd7f3fa697a91774c2ddedcd1a47cd7da01a...849672691dd5d1214d6c72167ae84c03e8d9c8e3
***** packaging doom WIP
Extremely WIP, basically just a scratchpad
****** first attempts
Had =:tangle (meta-in-dir "packaging-doom-wip-1.scm")=
#+begin_src scheme :tangle no
(define-module (ebullient home packaging-doom-wip)
  #:use-module (guix build-system trivial)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  ;; #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module (ebullient home packages emacs)
  #:use-module (ebullient home packages doom-emacs)
  )

;; (define doom-inputs
;;   (computed-file
;;    "doom-inputs"
;;    (with-imported-modules '((guix build utils))
;;      #~(begin
;;          (use-modules (guix build utils))
;;          (invoke (string-append #+doom-emacs:bin "/bin/doom") "help")
;;          (copy-file #$(local-file "nixpkgs-config.nix") #$output)
;;          ;; `emacs-substitute-sexps' might be useful here if my needs get more sophisticated.
;;          ;; (substitute* #$output
;;          ;;   (("(dunstctl|dunst)" all) (case (string->symbol all)
;;          ;;                               ((dunst) (string-append #$(file-append dunst "/bin/dunst")
;;          ;;                                                       " -config " #$(local-file "dunstrc")))
;;          ;;                               ((dunstctl) #$(file-append dunst "/bin/dunstctl"))))
;;          ;;   (("nm-applet") #$(file-append network-manager-applet "/bin/nm-applet"))
;;          ;;   (("pasystray") #$(file-append pasystray "/bin/pasystray"))
;;          ;;   (("redshift-gtk") (string-append #$redshift:gtk "/bin/redshift-gtk"))
;;          ;;   (("udiskie") #$(file-append udiskie "/bin/udiskie")))
;;          ))))


(define-public temp-doom-emacs
  (package
    (name "doom-emacs")
    (version "0")
    (source
     (local-file "/home/pharcosyle/projects/dotfiles/doom-emacs" #:recursive? #t))
    (build-system (@ (guix build-system copy) copy-build-system))
    (synopsis "")
    (description "")
    (home-page "")
    (license #f)))

(define-public doom-inputs
  (package
    (name "doom-inputs")
    (version "0")
    (source #f)
    (inputs
     (list emacs-29-pgtk+native-comp
           ;; doom-emacs
           temp-doom-emacs
           ;; (local-file "doom-private" #:recursive? #t)
           git
           ;; (local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/straight.el" #:recursive? #t)
           ;; (local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/use-package" #:recursive? #t)
           ))
    (build-system trivial-build-system)
    (arguments
     `(#:modules ((guix build utils))
       #:builder
       ,#~(begin
            (use-modules (guix build utils))
            (let ((doom-private #$(local-file "doom-private" #:recursive? #t))
                  (doom-local-dir (string-append #$output "/doom-local")))
              (mkdir-p doom-local-dir)

              ;; (mkdir-p (string-append #$output "/asdf"))
              ;; (with-output-to-file (string-append #$output "/asdf/asdf.txt")
              ;;   (lambda _
              ;;     (display "asdffffffffffff")))

              (setenv "PATH" (string-append (getenv "PATH")
                                            ":" (assoc-ref %build-inputs "emacs-29-pgtk+native-comp") "/bin"
                                            ":" (assoc-ref %build-inputs "git") "/bin"
                                            ))
              ;; (setenv "DOOMDIR" (assoc-ref %build-inputs "doom-private"))
              (setenv "DOOMDIR" doom-private)
              (setenv "DOOMLOCALDIR" doom-local-dir)

              ;; (chdir #$output)
              ;; (invoke "git" "clone" "https://github.com/dracula/gtk")

              ;; (display "hi!")
              ;; (display doom-private)
              ;; (display straight-el)

              (let ((repos-dir (string-append doom-local-dir "/straight/repos")))
                (mkdir-p repos-dir)
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/straight.el" #:recursive? #t)
                         (string-append repos-dir "/straight.el"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/use-package" #:recursive? #t)
                         (string-append repos-dir "/use-package"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/melpa" #:recursive? #t)
                         (string-append repos-dir "/melpa"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/gnu-elpa-mirror" #:recursive? #t)
                         (string-append repos-dir "/gnu-elpa-mirror"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/el-get" #:recursive? #t)
                         (string-append repos-dir "/el-get"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/emacsmirror-mirror" #:recursive? #t)
                         (string-append repos-dir "/emacsmirror-mirror")))

              (setenv "HOME" "/tmp/asdfasdf")
              (mkdir-p "/tmp/asdfasdf")

              ;; (symlink #$(local-file "/home/pharcosyle/projects/dotfiles/doom-emacs" #:recursive? #t)
              ;;            (string-append #$output "/temp-doom-emacs"))
              (let ((doom
                     ;; #$(local-file "/home/pharcosyle/projects/dotfiles/doom-emacs" #:recursive? #t)
                     (assoc-ref %build-inputs "doom-emacs")
                     ;; (string-append #$output "/temp-doom-emacs")
                     ))
                ;; (invoke (string-append #$(@ (gnu packages base) coreutils) "/bin/echo") "asdfasdfsdf")
                ;; (invoke (string-append doom "/bin/doom") "help")
                (invoke (string-append doom "/bin/doom") "install" "--no-config" "--no-env" "--no-fonts" "--no-hooks")
                )

              ;; (copy-file #$(local-file "nixpkgs-config.nix") #$output)
              )


            #t)))

    ;; (arguments
    ;;  `(;; #:install-plan
    ;;    ;; '(("." "share/doom-emacs/"))
    ;;    ;; #:tests? #t
    ;;    ;; #:test-command '("./bin/doom" "test")
    ;;    #:phases
    ;;    ,#~(modify-phases %standard-phases
    ;;         (add-after 'install 'symlink-bin
    ;;           (lambda _
    ;;             (mkdir #$output:bin)
    ;;             (symlink (string-append #$output "/bin")
    ;;                      (string-append #$output:bin "/bin")))))))

    (synopsis "")
    (description "")
    (home-page "")
    (license #f)))





(use-modules ((guix packages) #:select (content-hash content-hash-algorithm content-hash-value)))

(define doom-build
  (computed-file
   "doom-build"
   (with-imported-modules '((guix build utils))
     #~(begin
         (use-modules (guix build utils))

         ;; (mkdir-p #$output)

         (setenv "GIT_SSL_NO_VERIFY" "true") ; do ssl if it's easy. Also if I'm using `(guix build git) git-fetch' consider if it setting this variable leaks out.

         ;; (invoke (string-append #+doom-emacs:bin "/bin/doom") "help")
         ;; (copy-file #$(local-file "nixpkgs-config.nix") #$output)
         ;; (invoke (string-append #$(@ (gnu packages wget) wget) "/bin/wget") "--no-check-certificate" "https://xkcd.com/")
         ;; (copy-file "index.html" #$output)

         ;; TODO Consider making e.g. emacs, git not ungexped in a let but instead everywhere they're used (and move this let outside of the gexp). Then I could use file-append instead of string-append in places I guess. Which is better practice?
         (let ((doom-private #+(file-union "doom-private"
                                           `(("init.el" ,(file-append (local-file "/home/pharcosyle/projects/dotfiles/doom-emacs" #:recursive? #t)
                                                                      "/init.example.el"))
                                             ("config.el" ,(file-append (local-file "/home/pharcosyle/projects/dotfiles/doom-emacs" #:recursive? #t)
                                                                        "/core/templates/config.example.el"))
                                             ("packages.el" ,(file-append (local-file "/home/pharcosyle/projects/dotfiles/doom-emacs" #:recursive? #t)
                                                                          "/core/templates/packages.example.el")))))
               ;; (doom-private #$(local-file "doom-private" #:recursive? #t))
               (doom-local-dir (string-append #$output "/doom-local"))
               (emacs #+emacs-29-pgtk+native-comp)
               (git #+git)
               ;; (emacs (assoc-ref %build-inputs "emacs-29-pgtk+native-comp"))
               ;; (git (assoc-ref %build-inputs "git"))
               (doom-emacs #+temp-doom-emacs)
               ;; (doom-emacs #+doom-emacs)
               ;; (doom-emacs (assoc-ref %build-inputs "doom-emacs"))
               ;; (doom-emacs #$(local-file "/home/pharcosyle/projects/dotfiles/doom-emacs" #:recursive? #t))
               )
           (mkdir-p doom-local-dir)

           (setenv "PATH" (string-append (getenv "PATH")
                                         ":" emacs "/bin"
                                         ":" git "/bin"
                                         ":" #+(@ (gnu packages base) coreutils) "/bin" ; donno if this is necessary
                                         ":" #+(@ (gnu packages base) sed) "/bin"
                                         ))
           ;; Is this a better/cleaner way to do path-setting? Consider also the comment (from git-download.scm), should I add more stuff to the path?
           ;;
           ;; The 'git submodule' commands expects Coreutils, sed,
           ;; grep, etc. to be in $PATH.
           ;; (set-path-environment-variable "PATH" '("bin")
           ;;                                (match '#+inputs
           ;;                                  (((names dirs outputs ...) ...)
           ;;                                   dirs)))

           (setenv "DOOMDIR" doom-private)
           (setenv "DOOMLOCALDIR" doom-local-dir)

           ;; (chdir #$output)
           ;; (invoke "git" "clone" "https://github.com/dracula/gtk")

           ;; donno if this is necessary
           (setenv "HOME" "/tmp/asdfasdf")
           (mkdir-p "/tmp/asdfasdf")

           ;; temporary straight.el experimentation
           ;; (mkdir-p "/tmp/asdfasdf/123456")
           (mkdir-p (string-append doom-local-dir "/straight/repos"))
           (symlink #+(local-file "/home/pharcosyle/projects/dotfiles/straight.el" #:recursive? #t)
                    (string-append doom-local-dir "/straight/repos/straight.el"))

           ;; (copy-file #$(local-file "nixpkgs-config.nix") (string-append doom-local-dir "/asdf.txt"))
           ;; (invoke (string-append doom-emacs "/bin/doom") "help")
           (invoke (string-append doom-emacs "/bin/doom") "install" "--no-config" "--no-env" "--no-fonts" "--no-hooks")
           ;; (invoke (string-append doom-emacs "/bin/doom") "upgrade")
           ;; (invoke (string-append doom-emacs "/bin/doom") "build")
           ;; (invoke (string-append doom-emacs "/bin/doom") "sync")

           ;; (invoke (string-append emacs "/bin/emacs") "--batch" "--eval=\"(progn (load user-init-file) (straight-freeze-versions))\"")
           ;; (invoke (string-append emacs "/bin/emacs") "--batch" "--eval='(progn (message \"hello!\"))'")
           ;; (invoke "emacs" "--batch" "--eval='(message \"hello!\")'")
           ;; (chdir #$output)
           ;; (invoke "emacs" "--batch" "--eval='(with-temp-file \"asdf.txt\" (insert \"asdfasdf\"))'")
           ;; (invoke "emacs" "--batch" "--eval='(message \"hello!\")'")
           ;; (invoke "emacs" "--help")
           ;; (invoke "echo" (string-append (string-append emacs "/bin/emacs") "--batch" (string-append "--load=" doom-emacs "/init.el") "--eval=(progn (message \"hi\") (message \"yo\"))"))
           ;; (invoke (string-append emacs "/bin/emacs") "--batch" (string-append "--load=" doom-emacs "/init.el") "--eval=(progn (message \"hi\") (straight-freeze-versions) (message \"yo\"))")
           ;; (invoke "echo" "asdf")

           )))
   #:options (let ((ch (content-hash "1zcpkabkizadc3j9jqnnpyqm4d71bnvxz2x6as53f6wjwn82ahd9")))
               (list #:hash (content-hash-value ch)
                     #:hash-algo (content-hash-algorithm ch)
                     #:recursive? #t
                     ;; #:substitutable? #f ; This isn't appropriate, right?
                     ))))

;; (define-public doom-build-pkg
;;   (package
;;     (name "doom-build-pkg")
;;     (version "0")
;;     (source doom-build)
;;     (build-system (@ (guix build-system copy) copy-build-system))
;;     (synopsis "")
;;     (description "")
;;     (home-page "")
;;     (license #f)))
#+end_src
****** second attempt
Had =:tangle (meta-in-dir "packaging-wip-2.scm") :comments link=
#+begin_src scheme :tangle no
(define-module (ebullient home packaging-wip)
  ;; #:use-module (guix build-system trivial)
  ;; #:use-module (guix gexp)
  ;; #:use-module (guix git-download)
  ;; #:use-module (guix packages)
  ;; #:use-module ((guix licenses) #:prefix license:)
  ;; ;; #:use-module ((gnu packages emacs) #:select (emacs))
  ;; #:use-module ((gnu packages version-control) #:select (git))
  ;; #:use-module (ebullient home packages emacs)
  ;; #:use-module (ebullient home packages doom-emacs)

  #:use-module ((guix packages) #:select (package-input-rewriting))
  #:use-module ((gnu packages emacs) #:select (emacs emacs-minimal emacs-no-x emacs-next emacs-next-pgtk emacs-xwidgets emacs-no-x-toolkit emacs-wide-int))

  )
(define emacs-variant (@ (ebullient home packages emacs) emacs-29-pgtk+native-comp))

;; TODO does this rewrite recursively?
;; package-input-rewriting/spec says it specifically does this while package-input-rewriting does not. And what about using `package-mapping'? I can check the final product for references to emacs/emacs-minimal but still read over the source code of each later. What about native-inputs, sometimes emacs(-minimal) is in there.
;; TODO do I need to specify all of the different emacs packages for rewriting?
;; Does it work without doing this already? Would package-input-rewriting/spec handle them somehow? Does `package/inherit' (in both the -spec and non-spec versions)?
(define with-emacs-variant
  (package-input-rewriting `((,emacs . ,emacs-variant)
                             (,emacs-minimal . ,emacs-variant)
                             (,emacs-no-x . ,emacs-variant)

                             ;; TODO maybe ths should be in a nested `package-input-rewriting' or having packages with themselves as input rewrites
                             ;; will cause problems, I donno. Putting this here for now.
                             (,(@ (gnu packages emacs-xyz) emacs-dash) . ,(@ (ebullient home packages emacs-xyz) emacs-dash)))))

;; (define-public test-reftex
;;   (with-emacs-variant (@ (gnu packages emacs-xyz) emacs-company-reftex)))
;; (define-public test-dash-existing
;;   (with-emacs-variant (@ (gnu packages emacs-xyz) emacs-dash)))
;; (define-public test-dash
;;   (with-emacs-variant (@ (ebullient home packages emacs-xyz) emacs-dash)))

;; (define orig-pkg (@ (gnu packages emacs-xyz) emacs-build-farm))
;; (define orig-pkg (@ (gnu packages emacs-xyz) emacs-cider))
(define orig-pkg (@ (gnu packages emacs-xyz) emacs-buttercup))

(define-public test-pkg
  (with-emacs-variant orig-pkg))





(use-modules (guix packages)
             (guix git-download))

(define (git-origin url commit hash recursive?)
  (origin
    (method git-fetch)
    (uri (git-reference
          (url url)
          (commit commit)
          (recursive? recursive?)))
    (sha256
     (base32
      hash))))



(use-modules (gnu packages)
             (guix profiles)
             ;; ((srfi srfi-1) #:select (remove))
             ;; (ebullient utils)
             )

;; (define (doom-ps)
;;   (->> (call-with-input-file "../doom-packaging/guix-doom-emacs-packages-from-straight-build-cache.txt" read)
;;        (remove
;;         (lambda (dpns)
;;           (member dpns (list "donnager"

;;                              "straight"

;;                              ;; TODO built-in, ignoring for now but handle this when grabbing from ~doom-packages~. It marks them as ~:ignored t~
;;                              ;; - but what about built-in 'prefer, this isn't marked specially
;;                              "hideshow"
;;                              "vc"
;;                              "vc-annotate"
;;                              "smerge-mode"
;;                              "elisp-mode"
;;                              "css-mode"

;;                              "org-elpa"
;;                              "melpa"
;;                              "gnu-elpa-mirror"
;;                              "el-get"
;;                              "emacsmirror-mirror"
;;                              ))))))

(define (emacs-ps)
  (map (lambda (x)
         (string-append "emacs-" x))
       (doom-ps)))

;; (display
;;  (map (lambda (x)
;;         (find-best-packages-by-name x #f))
;;       (emacs-ps)))

;; (display
;;  (->> (emacs-ps)
;;       (map (lambda (x)
;;              (let ((found (find-best-packages-by-name x #f)))
;;                (if (null? found)
;;                  x '()))))
;;       (remove null?)))

(use-modules (gnu packages emacs-xyz)
             (ebullient home packages emacs-xyz)
             ;; (ebullient home packages emacs-xyz-batch)
             )

(define (str->pkg x)
  (primitive-eval
   (string->symbol
    (if (equal? "emacs-git-modes" x)
        "git-modes"
        x))))

;; (let ((the-manifest
;;        (packages->manifest
;;         (map str->pkg (emacs-ps)))))
;;   ;; (display the-manifest)
;;   #f)






(use-modules ((guix base32) #:select (bytevector->nix-base32-string))
             ((guix build git) #:select (git-fetch) #:prefix other:)
             (guix build utils)
             ((guix hash) #:select (file-hash*)))

(define* (git-checkout-hash url commit #:key recursive?)
  (let ((dir (string-append "/tmp" "/8888")))
    (when (file-exists? dir)
      (delete-file-recursively dir))
    (if (other:git-fetch url commit dir
                         #:recursive? recursive?
                         ;; #:git-command (string-append #+git "/bin/git")
                         )
        (let ((hash (bytevector->nix-base32-string (file-hash* dir))))
          (delete-file-recursively dir)
          hash)
        #f)))


(define (test-get-hash)
  (display
   (git-checkout-hash
    "https://github.com/emacs-evil/evil-surround"
    "282a975bda83310d20a2c536ac3cf95d2bf188a5"
    #:recursive? #t)))

;; (test-get-hash)


(define* (find-hash doom-pkg p commit #:key recursive?)
  (let ((hasher (lambda (url)
                  (git-checkout-hash url commit #:recursive? recursive?))))
    (as-> hasher $
          ($ (if (eq? (-> p package-source origin-method) git-fetch)
                 (-> p
                     package-source
                     origin-uri
                     git-reference-url)
                 (string-append "https://github.com/emacs-straight/" doom-pkg)))
          (if $ $ "NONE_FOUND"))))

;; TODO later: maybe don't look for hashes if the requested commit is already in the Guix package
;; - and maybe if the hashes turn out to be the same after doing `git-checkout-hash', presumably
;; because the Guix package had a git tag or something but it ended up being the same as the
;; Doom-requested commit, don't save the hash? Meh.
;; TODO maybe don't write out the hashes file
;; Just cache the results somehow in the guix store so hash generation can be run as-needed
(define (hashes ps)
  (let ((commits (call-with-input-file "../doom-packaging/straight-commits.txt" read)))
    (map
     (lambda (doom-pkg)
       (let* ((p (str->pkg (string-append "emacs-" doom-pkg)))
              (commit (assoc-ref commits doom-pkg))
              (hash (find-hash doom-pkg p commit #:recursive? #t)))
         (kvm #:package doom-pkg
              #:commit commit
              #:hash hash)))
     ps)))

(define (spit f content)
  (call-with-output-file f
    (lambda (port)
      (write content port))))

;; (define write-hashes (partial spit "../doom-packaging/hashes.txt"))

;; (write-hashes
;;  (hashes (list "restart-emacs" "smartparens")))
;; (write-hashes (doom-ps))
#+end_src
****** active WIP
******* clojure part
******** clj file
I had =:tangle ebullient/src/protostar/hickeyland.clj :comments link= for the source block options here.
#+begin_src clojure :tangle no
(ns protostar.hickeyland
  (:require [clojure.alpha.spec :as s]
            [clojure.edn :as edn]
            [clojure.java.io :as io]
            [clojure.string :as str]))

;; TODO At end: just maybe try doing this, slurp, any anything else impure as some sort of "coeffects"
(defn- file-exists? [f]
  (.exists (io/file f)))


(s/defop nospec [_]
  any?)



(s/def ::str->edn (s/conformer edn/read-string)) ; TODO donno if I want to use this or just do it in clojure code (is that more idiomatic then writing a spec/conformer for everything?)


(s/def :char/blank #{\space \tab})
;; (s/def :char/newline #{\newline}) ; TODO remvoe if not needed

(s/def ::text->lines (s/conformer str/split-lines)) ; TODO donno if I want to use this or just do it in clojure code (is that more idiomatic then writing a spec/conformer for everything?)

(s/def ::str->chars (s/conformer seq))
(s/def ::chars->str (s/conformer (partial apply str)))



;; TODO would this be better / more flexible if I made it check validity (`valid?`) and then did conforming in a separate step?
;; TODO s/defop works currently but might not be the idiomatic way to do this
(s/defop s-filter [spec]
  (s/conformer
   (fn [xs]
     (keep (fn [x]
             (let [conformed (s/conform spec x)]
               (when-not (s/invalid? conformed)
                 conformed)))
           xs))))


(s/def :elisp/form any?)
(s/def :elisp/t #{t})
(s/def :elisp/list->car (s/conformer first)) ; TODO remove if not needed
(s/def :elisp/list->cdr (s/conformer next)) ; TODO remove if not needed
(s/def :elisp/plist->map (s/conformer (partial apply hash-map))) ; TODO remove if not needed
(s/def :elisp/nil-or-non-nil :elisp/form) ; TODO think this (perhaps just the name) through more?


(s/def :epkg.dep/name symbol?)
(s/def :epkg.dep/version (nospec string?))
(s/def :epkg.dep/name+ver (s/cat :name :epkg.dep/name
                                 :_version (s/? (nospec :epkg.dep/version))))
(s/def :epkg.dep/name+ver->name
  (s/conformer (fn [[form x]]
                 (case form
                   :name x
                   :name+ver (:name x)))))
(s/def :epkg/dep (s/or :name :epkg.dep/name
                       :name+ver :epkg.dep/name+ver))

(s/def :epkg/deps (s/coll-of :epkg/dep))
(s/def :epkg/deps->name-strs
  (s/coll-of (s/and
              :epkg.dep/name+ver->name
              (s/conformer str))))

;; Testing
;; (def test-deps '((emacs "24.1") another (seq) (cl-lib "0.5")))
;; (s/valid? :epkg/deps test-deps)
;; (s/explain-str :epkg/deps test-deps)
;; (s/conform :epkg/deps test-deps)
;; (s/conform
;;  (s/and
;;   :epkg/deps
;;   :epkg/deps->name-strs)
;;  test-deps)

;; TODO ideally do this better / more flexibly / maybe faster
(s/def :epkg.simple/req-header-name
  (s/&
   (s/+ char?)
   ::chars->str
   #(= "Package-Requires:" %))) ; TODO (if keeping things this way) could this just be a literal set predicate?

(s/def :epkg.simple/req-header-line
  (s/and
   ::str->chars
   (s/cat :_comment (s/&
                     (s/+ #{\;})
                     ::chars->str)
          :_ws (s/&
                (s/* :char/blank)
                ::chars->str)
          :_req-header :epkg.simple/req-header
          :_ws2 (s/&
                 (s/* :char/blank)
                 ::chars->str)
          :deps (s/&
                 (s/* char?)
                 ::chars->str
                 ::str->edn
                 :epkg/deps))))

(s/def :epkg.simple/reqs
  (s/and
   ::text->lines
   (s-filter :epkg.simple/req-header-line)
   ;; TODO spec that there should be exactly :count 1?
   (s/conformer first)
   ;; TODO what was I trying here?
   ;; (s/conformer (fn [xs]
   ;;                (or (first xs) :clojure.alpha.spec/invalid)))
   ))

;; Testing
;; (def test-pkgrequires-line ";; Package-Requires: ((emacs \"24.1\") (cl-lib \"0.5\"))")
;; (s/conform :epkg.simple/reqs (str "asdf\n" test-pkgrequires-line))
;; (s/explain-str :epkg.simple/reqs test-pkgrequires-line)

(s/def :epkg.multifile/reqs
  (s/cat :_define-package #{define-package}
         :_name (nospec string?)
         :_version (nospec :epkg.dep/version)
         :_docstring (s/? (nospec string?))
         :requirements (s/? (s/cat
                             :quote #(= (symbol (str \')) %) ; "Artifact" of `edn/read-string`.
                             :form :epkg/deps))
         :_extra (s/* (nospec nil))))

;; Testing
;; (s/conform :epkg.multifile/reqs {:pname "magit" :dir "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp"})
;; (s/conform :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp/magit-pkg.el")))
;; (s/explain-str :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp/magit-pkg.el")))
;; (s/conform :epkg.multifile/reqs "asdf")
;; (s/conform :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/drag-stuff.el/drag-stuff-pkg.el")))

;; TODO Might not need to test if file-exists for simple packages, is there always a packagename.el file? Or should always be one if there's no -pkg.el so its find to have it as a fallthrough case?
;; TODO maybe do coeffects if it's easy
;; Maybe see my now-deleted cofx attempts
(s/def :epkg/reqs->deps
  (s/or :multifile
        (s/and
         (s/conformer
          (fn [{:keys [pname dir]}]
            (let [f (str dir "/" pname "-pkg.el")]
              (if (file-exists? f)
                (-> f slurp edn/read-string)
                :clojure.alpha.spec/invalid))))
         :epkg.multifile/reqs
         (s/conformer #(get-in % [:requirements :form])))
        :simple
        (s/and
         (s/conformer
          (fn [{:keys [pname dir]}]
            (let [f (str dir "/" pname ".el")]
              (if (file-exists? f)
                (-> f slurp edn/read-string)
                :clojure.alpha.spec/invalid))))
         :epkg.simple/reqs
         (s/conformer :deps))))

(defn epkg-dependencies [name dir]
  (let [deps
        (s/conform
         (s/and
          :epkg/reqs->deps
          (s/conformer (fn [[_ reqs]] reqs))
          :epkg/deps->name-strs)
         {:pname name :dir dir})]
    (when-not (s/invalid? deps)
      deps)))

;; Testing
;; (epkg-dependencies "magit" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp")
;; (println (epkg-dependencies "dash" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/dash"))
;; (println (epkg-dependencies "helpful" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/helpful"))
;; (println (epkg-dependencies "evil" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/evil"))
;; (println (epkg-dependencies "drag-stuff" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/drag-stuff.el"))
;; (println (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/evil/evil-pkg.el"))




(s/def ::forge-repo
  (s/and
   ::str->chars
   (s/cat :user-name (s/&
                      (s/+ char?)
                      ::chars->str)
          :slash #{\/}
          :repo-name (s/&
                      (s/+ char?)
                      ::chars->str))))

(s/def ::glob string?)

(s/def ::recipe-subdirective
  (s/alt :subdir string?
         :exclude #{:exclude}))

(s/def ::recipe-defaults #{:defaults})




; TODO better sha and ref specs
(s/def :git/sha string?)
(s/def :git/ref string?)

(s/def :melpa.recipe.files/element
  (s/alt :glob ::glob
         :sublist (s/nest
                   (s/cat :subdirective ::recipe-subdirective
                          :elements (s/+ :melpa.recipe.files/element)))))
(s/def :melpa.recipe/files
  (s/cat
   :defaults (s/? ::recipe-defaults)
   :elements (s/* :melpa.recipe.files/element)))

(s/def :melpa.recipe/name symbol?)
(s/def :melpa.recipe/fetcher #{git hg github gitlab})
(s/def :melpa.recipe.vc/url string?)
(s/def :melpa.recipe.forge/repo ::forge-repo)
;; TODO nb: "commit" is used only once in all of the melpa recipes. Do doom/straight even consider it?
(s/def :melpa.recipe.git/commit (s/or :git/sha
                                      :git/ref))
(s/def :melpa.recipe.git/branch string?) ; TODO do better spec? It can be a git or hg branch, right?
;; -- originial position of :melpa.recipe/files before I moved it up --
;; TODO nb: ignoring :version-regexp and :old-names, I don't care about them, right (straight doesn't seem to)? And I'm excluding from even this validation spec stuff I don't care about, right? Or just maybe spec them but do a `s/select` that doesn't include them (or use `nospec`)? Remember to add them to :melpa.recipe/schema.

(s/def :melpa.recipe/props
  (s/schema {;; :melpa.recipe/name
             :fetcher :melpa.recipe/fetcher
             :files :melpa.recipe/files}))

(s/def :melpa.recipe/vc-props
  (s/schema {:url :melpa.recipe.vc/url}))

(s/def :melpa.recipe/forge-props
  (s/schema {:repo :melpa.recipe.forge/repo}))

(s/def :melpa.recipe/git-props
  (s/schema {:commit :melpa.recipe.git/commit
             :branch :melpa.recipe.git/branch}))

(defmulti melpa-recipe-fetcher :fetcher)

(defmethod melpa-recipe-fetcher 'git [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/vc-props
            :melpa.recipe/git-props)
   [:url]))
(defmethod melpa-recipe-fetcher 'hg [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/vc-props)
   [:url]))
(defmethod melpa-recipe-fetcher 'github [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/forge-props
            :melpa.recipe/git-props)
   [:repo]))
(defmethod melpa-recipe-fetcher 'gitlab [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/forge-props
            :melpa.recipe/git-props)
   [:repo]))

(s/def :melpa/recipe
  (s/cat
   :name (nospec :melpa.recipe/name)
   :props
   (s/&
    (s/* :elisp/form)
    #(even? (count %))
    :elisp/plist->map
    (s/multi-spec melpa-recipe-fetcher :fetcher))))

;; Testing
;; (def test-melpa-recipe '(yasnippet :repo "joaotavora/yasnippet"
;;                                    :fetcher github
;;                                    :files ("yasnippet.el" "snippets")))
;; (s/conform :melpa/recipe test-melpa-recipe)
;; (s/explain-str :melpa/recipe test-melpa-recipe)



(s/def :straight.recipe-repo/name symbol?)

(s/def :straight.recipe/name symbol?) ; Maybe spec this so I can accept the argument to `straight-use-package` (for other users who use straight): doom doesn't take this just the rest of the recipe plist. Update: also need it for :includes.
(s/def :straight.recipe/local-repo string?)
;; TODO maybe some of the sub-stuff in :straight.recipe/files should be `nospec` or have leading keywork underscores.
(s/def :straight.recipe/files
  (s/*
   (s/alt :glob ::glob
          :pair (s/cat :car string?
                       :dot #{.}
                       :cdr string?)
          :sublist (s/nest
                    (s/cat :subdirective ::recipe-subdirective
                           :elements (s/+ :straight.recipe/files)))
          :defaults ::recipe-defaults)))
(s/def :straight.recipe/flavor #{melpa})
(s/def :straight.recipe/build any?) ; TODO. Had #{nil t}, it would be better to use :elisp/t but set specs take literal, not spec, values
(s/def :straight.recipe/pre-build any?) ; TODO
(s/def :straight.recipe/post-build any?) ; TODO
(s/def :straight.recipe/type #{git built-in})
(s/def :straight.recipe/source (s/or :one :straight.recipe-repo/name
                                     :many (s/coll-of :straight.recipe-repo/name)))
(s/def :straight.recipe/includes (s/or :one :straight.recipe/name
                                       :many (s/coll-of :straight.recipe/name)))
(s/def :straight.recipe/inherit :elisp/nil-or-non-nil)
(s/def :straight.recipe.git/host #{nil github gitlab bitbucket})
(s/def :straight.recipe.git/branch string?)
(s/def :straight.recipe.git/remote string?)
(s/def :straight.recipe.git/nonrecursive :elisp/nil-or-non-nil)
(s/def :straight.recipe.git/fork any?) ; TODO
(s/def :straight.recipe.git/depth (s/or :full #{full}
                                        :n integer?))
(s/def :straight.recipe.git/protocol #{https ssh})
(s/def :straight.recipe.git/upstream any?) ; TODO


(s/def :straight.recipe/props
  (s/schema {;; :straight.recipe/name
             :local-repo :straight.recipe/local-repo
             :files :straight.recipe/files
             :flavor :straight.recipe/flavor
             :build :straight.recipe/build
             :pre-build :straight.recipe/pre-build
             :post-build :straight.recipe/post-build
             :type :straight.recipe/type
             :source :straight.recipe/source
             :includes :straight.recipe/includes
             :inherit :straight.recipe/inherit}))

(s/def :straight.recipe/git-props
  (s/schema {;; :repo :straight.recipe.git/repo
             :host :straight.recipe.git/host
             :branch :straight.recipe.git/branch
             :remote :straight.recipe.git/remote
             :nonrecursive :straight.recipe.git/nonrecursive
             :fork :straight.recipe.git/fork
             :depth :straight.recipe.git/depth
             :protocol :straight.recipe.git/protocol
             :upstream :straight.recipe.git/upstream}))


(s/def :straight/repository-url string?)

(defmulti straight-recipe-git-host :host)

(defmethod straight-recipe-git-host nil [_]
  (s/select {:repo :straight/repository-url} [:repo]))
(defmethod straight-recipe-git-host 'github [_]
  (s/select {:repo ::forge-repo} [:repo]))
(defmethod straight-recipe-git-host 'gitlab [_]
  (s/select {:repo ::forge-repo} [:repo]))
(defmethod straight-recipe-git-host 'bitbucket [_]
  (s/select {:repo ::forge-repo} [:repo]))


(def straight-default-vc 'git)

(defmulti straight-recipe-type #(get % :type straight-default-vc))

(defmethod straight-recipe-type 'git [_]
  (s/and
   (s/union :straight.recipe/props
            :straight.recipe/git-props)
   (s/multi-spec straight-recipe-git-host :host)))
(defmethod straight-recipe-type 'built-in [_]
  (s/schema {}))


(s/def :straight.recipe/props-asdf
  (s/&
   (s/* :elisp/form)
   #(even? (count %))
   :elisp/plist->map
   (s/multi-spec straight-recipe-type :type)))

;; TODO I don't think I need this for anything
(s/def :straight/recipe
  (s/cat
   :name (nospec :straight.recipe/name)
   :props :straight.recipe/props-asdf))


(s/def :doom.package/name symbol?)
(s/def :doom.package/type #{core local built-in virtual}) ; Depending on where I'm doing "checking for stuff I explicitly don't support" either remove local/built-in/(maybe)virtual here or check for them elsewhere
(s/def :doom.package/recipe :straight.recipe/props-asdf)
(s/def :doom.package/disable :elisp/t)
(s/def :doom.package/ignore :elisp/t)
(s/def :doom.package/pin :git/sha)
;; TODO nb: not speccing :modules (for now?)

(s/def :doom.package/props
  (s/schema {:type :doom.package/type
             :recipe :doom.package/recipe
             :disable :doom.package/disable
             :ignore :doom.package/ignore
             :pin :doom.package/pin}))

(s/def :doom/package
  (s/cat
   :name :doom.package/name
   :props
   (s/&
    (s/* :elisp/form)
    #(even? (count %))
    :elisp/plist->map
    :doom.package/props)))


#_(defn parse-doom-packages []
  (as-> (slurp "/home/pharcosyle/projects/phrenetic/doom-packaging/my-doom-packages.el") $
    (edn/read-string $)
    (map parse-doom-package $)
    ;; TODO later: this is Doom-specific, move it out of the main "guix-emacs-generator"
    (remove #(= (:package/name %) "straight") $)
    (remove :package/deactivated? $)))



(s/def ::todo any?)

;; (s/def :fex.repo/user-name ::todo)
;; (s/def :fex.repo/repo-name ::todo)
;; (s/def :fex/repo
;;   (s/schema [:fex.repo/user-name
;;              :fex.repo/repo-name]))

(s/def :fex.package/url ::todo)
;; (s/def :fex.package/forge #{:forge/github
;;                             :forge/gitlab
;;                             ;; :forge/bitbucket
;;                             })
;; (s/def :fex.package.forge/repo :fex/repo) ; TODO maybe just use :fex/repo or ::forge-repo (and make the current ::forge-repo be ::forge-repo-str or something)
(s/def :fex.package/branch ::todo)
(s/def :fex.package/nonrecursive? #{true})
(s/def :fex.package/files :melpa.recipe/files) ; TODO This is "inheritance", maybe make this a "shared" spec like ::recipe-defaults or just allow :melpa.recipe/files as a key in :fex/package (maybe even rename it to ::melpa-style-files or something)

(s/def :fex/package
  (s/schema [:fex.package/url
             ;; :fex.package/forge
             ;; :fex.package.forge/repo
             :fex.package/branch
             :fex.package/nonrecursive?
             :fex.package/files]))





(def ^:private forge-domains
  {'github "github.com"
   'gitlab "gitlab.com"
   'bitbucket "bitbucket.com"})

(defn forge-repo-url [forge user-name repo-name]
  (str "https://" (get forge-domains forge) "/" user-name "/" repo-name ".git"))


(require '[clojure.set :refer [rename-keys]])
(defn select-and-rename-keys [m kmap]
  (as-> m $
    (select-keys $ (keys kmap))
    (rename-keys $ kmap)))






(defmacro defkmultis [& methods]
  (let [create (fn [name]
                 `(defmulti ~name ~(fn [k & _] k)))]
    `(do
       ~@(map create methods))))

(defmacro defkmethods [k & methods]
  (let [register
        (fn [[name argslist & body]]
          `(defmethod ~name ~k ~(vec (cons '_ argslist)) ~@body))]
    `(do
       ~@(map register methods))))





;; Archives
(defkmultis
  ;; has-recipe
  get-recipe) ; TODO maybe rename this get-package or something, I'm returning fex packages, not straight/melpa recipes


(defn gnu-elpa-mirror-recipe-filename [p]
  (str "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/gnu-elpa-mirror" "/" p))

(defkmethods
  :archive/gnu-elpa-mirror
  (get-recipe [p] (let [f (gnu-elpa-mirror-recipe-filename p)]
                    ;; TODO straight checks against straight-recipes-gnu-elpa-ignored-packages for this archive, I might need to do that too. There are other notes on this already.
                    (when (file-exists? f)
                      {:fex.package/url (forge-repo-url
                                         (symbol :github) "emacs-straight" p)
                       :fex.package/files {:elements [[:glob "*"]]}})))) ; TODO straight also has ~(:exclude ".git")~ here but I don't think I need that.

(defn melpa-recipe-filename [p]
  (str "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/melpa/recipes" "/" p))

(defkmethods
  :archive/melpa
  ;; (has-recipe [p] (file-exists? (melpa-recipe-filename p)))
  (get-recipe [p] (let [f (melpa-recipe-filename p)]
                    (when (file-exists? f)
                      (let [text (slurp f)
                            parsed
                            (s/conform (s/and
                                        ::str->edn
                                        :melpa/recipe
                                        (s/conformer :props))
                                       text)]
                        ;; TODO check that `parsed` is not invalid?
                        ;; TODO "supported"-ness: this might be the place to check that the melpa recipe fetcher isn't 'hg. Alternatively, or perhaps preferably (it would match straight's behavior) just report there's no package if the fetcher is 'hg (or isn't 'git, 'github, or 'gitlab)
                        ;; TODO additional things straight does for this archive: adds -pkg.el to :files and sets flavor to melpa. Donno if I need these. There are other todos/notes on these already
                        (merge
                         {:fex.package/url (let [fetcher (:fetcher parsed)]
                                             (condp some #{fetcher}
                                               #{'git} (:url parsed)
                                               #{'github 'gitlab} (let [repo (:repo parsed)]
                                                                    (forge-repo-url
                                                                     fetcher
                                                                     (:user-name repo)
                                                                     (:repo-name repo)))))}
                         (select-and-rename-keys
                          parsed {:branch :fex.package/branch
                                  :files :fex.package/files})
                         ;; TODO not using, remove
                         ;; (when-let [files (:files parsed)]
                         ;;   {:fex.package/files (s/unform :melpa.recipe/files files)})
                         ))))))

;; Testing
;; (get-recipe :archive/melpa "yasnippet")

;; TODO I don't think the lisp/* bits are necessary since these already have :defaults but for now I've copied the :files over just like they are in straight.
(defkmethods
  :archive/org-elpa
  (get-recipe [p] (case p
                    "org"
                    {:fex.package/url "https://git.savannah.gnu.org/git/emacs/org-mode.git"
                     :fex.package/files {:defaults :defaults
                                         :elements [[:glob "lisp/*.el"]
                                                    [:sublist
                                                     {:subdirective [:subdir "etc/styles/"]
                                                      :elements [[:glob "etc/styles/*"]]}]]}}
                    "org-contrib"
                    {:fex.package/url "https://git.sr.ht/~bzg/org-contrib"
                     :fex.package/files {:defaults :defaults
                                         :elements [[:glob "lisp/*.el"]]}}
                    nil)))


;; TODO make this configurable (of course) and probably not global (pass it as an argument to functions that use it)
(def archives [:archive/org-elpa
               :archive/melpa
               :archive/gnu-elpa-mirror])

;; TODO probably add emacsmirror, etc archives but make all of the methods throw an exception stating that they're not implemented "yet".
;; (def archive-priority [:archive/org-elpa
;;                        :archive/melpa
;;                        :archive/gnu-elpa-mirror])

;; TODO maybe a way to get these from Doom programatically is to advise `straight-use-recipes` but then I'd have to run `doom--ensure-straight` as well
;; (def doom-recipe-repos
;;   '((org-elpa :local-repo nil)
;;     (melpa              :type git :host github
;;                         :repo "melpa/melpa"
;;                         :build nil)
;;     (gnu-elpa-mirror    :type git :host github
;;                         :repo "emacs-straight/gnu-elpa-mirror"
;;                         :build nil)
;;     (el-get             :type git :host github
;;                         :repo "dimitri/el-get"
;;                         :build nil)
;;     (emacsmirror-mirror :type git :host github
;;                         :repo "emacs-straight/emacsmirror-mirror"
;;                         :build nil)))
;; (def doom-straight-recipe-repositories
;;   '(org-elpa melpa gnu-elpa-mirror el-get emacsmirror-mirror))




(require '[clojure.java.shell :refer [sh]])
(def eb-dir "/home/pharcosyle/projects/phrenetic/ebullient")
(def guix-repl-cmd ["guix" "repl" "-L" "." "--" "ebullient/home/packaging-runner.scm"])
(defn sh-call [f & args]
  (apply sh (concat guix-repl-cmd
                    [(name f)]
                    (map pr-str args)
                    [:dir eb-dir])))
;; (sh-call :guix/asdf 6)
(def get-origin-data (partial sh-call :guix/get-origin-data))







(defn get-archive-package [archives package-name]
  (first (map #(get-recipe % package-name) archives)))

(defn package-with-inheritance [package-name package]
  (merge
   (get-archive-package package-name)
   package))






(defn convert-straight-recipe-props-to-package [props]
  (let [; parsed (s/conform :straight.recipe/props-asdf props)
        parsed props]
    ;; TODO check that `parsed` is not invalid?
    ;; TODO "supported"-ness: is this the place to check that there aren't unsupported keys and provided keys have supported values (including that the :files is a valid /melpa/ :files)?
    (merge
     {:fex.package/url
      (let [{:keys [host repo]} parsed]
        (if host
          (forge-repo-url
           host
           (:user-name repo)
           (:repo-name repo))
          repo))}
     (select-and-rename-keys
      parsed {:branch :fex.package/branch})
     (when (:nonrecursive parsed)
       {:fex.package/nonrecursive? true})
     (when-let [files (:files parsed)]
       ;; TODO donno why I want to do it this convoluted way, maybe because I don't want to use the "raw" props?
       {:fex.package/files
        ;; (s/conform :melpa.recipe/files props)
        (->> files
             (s/unform :straight.recipe/files)
             (s/conform :melpa.recipe/files))}))))




;; (def my-doom-packages-test "/home/pharcosyle/projects/phrenetic/doom-packaging/my-doom-packages.el")
;; (def my-doom-packages-test "/home/pharcosyle/projects/phrenetic/doom-packaging/my-doom-packages-edited.el")
(def my-doom-packages-test "/home/pharcosyle/projects/phrenetic/doom-packaging/my-doom-packages-small.el")

(defn test-packages []
  (let [data (-> my-doom-packages-test
                 slurp
                 edn/read-string)
        conformed (s/conform (s/coll-of :doom/package) data)]
    ;; (s/explain (s/coll-of :doom/package) data)
    (as-> conformed $
      (map #(get-in % [:props :recipe]) $)
      (map convert-straight-recipe-props-to-package $))))

;; (test-packages)





(def straight-allow-recipe-inheritance? true)

;; TODO Ideally I think I want to grab any pertinent straight settings from Doom Emacs
;; By serializing them "in the same run" as when I grab e.g `doom-packages`. Update: but wait I won't have straight installed when I do this, perhaps scrape the straight code for sexps or maybe it'll be enough to just get the ones that Doom sets itself (see core-packages.el line 78-97)
;; - default protocol, allow inheritance, the recipe repos Doom sets up, etc
;; - straight-default-vc
;; - look through straight's ~defcustom~s
(def defaults {:recipe/protocol "https"})
;; maybe?:
;; :files '("*.el" "*.el.in" "dir"
;;          "*.info" "*.texi" "*.texinfo"
;;          "doc/dir" "doc/*.info" "doc/*.texi" "doc/*.texinfo" "lisp/*.el"
;;          (:exclude ".dir-locals.el" "test.el" "tests.el" "*-test.el" "*-tests.el")

;; TODO regarding :flavor: read `straight-expand-files-directive' and see if I need this / what I should do about :files. Also read the melpa readme about the rules it has for expanding its :files property
;; - :melpa/recipe shouldn't have a flavor, right? Just straight recipes?
;; - new thoughts
;;   - I might need it to make sure template files are copied over "before build", does that make sense I can't be fucked to think through the ordering at present
;;   - If I do need to consider .el.in files perhaps I can prepreocess the :fex.package/files returned from the melpa archive (but that might not be feasable, the .el.in logic is deep in the melpa/straight files expansion logic)
;;   - The Guix elpa importer doesn't even consider .el.in files, maybe they're super rare
;;   - nb: straight recipe inheritance logic includes :flavor and I'm not presently doing that
;;   - reconcile the Guix elpa importer's file expansion logc with melpa's to make sure it's thorough (not straight's, it's different, but do look it over afterwards anyway)
;; TODO downloading to a cache like the elpa importer does would speed up successive/reattempted runs, no?
;; - assuming that is what it's doing (check). Do those repo caches stick around forever though? Will adding my own interfere with anything?
;; - if it's /really/ fast maybe I could get rid of the later-to-come bump "scripts"'s need to read an existing list of generated packges at all! I wouldn't even have to save it to disk, just the lockfile!
;;   - even if the guix git repositories cache thing is untenable maybe there's some other cache I could write the repos or the generated packages-with-hashes to, even just ~./cache. I'd like to not have to manage a generated packages file if I don't have to
;; TODO handle :host: search "bitbucket" in straight to see stuff that affects hosts. If necessary add a check to make sure a supported host is provided.
;; TODO use value of `straight-built-in-pseudo-packages' (let-alist emacs nadvice python) in addition to elpa.scm's `emacs-standard-library?'? What about `straight-recipes-gnu-elpa-ignored-packages'? What about straight--package-built-in-p and package--builtins (read its doc)?
;; - Straight claims to be able to "deal with built-in packages" even without this variable. How? Something like hlissner does when :built-in is set to 'prefer? Use one
;;   of these approaches instead of making a (brittle) list of built-in pseudo packages?
;; - Remember, sometimes even if a package is built-in it should still be installed (like org)
;; - unrelated: are there any built-in dependencies with newer upstream/external versions? Do I want them?
;;   Perhaps not even proper versions just newer commits in a git repo
;; TODO always include *pkg.el like straight.el::3168 says?
;; Is that just about making sure that dependencies get resolved? It says "linked over" though. But then why wouldn't the other `straight-recipes-REPO-retrieve' methods have it? For
;; the elpa one at least it could be because it includes everything (=:files "*"=)
;; - also see the github melpa readme: "For multi-file packages, the file <NAME>-pkg.el is automatically generated..."
;; - update: shit is the /built/ package (after the :files directive has been "applied", among other things) used for determining dependencies? That's the way straight does it, I was just going to use the "raw" cloned repo to find dependencies. Note that e.g. ghub, magit-secion have their -pkg.el files in a subfolder so assuming -pkg.el lives in the root of the unbuilt repo isn't going to work the way I have it now. Conceivably the same could be true of a regular packagename.el file: it could be in a subdirectory.
;;   - I'll probably have to build the package before I get dependencies like straight does. Is there anything else about building the package, besides doing the :files copying/linking, that could affect the packagename.el and packagename-pkg.el files and thus dependency resolution?
;; TODO do I actually need :includes / consider the org-elpa pseudo repository (look at straight-recipes-org-elpa-retrieve in particular)
;; I think the Doom package declarations of org/org-contrib are inheriting from org-elpa and all that stuff it does with :includes and maybe other stuff /does/ matter?
;; - how does Guix handle org? One package, multiple?
;; TODO consider `straight--convert-recipe'
;; TODO consider straight-built-in-pseudo-packages
;; esp. in straight--convert-recipe
;; TODO consider how straight.el recipe inheritance works
;; esp. in straight--convert-recipe

;; TODO hack
;; Wait to do this until the end when I have a concrete idea of all the stuff I'll have to read (doom packages, melpa recipes...) and how I want to do it.
;; Ideas:
;; - hack scm/edn.scm somehow?
;; - convert `doom-packages` (and melpa recipes) package names to strings on the elisp side
;;   Would be messy with melpa recipes since there's no "elisp-reading phase"
;; - elisp "parseclj"/"parseedn" are nice but they don't solve the 0x0 problem
;;   Are they worth the additional overhead of running them on the elisp side? Again, with melpa there might not /be/ an elisp side
;;   - nice to have but maybe not necessary: handling dotted pairs, t/nil become true/nil
;; - don't use the 0x0 package
(defn icky [x]
  (if (= x "0")
    "0x0" x))

;; TODO probably do this with spec, but wait until a bit later / the end
;; (if-let [unsupported (seq (filter (fn [p]
;;                                       (or (let [type (get p :doom.package/type)]
;;                                             (some (hash-set type) (vector :doom.package.type/local :doom.package.type/built-in)))
;;                                           (let [vc (get-in p (vector :package/recipe :recipe/vc))]
;;                                             (and vc (not= vc :vc/git)))
;;                                           (get-in p (vector :package/recipe :straight.recipe/protocol))
;;                                           (get-in p (vector :package/recipe :straight.recipe/source))
;;                                           (get-in p (vector :package/recipe :straight.recipe/fork))
;;                                           (get-in p (vector :package/recipe :straight.recipe/upstream))
;;                                           (get-in p (vector :package/recipe :straight.recipe/includes))))
;;                                   $))]
;;         (throw (ex-info "Package(s) with unsupported configuration" {:packages unsupported}))
;;         $)
;; TODO NEW stuff I've decided I'm /definitely/ not supporting: fork, source
;; - don't support :build. (At leat for values other than 't, which is harmless and which Doom's org package declaration uses. Maybe just override the Doom org package like I'm going to do for its :pre-build)
;; - don't support :pre-build/:post-build (Doom's org and notmuch packages use :pre-build though, so find probably override those recipes to not have :pre-build steps and make sure the Guix packages for them do what the :pre-build steps would have done).
;; - probably not supporting manually-set inherit property (and straight-allow-recipe-inheritance must be true)
;; - list of straight package props Doom actually uses
;;   host
;;   repo
;;   files
;;   nonrecursive
;;   branch
;;   local-repo
;;   - Only straight has this and it doesn't matter for me
;;   build
;;   - only org (:build t)
;;   pre-build
;;   - only org and notmuch
;;   depth
;;   - only org (:depth 1)
;; - spec that both host and repo must be specified so in inheritance one isn't overridden without the other?
#+end_src
******** deps
Had =:tangle ebullient/deps.edn :comments link=
#+begin_src clojure :tangle no
{:paths ["src" "resources"]
 :deps {org.clojure/clojure {:mvn/version "1.11.1"}
        org.clojure/alpha.spec {:git/url "https://github.com/clojure/spec-alpha2.git"
                                :sha "99456b1856a6fd934e2c30b17920bd790dd81775"}
        babashka/fs {:mvn/version "0.1.6"}}
 :aliases
 {:run-m {:main-opts ["-m" "protostar.hickeyland"]}
  :run-x {:ns-default protostar.hickeyland
          :exec-fn greet
          :exec-args {:name "Clojure"}}
  :build {:deps {io.github.seancorfield/build-clj
                 {:git/tag "v0.6.3" :git/sha "9b8e09b"
                  ;; since we're building an app uberjar, we do not
                  ;; need deps-deploy for clojars.org deployment:
                  :deps/root "slim"}}
          :ns-default build}
  :test {:extra-paths ["test"]
         :extra-deps {org.clojure/test.check {:mvn/version "1.1.1"}
                      io.github.cognitect-labs/test-runner
                      {:git/tag "v0.5.0" :git/sha "48c3c67"}}}}}
#+end_src
******* guix part
Had =:tangle ebullient/lokke/ns/ebullient/home/packaging-wip.clj :comments link=
#+begin_src clojure :tangle no
(ns ebullient.home.packaging-wip
  (:require [guile :refer [command-line]]
            [guile.guix.base32 :refer [bytevector->nix-base32-string]]
            [guile.guix.git :refer [latest-repository-commit]]
            [guile.guix.hash :refer [file-hash*]]
            [guile.guix.store :refer [with-store]]
            [guile.srfi.srfi-11 :as srfi-11]

            [guile.guix.build-system.emacs :refer [emacs-build-system]]
            [guile.guix.git-download :refer [git-fetch git-reference git-file-name]]
            [guile.guix.packages :refer [package origin content-hash]]))

(defn- pair [a b]
  (guile/cons a b))

(defmacro let-values [bindings & body]
  (let [bindings*
        (->> bindings
             (partition 2)
             (map (fn [[names expr]]
                    (list
                     (apply list names) expr))))]
    `(srfi-11/let-values ~bindings*
       ~@body)))

(defn- download-git-repo! [url [ref' ref''] recursive?]
  (let-values
   [[dir commit]
    (with-store store
      (latest-repository-commit store url
                                :ref (pair (symbol ref') ref'')
                                :recursive? recursive?))]
   {:dir dir :commit commit}))

;; (println
;;  (download-git-repo! "https://github.com/raxod502/straight.el.git" [:branch "develop"] false))
;; (println
;;  (download-git-repo! "https://github.com/minad/consult.git" '()))

(defn get-origin-data [url ref recursive?]
  (let [{:keys [dir commit]} (download-git-repo! url ref recursive?)]
   {:commit commit
    :hash (bytevector->nix-base32-string
           (file-hash* dir))}))

;; (println
;;  (get-origin-data "https://github.com/raxod502/straight.el.git" [:branch "develop"] false))





(defn fex-package [package-name url commit recursive? hash]
  (package
   (name (str "emacs-" package-name))
   (version "0.0.1")
   (source
    (origin
     (method git-fetch)
     (uri (git-reference
           (url url)
           (commit commit)
           (recursive? recursive?)))
     (file-name (git-file-name name version))
     (hash
      (content-hash hash))))
   (build-system emacs-build-system)
   ;; (arguments
   ;;  `(#:phases
   ;;    (modify-phases %standard-phases
   ;;      (add-after 'unpack 'move-source-files
   ;;        (lambda _
   ;;          (let ((el-files (find-files "./extensions" ".*\\.el$")))
   ;;            (for-each (lambda (f)
   ;;                        (rename-file f (basename f)))
   ;;                      el-files)))))))
   ;; (native-inputs
   ;;  (list texinfo))
   (home-page nil)
   (synopsis nil)
   (description nil)
   (license nil)))

;; (println
;;  (fex-package "tldr"
;;               "https://github.com/kuanyui/tldr.el"
;;               "7203d1be3dcbf12131846ffe06601933fa874d74"
;;               nil
;;               "1bw6la463l2yfm7rp76ga4makfy4kpxgwi7ni5gxk31w11g26ryk"))




;; (defn call [nm & args]
;;   (let [f (ns-resolve *ns* (symbol nm))]
;;     (apply f args)))

(defn asdf [n]
  (+ 1 n))

(when (< (count (command-line)) 1) ; temporarily let me run this file manually
  (let [f (-> (command-line) second)
        args (-> (command-line) next next)]
    (println
     (let [func
           (case f
             "asdf" asdf)]
       (apply func (map read-string args))))))
#+end_src
******* packaging runner
Had =:tangle (meta-in-dir "packaging-runner.scm")=
#+begin_src scheme :tangle no
(use-modules (lokke ns))
(require #(ebullient.home.packaging-wip))
#+end_src
******* test clj
Had =:tangle ebullient/lokke/ns/ebullient/home/test-clj.clj :comments link=
#+begin_src clojure :tangle no
(ns ebullient.home.test-clj
  (:require [guile.guix.gexp :as g]
            [guile.guix.packages :refer [package package-description]]))

(println
 (gexp "asdf"))

;; (println
;;  (p/package (name "asdf")))

;; (println
;;  (package-description
;;   (package
;;     (name "asdf")
;;     (version "0")
;;     (source nil)
;;     (build-system nil)
;;     (synopsis "asdf")
;;     (description "asdf3333")
;;     (home-page nil)
;;     (license nil))))

(+ 1 1)
(println 5)

#+end_src
******* test scm
Had =tangle (meta-in-dir "test-scm.scm")=
#+begin_src scheme :tangle no
(use-modules (lokke ns))
(require #(ebullient.home.test-clj))
#+end_src
******* elisp
Had =:tangle (meta-in-dir "parse-doom-packages.el")=
#+begin_src elisp :tangle no
(defun m-slurp (f)
  (with-temp-buffer
    (insert-file-contents f)
    (buffer-string)))

(defun m-spit (f content)
  (with-temp-file f
    (insert content)))




(defun m-process ()
  (-as-> (m-slurp "~/projects/phrenetic/doom-packaging/my-doom-packages.el") $
         (read $)
         (-map #'-first-item $)
         (-map #'symbol-name $)))

(defun write-doom-pkgs-txt ()
  (m-spit "doom-packaging/guix-doom-emacs-packages.txt"
          (pp (m-process))))





(defun repo-commit (r)
  (let ((default-directory (concat "~/.local/var/lib/doom-local/straight/repos/" r)))
    (straight--process-output "git" "rev-parse" "HEAD")))

(defun write-current-commits ()
  (let ((pkgs-to-repos
         (-map
          (lambda (x)
            (cons
             (-first-item x)
             (-as-> x $
                    (-fourth-item $)
                    (plist-get $ :local-repo))))
          (map-into straight--build-cache 'list))))
    (-map (lambda (x)
            (cons (car x)
                  (if-let ((y (cdr x)))
                      (if (not (equal y "/home/pharcosyle/projects/dotfiles/donnager"))
                          (repo-commit y)
                        nil)
                    y)))
          pkgs-to-repos)))

;; (write-current-commits)
#+end_src
**** Doom private
:PROPERTIES:
:meta-dir+: /doom-private
:END:

#+name: palette
| Name              | Color   |
|-------------------+---------|
| fg                | #dee2f8 |
| highlight         | #8496ff |
| comments          | #63677f |
| comment-delimiter | #939abd |
| red               | #fb8578 |
| orange            | #fdce5f |
| green             | #9fed9c |
| yellow            | #eddc91 |
| blue              | #7db9fe |
| dark-blue         | #5f68de |
| magenta           | #e29bf7 |
| violet            | #aeb9f3 |
| cyan              | #75e0f9 |
| gold              | #fdd94a |
| pink              | #ff9999 |

***** Init
#+begin_src elisp :tangle (meta-in-dir "init.el")
;;; -*- lexical-binding: t; -*-

(doom! :completion
       (company +childframe)
       (vertico +icons)

       :ui
       doom
       doom-dashboard
       (emoji +unicode)
       hl-todo
       hydra
       indent-guides
       (ligatures +extra)
       modeline
       nav-flash
       ophints
       (popup +defaults +all)
       treemacs
       vc-gutter
       vi-tilde-fringe
       window-select
       workspaces

       :editor
       (evil +everywhere)
       file-templates
       fold
       format
       lispy
       multiple-cursors
       rotate-text
       snippets
       word-wrap

       :emacs
       (dired +icons)
       electric
       (ibuffer +icons)
       undo
       vc

       :term
       eshell
       vterm

       :checkers
       (syntax +childframe)

       :tools
       direnv ; TODO should be contributed by direnv component
       (eval +overlay)
       lookup
       (magit +forge)
       (pass +auth)
       pdf
       prodigy ; TODO dependency of hyperdrive. Keep it enabled by default too.
       rgb
       taskrunner
       tree-sitter
       ;; upload ; TODO dependency of massrealty/phucnet

       :lang
       clojure ; TODO contribute this with some Clojure module/compnent /if I end up having one/ (maybe along with the WIP clojure manifest)
       common-lisp ; TODO this should be contributed by Nyxt / my eventual nyxt project
       data
       emacs-lisp
       ;; graphql ; TODO dependency of krush/hyperdrive
       (json +tree-sitter)
       (javascript +tree-sitter)
       markdown
       (nix +tree-sitter) ; TODO this should be gated by Nix inclusion like system components do.
       (org +journal)
       (rest +jq)
       (scheme +guile) ; TODO Should be contributed by some Guix component (also the guix-related packages.el entries and stuff in config)
       (sh +tree-sitter)
       (web +tree-sitter)
       yaml ; TODO this should probably be specific to the krush/hyperdrive/afterburner(?) project

       :app
       calendar

       :config
       (default +bindings +smartparens))
#+end_src
***** Config
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "config.el")
:END:
#+begin_src elisp
;;; -*- lexical-binding: t; -*-
#+end_src
****** Doom Guix module params
#+begin_src elisp
(load! "params")
#+end_src
****** Requires
#+begin_src elisp
(use-package! dash)
(use-package! s)
#+end_src
****** Personal Info :user:
#+begin_src elisp
(setq user-full-name param-full-name
      user-mail-address param-email)
#+end_src
****** Locals :path:
#+begin_src elisp
(defconst biome--org-dir (concat org-directory "~/org"))
(defconst biome--org-gcal-dir (concat biome--org-dir "/gcal"))

(defconst biome--very-big 1000000)

(defconst biome--theme 'doom-nuclear)
#+end_src
#+begin_src elisp :var palette=palette
(defun biome--color (color)
  (let ((k (-> color symbol-name (substring 1))))
    (cadr (assoc k palette))))
#+end_src
****** General :UI:path:
#+begin_src elisp
;; hlissner says this must be set before org loads. I'm not sure if this is a requirement of org-mode but the Doom org config certainly does a lot of gymnastics with this variable so I'll just set this exactly like the example config does.
(setq org-directory biome--org-dir)

(setq scroll-margin 10
      save-interprogram-paste-before-kill t)

;; I like having line numbers on but hlissner says they're slow so I might want to disable them at some point. Keep in mind I use them to determine what lines are continuation lines so I might have to make the right fringe bigger if I do this and set visual-line-fringe-indicators.
;; (setq display-line-numbers-type nil)
#+end_src
******* Doom resets
#+begin_src elisp
(setq-default indent-tabs-mode t)

;; I'd like to have this on but in the Doom code it says it's more efficient not to.
;; (setq-default cursor-in-non-selected-windows t)
#+end_src
******* Doom
#+begin_src elisp
;; REVIEW Might be useful if there end up being a lot more of these and they have a lot of similarities: https://www.gnu.org/software/emacs/manual/html_node/elisp/Extending-Rx.html
(add-hook! 'doom-real-buffer-functions
  ;; (defun biome-new-buffer-p (buf)
  ;;   (s-matches?
  ;;    (rx bol "*new*"
  ;;        (* "<" (+ digit) ">")
  ;;        eol)
  ;;    (buffer-name buf)))
  ;; TODO This should be in my Org config section / module but wait to move it until I'm confident I'll be continuing with this marking-buffers-as-real approach.
  (defun biome-org-src-edit-buffer-p (buf)
    (s-matches?
     (rx bol "*Org Src " (+ anything) "*"
         (* "<" (+ digit) ">")
         eol)
     (buffer-name buf))))
#+end_src
****** Keybindings :bindings:
#+begin_src elisp
(setq help-char (string-to-char "\C-_"))
#+end_src
******* Translations
#+begin_src elisp
(defun biome--trans (&rest rest)
  (-each (-partition 2 rest)
    (-lambda ((to from))
      (define-key key-translation-map (kbd to) (kbd from)))))

(biome--trans "C-h" "DEL"
              "C-?" "C-h"

              "s-h" "<left>"
              "s-j" "<down>"
              "s-k" "<up>"
              "s-l" "<right>")
#+end_src
******* Leader/localleader
#+begin_src elisp
(setq doom-leader-alt-key "s-SPC"
      doom-localleader-key "s-m"
      doom-localleader-alt-key "s-m")
#+end_src
******* General
#+begin_src elisp
(defalias 'original-yank-pop #'yank-pop)

;; REVIEW Some of these should be in `:after' (or their respective package) sections but I'm not totally certain where I want to put bindings yet and I'm lazy.
(map! "s-V" #'original-yank-pop

      "s-SPC" doom-leader-map

      ;; Adapted from Doom macOS bindings: ~/.config/emacs/modules/config/default/config.el:263
      "s-`" #'other-frame
      "s-n" #'+default/new-buffer
      "s-z" #'undo
      "s-Z" #'redo
      "s-c" (if (featurep 'evil) #'evil-yank #'copy-region-as-kill)
      "s-v" #'yank
      "s-s" #'save-buffer
      "s-x" #'execute-extended-command
      ;; REVIEW I don't think I need this, any time I'm in visual mode I can use `evil-delete` ("d")
      ;; :v "s-x" #'kill-region
      "s-/" (cmd! (save-excursion (comment-line 1)))
      :n "s-/" #'evilnc-comment-or-uncomment-lines
      :v "s-/" #'evilnc-comment-operator

      "s-t" (lookup-key doom-leader-map (kbd "`"))
      "s-f" (lookup-key doom-leader-map (kbd "s b"))
      "s-r" (lookup-key doom-leader-map (kbd "f r"))
      "s-w" (lookup-key doom-leader-map (kbd "b k"))
      "s-d w" (lookup-key doom-leader-map (kbd "w d"))
      "s-d s-w" (cmd! (kill-current-buffer)
                      (+workspace/close-window-or-workspace))
      "s-g" (lookup-key doom-leader-map (kbd "g g"))
      "s-," (lookup-key doom-leader-map (kbd "w w"))
      "s-<" (lookup-key doom-leader-map (kbd "w W"))
      "s-y" (lookup-key doom-leader-map (kbd "i y"))
      "s-{" (lookup-key doom-leader-map (kbd "b p"))
      "s-}" (lookup-key doom-leader-map (kbd "b n"))
      "s-p" (lookup-key global-map (kbd "C-~")) ; TODO if I'm keeping this, improve it to first switch focus to a/the popup window if one isn't focused already

      "s-u" (lookup-key doom-leader-map (kbd "u"))
      "s-U" #'negative-argument         ; Trying this out.
      (:map universal-argument-map
       "s-u" #'universal-argument-more)

      (:after evil-easymotion
       "s-a" (lookup-key evilem-map (kbd "SPC")))

      "s-." #'repeat

      "s-J" #'evil-scroll-down
      "s-K" #'evil-scroll-up

      (:prefix "s-d"
       "." #'repeat-complex-command

       "h" #'git-gutter:popup-hunk
       ;; "o" #'+macos/open-in-default-program ;; TODO consider a Guix alternative? Meh.
       "r" #'projectile-replace
       "t" #'tldr
       "s" #'org-save-all-org-buffers
       "a" #'link-hint-open-multiple-links
       ;; "b" (cmd! (evil-local-mode 'toggle)
       ;;           (when evil-local-mode (evil-normal-state)))
       (:prefix "c"
        "f" #'org-gcal-fetch
        "s" #'org-gcal-sync
        "p" #'org-gcal-post-at-point)))
#+end_src
****** Modules
******* UI
******** Doom
********* doom-themes
- TODO get rid of this if I'm not going to try it out again
#+begin_src elisp
;; (after! doom-themes
;;   (doom-themes-visual-bell-config))
#+end_src
******** Modeline
********* doom-modeline
#+begin_src elisp
(after! doom-modeline
  ;; (setq doom-modeline-checker-simple-format nil)
  (setq doom-modeline-major-mode-icon t)
  (setq doom-modeline-persp-name t))
#+end_src
******** Indent Guides
********* highlight-indent-guides :prog_mode:
#+begin_src elisp
(use-package! highlight-indent-guides
  :defer t
  :init
  ;; I don't want indent guides on by default, remove all the Doom module's hooks.
  (remove-hook! '(prog-mode-hook
                  text-mode-hook
                  conf-mode-hook)
    #'highlight-indent-guides-mode))
#+end_src
******** Ligatures
********* ligature
#+begin_src elisp :tangle (meta-in-dir "init.el")
;; (use-package-hook! ligature
;;   :pre-config
;;   (setq +ligatures-all-modes-list
;;         '("www")
;;         +ligatures-prog-mode-list
;;         '(;; Fira Code (from https://github.com/tonsky/FiraCode/wiki/Emacs-instructions#using-ligatureel)
;;           "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\" "{-" "::"
;;           ":::" ":=" "!!" "!=" "!==" "-}" "----" "-->" "->" "->>"
;;           "-<" "-<<" "-~" "#{" "#[" "##" "###" "####" "#(" "#?" "#_"
;;           "#_(" ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*" "/**"
;;           "/=" "/==" "/>" "//" "///" "&&" "||" "||=" "|=" "|>" "^=" "$>"
;;           "++" "+++" "+>" "=:=" "==" "===" "==>" "=>" "=>>" "<="
;;           "=<<" "=/=" ">-" ">=" ">=>" ">>" ">>-" ">>=" ">>>" "<*"
;;           "<*>" "<|" "<|>" "<$" "<$>" "<!--" "<-" "<--" "<->" "<+"
;;           "<+>" "<=" "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<"
;;           "<~" "<~~" "</" "</>" "~@" "~-" "~>" "~~" "~~>" "%%"
;;           ;; Doom defaults (just the ones not already present in Fira Code)
;;           "|||>" "<|||" "<==>" "||>" "::=" "=!=" "!!." ">->" "---" "<~>"
;;           "<||" "<-<" "_|_" "~=" "|}" "|]" "|-" "{|" "[|" "]#" ":>" ":<"
;;           ">:" "-|" "--" "<:" "#:" "#=" "#!" ".?" "?:" "?." "__" "(*"
;;           "*)" "://"))
;;   t)
#+end_src
******* Editor
******** Evil
********* evil :bindings:theming:
#+begin_src elisp
(after! evil
  (defun biome--set-theme-cursor-color-symbols ()
    (put 'cursor 'evil-normal-color (biome--color :gold))
    (put 'cursor 'evil-emacs-color  (biome--color :pink)))

  (defadvice! biome-update-cursor-color-a (&rest _)
    :after #'+evil-update-cursor-color-h
    (when (memq biome--theme custom-enabled-themes)
      (biome--set-theme-cursor-color-symbols)))

  (map! :m [C-i] nil)) ; Remove Doom's binding for `evil-jump-forward'.
#+end_src
******** Multiple Cursors
********* evil-multiedit :evil:
#+begin_src elisp
(after! evil-multiedit
  (setq evil-multiedit-follow-matches t))
#+end_src
******** Lisp
********* lispy
#+begin_src elisp
(use-package! lispy
  :defer t
  :init
  ;; Not using lispy, remove all the Doom module's hooks.
  (remove-hook! '(lisp-mode-hook
                  emacs-lisp-mode-hook
                  ielm-mode-hook
                  scheme-mode-hook
                  racket-mode-hook
                  hy-mode-hook
                  lfe-mode-hook
                  dune-mode-hook
                  clojure-mode-hook
                  fennel-mode-hook)
    #'lispy-mode)
  (remove-hook! 'eval-expression-minibuffer-setup-hook #'doom-init-lispy-in-eval-expression-h))
#+end_src
********* lispyville :prog_mode:bindings:
#+begin_src elisp
(use-package! lispyville
  :hook (prog-mode . lispyville-mode)
  :init
  (setq lispyville-key-theme nil) ; Prevent Doom module's invocation of `lispyville-set-key-theme' from doing anything.
  :config
  (lispyville-set-key-theme
   '(operators
     c-w
     c-u
     commentary))
  (map! :map lispyville-mode-map
        "C-s-j" #'lispyville-beginning-of-next-defun
        "C-s-k" #'lispyville-beginning-of-defun
        "C-s-," #'lispyville-end-of-defun
        "C-s-a" #'lispyville-drag-backward
        "C-s-g" #'lispyville-drag-forward
        "C-s-p" #'lispyville-prettify
        (:prefix "C-s-;"
         "R" #'lispyville-raise-list)))
#+end_src
******* Emacs
******** Dired
********* dired-x :UI:hidden:
Don't hide files in dired, remove the Doom module's hook. However, via the Doom config dired-x is only loaded when ~dired-omit-mode~ is triggered so add another hook that mimics this (loads dired-x after the first use of dired). A simple =:after= would probably be fine too (and less odd) but this is lazier.
- TODO dired buffers always marked modified
  *wait to do this until I do my dired project*
  Removing the ~dired-omit-mode~ hook causes dired buffers to start off marked as modified. I don't think this was happening until I upgraded to Emacs 29 so maybe this will resolve itself on a later Emacs upgrade.
  - although even before this started happenning I recall dired buffers being marked modified and annoying to close irritating me. I don't know why I'd want that behavior to begin with but I suspect there are good reasons.
    Some remarks on modified dired buffers: [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Reverting-Dired.html]]
#+begin_src elisp
(use-package! dired-x
  :defer t
  :init
  (remove-hook! 'dired-mode-hook #'dired-omit-mode)
  (add-hook! 'dired-mode-hook
    (defun require-dired-x-h ()
      (require 'dired-x))))
#+end_src
******* Term
******** eshell :persistence:
#+begin_src elisp
(after! eshell
  (setq eshell-history-size biome--very-big)) ; Setting this to `nil' to inherit envvar HISTSIZE is another option.
#+end_src
******* Tools
******** Magit
********* magit :UI:
#+begin_src elisp
(after! magit
  (setq git-commit-style-convention-checks '(non-empty-second-line))
  (setq magit-revision-show-gravatars '("^Author:     " . "^Commit:     ")))
#+end_src
******* Lang
******** Clojure
********* clojure :bindings:theming:
#+begin_src elisp
(use-package! clojure-mode
  :defer t
  :init
  (setq clojure-refactor-map-prefix (kbd "s-M r")) ; Has to be set before clojure-mode loads. ; REVIEW temporary binding
  :config
  (set-ligatures! 'clojure-mode :lambda "fn")
  (custom-theme-set-faces! biome--theme
    `(clojure-character-face :foreground ,(doom-color 'violet) :weight bold)))
#+end_src
********* cider :persistence:
#+begin_src elisp
(after! cider
  (setq cider-repl-history-size biome--very-big
        cider-print-options '(("length" 100))))

;; REVIEW make sure this is still working after nesting in `after!'
(after! cider-repl
  (add-hook! 'cider-repl-mode-hook
             #'goto-address-prog-mode
             #'highlight-numbers-mode
             #'rainbow-delimiters-mode
             #'yas-minor-mode-on
             #'biome-sp-strict-h))
#+end_src
********* clj-refactor :bindings:
#+begin_src elisp
(after! clj-refactor
  (cljr-add-keybindings-with-prefix "s-M R")) ; REVIEW temporary binding
#+end_src
******** Emacs Lisp
********* emacs-lisp
#+begin_src elisp
(after! elisp-mode
  (setq-hook! 'emacs-lisp-mode-hook indent-tabs-mode nil))
#+end_src
******** Org
********* org :UI:path:theming:
#+begin_src elisp
(after! org
  (setq org-agenda-files `(,biome--org-dir
                           ,biome--org-gcal-dir
                           ,(concat biome--org-dir "/projects"))
        org-log-done 'time
        org-priority-lowest ?E
        org-priority-default ?C
        org-priority-faces `((?A . ,(doom-color 'red))
                             (?B . ,(doom-color 'orange))
                             (?C . ,(doom-color 'blue))
                             (?D . ,(doom-color 'yellow))
                             (?E . ,(doom-color 'green)))))
#+end_src
********* ob
#+begin_src elisp
(after! ob
  (setq org-babel-noweb-error-all-langs t))
#+end_src
********* evil-org :evil:bindings:
#+begin_src elisp
(after! evil-org
  (map! :map evil-org-mode-map
        :nv "C-j" #'outline-forward-same-level
        :nv "C-k" #'outline-backward-same-level))
#+end_src
******** Scheme
********* scheme
#+begin_src elisp
(after! scheme
  (setq-hook! 'scheme-mode-hook indent-tabs-mode nil))
#+end_src
********* geiser :persistence:path:guix:
Use ~:init~ to configure variables (as opposed to ~:config~, which seems like it'd be fine) because hlissner does it this way for the Geiser package so I will too.
#+begin_src elisp
(use-package! geiser
  :defer t
  :init
  (setq geiser-repl-current-project-function #'ignore)) ; Reset this back to its default (don't have separate REPLs for projects) because it doesn't play nice with the Guix store.
#+end_src
******* App
******** Calendar
********* org-gcal :org:user:secret:persistence:path:
#+begin_src elisp
(after! org-gcal
  (setq org-gcal-client-id "446729771716-pp79934q99aro2h8v3iki1fejcodbdoo.apps.googleusercontent.com"
        org-gcal-client-secret (-> (auth-source-search :host org-gcal-client-id) car (plist-get :secret) funcall)
        org-gcal-fetch-file-alist `((user-mail-address . ,(concat biome--org-gcal-dir "/" user-mail-address ".org"))
                                    ("addressbook%23contacts@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/contacts.org"))
                                    ("en.usa%23holiday@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/holidays.org")))
        org-gcal-recurring-events-mode 'nested))
#+end_src
******* Config
******** expand-region :bindings:
#+begin_src elisp
(use-package! expand-region
  :defer t
  :init
  (map! :nv "s-e" #'er/expand-region
        :nv "s-E" #'er/contract-region)
  :config
  (setq expand-region-fast-keys-enabled nil) ; My mapping is conventient enough and I don't want the repeat key to conflict with anything.
  ;; Copied from Doom config: ~/.config/emacs/modules/config/default/+emacs.el:12
  (defadvice! biome--quit-expand-region-a (&rest _)
    "Properly abort an expand-region region."
    :before '(evil-escape doom/escape)
    (when (memq last-command '(er/expand-region er/contract-region))
      (er/contract-region 0))))
#+end_src
******* Guix
******** guix.el
********* guix :UI:
#+begin_src elisp
(after! guix
  (set-popup-rules!
    '(("^\\*Guix" :height 0.5))))
#+end_src
********* guix-devel :scheme:
#+begin_src elisp
(use-package! guix-devel
  :hook (scheme-mode . guix-devel-mode))
#+end_src
********* guix-popup :bindings:
#+begin_src elisp
(use-package! guix-popup
  :defer t
  :init
  (map! :leader
        "l" #'guix))  ; REVIEW temporary binding?
#+end_src
********* guix-prettify :UI:
#+begin_src elisp
(use-package! guix-prettify
  :hook (doom-first-buffer . global-guix-prettify-mode))
#+end_src
******** guix-contributing
#+begin_src elisp
;; TODO once I'm done packaging Doom figure out how to enable this
;; (use-package! guix-contributing)
#+end_src
******** guix-packaging :persistence:path:
#+begin_src elisp
(use-package! guix-packaging
  :defer t
  :init
  (setq guix-packaging--data-dir (concat doom-cache-dir "guix-packaging")))
#+end_src
******* ?
******** avy
#+begin_src elisp
;; REVIEW Trying out not having this so I can use avy dispatch commands.
;; (after! avy
;;   (setq avy-single-candidate-jump t))
#+end_src
******** paren :UI:
#+begin_src elisp
(after! paren
  (setq! show-paren-delay 0))
#+end_src
******** prog-mode :prog_mode:
#+begin_src elisp
(add-hook! 'prog-mode-hook #'biome-sp-strict-h)
#+end_src
******** rainbow-delimiters :theming:
#+begin_src elisp
(after! rainbow-delimiters
  (let ((default-max rainbow-delimiters-max-face-count))
    (defun biome-set-rainbow-delimiters-max-face-count ()
      (setq rainbow-delimiters-max-face-count
            (if (memq biome--theme custom-enabled-themes)
                8 default-max))))

  (biome-set-rainbow-delimiters-max-face-count)
  (add-hook! 'doom-load-theme-hook #'biome-set-rainbow-delimiters-max-face-count)

  (custom-theme-set-faces! biome--theme
    `(rainbow-delimiters-depth-1-face :foreground ,(doom-color 'fg))
    `(rainbow-delimiters-depth-2-face :foreground ,(doom-color 'magenta))
    `(rainbow-delimiters-depth-3-face :foreground ,(doom-color 'blue))
    `(rainbow-delimiters-depth-4-face :foreground ,(doom-color 'cyan))
    `(rainbow-delimiters-depth-5-face :foreground ,(doom-color 'green))
    `(rainbow-delimiters-depth-6-face :foreground ,(doom-color 'yellow))
    `(rainbow-delimiters-depth-7-face :foreground ,(doom-color 'orange))
    `(rainbow-delimiters-depth-8-face :foreground ,(doom-color 'red))))
#+end_src
******** recentf :persistence:
#+begin_src elisp
(after! recentf
  (setq recentf-max-saved-items 500))
#+end_src
******** smartparens :bindings:
#+begin_src elisp
(after! smartparens
  (map! :map smartparens-mode-map
        "C-s-h" #'sp-backward-sexp
        "C-s-l" #'sp-forward-sexp
        "C-s-u" #'sp-backward-up-sexp
        "C-s-o" #'sp-up-sexp
        :gn "C-s-m" #'sp-backward-down-sexp ; Bind in normal mode explicitly to override the Doom mapping in ~/.config/emacs/modules/config/default/config.el:447
        "C-s-." #'sp-down-sexp
        "C-s-c" #'sp-splice-sexp
        "C-s-s" #'sp-splice-sexp-killing-backward
        "C-s-f" #'sp-splice-sexp-killing-forward
        "C-s-x" #'sp-backward-slurp-sexp
        "C-s-v" #'sp-forward-slurp-sexp
        "C-s-w" #'sp-backward-barf-sexp
        "C-s-r" #'sp-forward-barf-sexp
        (:prefix "C-s-;"
         "(" #'sp-wrap-round
         "[" #'sp-wrap-square
         "{" #'sp-wrap-curly
         "s" #'sp-split-sexp
         "j" #'sp-join-sexp
         "r" #'sp-raise-sexp
         "c" #'sp-convolute-sexp
         "w" #'sp-rewrap-sexp)))
#+end_src
********* Hook :bindings:
#+begin_src elisp
(defun biome-sp-strict-h ()
  (add-hook! 'smartparens-enabled-hook :local
             #'turn-on-smartparens-strict-mode
             (defun biome-modify-sp-strict-mode-map-h ()
               (map! :map smartparens-strict-mode-map
                     :i "DEL" #'sp-backward-delete-char))))
#+end_src
******** transient :persistence:
- TODO Not sure where this should be categorized, it's a helper package required by at least magit, forge, git-timemachine
#+begin_src elisp
(after! transient
  (setq transient-history-limit biome--very-big))
#+end_src
******** undo-fu
#+begin_src elisp
(after! undo-fu
  (setq undo-fu-ignore-keyboard-quit t))
#+end_src
******** undo-tree :UI:
#+begin_src elisp
;; (after! undo-tree
;;   (setq undo-tree-visualizer-timestamps t))
#+end_src
******** emojify :UI:
#+begin_src elisp
(after! emojify
  (setq emojify-display-style 'unicode))
#+end_src
******** asdf :bindings:
- TODO donno where this should go, ~+default-minibuffer-maps~ is a doom thing I guess
#+begin_src elisp
(define-key! :keymaps +default-minibuffer-maps
  "s-J" #'scroll-up-command
  "s-K" #'scroll-down-command)
#+end_src
****** Theming :theming:
#+begin_src elisp
(setq doom-theme biome--theme)

(custom-theme-set-faces! biome--theme
  `(font-lock-comment-delimiter-face :foreground ,(biome--color :comment-delimiter))
  `(font-lock-doc-face :foreground ,(doom-color 'cyan)))
#+end_src
******* Font
#+begin_src elisp
(let ((font (font-spec :family param-font-name
                       :size param-font-size
                       :weight param-font-weight)))
  (when (find-font font)
    (setq doom-font font)))
#+end_src
******* Nuclear Theme

#+call: gen-doom-theme() :results code :post unescape(*this*) :results_switches ":tangle (meta-in-dir \"themes/doom-nuclear-theme.el\")"

#+RESULTS:
#+begin_src elisp :tangle (meta-in-dir "themes/doom-nuclear-theme.el")
;;; nuclear-theme.el --- inspired by Atom One Dark -*- lexical-binding: t; no-byte-compile: t; -*-
;;
;;
;;
;;; Commentary:
;;
;; This themepack's flagship theme.
;;
;;; Code:

(require 'doom-themes)


;;
;;; Variables

(defgroup nuclear-theme nil
  "Options for the `nuclear' theme."
  :group 'doom-themes)

(defcustom nuclear-brighter-modeline nil
  "If non-nil, more vivid colors will be used to style the mode-line."
  :group 'nuclear-theme
  :type 'boolean)

(defcustom nuclear-brighter-comments nil
  "If non-nil, comments will be highlighted in more vivid colors."
  :group 'nuclear-theme
  :type 'boolean)

(defcustom nuclear-padded-modeline doom-themes-padded-modeline
  "If non-nil, adds a 4px padding to the mode-line.
Can be an integer to determine the exact padding."
  :group 'nuclear-theme
  :type '(choice integer boolean))


;;
;;; Theme definition

(def-doom-theme doom-nuclear
  "A dark theme inspired by Atom One Dark."

  ;; name        default   256           16
  ((bg         '("#282c34" "black"       "black"  ))
   (fg         '("#dee2f8" "#bfbfbf"     "brightwhite"  ))

   ;; These are off-color variants of bg/fg, used primarily for `solaire-mode',
   ;; but can also be useful as a basis for subtle highlights (e.g. for hl-line
   ;; or region), especially when paired with the `doom-darken', `doom-lighten',
   ;; and `doom-blend' helper functions.
   (bg-alt     '("#21242b" "black"       "black"        ))
   (fg-alt     '("#5B6268" "#2d2d2d"     "white"        ))

   ;; These should represent a spectrum from bg to fg, where base0 is a starker
   ;; bg and base8 is a starker fg. For example, if bg is light grey and fg is
   ;; dark grey, base0 should be white and base8 should be black.
   (base0      '("#1B2229" "black"       "black"        ))
   (base1      '("#1c1f24" "#1e1e1e"     "brightblack"  ))
   (base2      '("#202328" "#2e2e2e"     "brightblack"  ))
   (base3      '("#23272e" "#262626"     "brightblack"  ))
   (base4      '("#3f444a" "#3f3f3f"     "brightblack"  ))
   (base5      '("#5B6268" "#525252"     "brightblack"  ))
   (base6      '("#73797e" "#6b6b6b"     "brightblack"  ))
   (base7      '("#9ca0a4" "#979797"     "brightblack"  ))
   (base8      '("#DFDFDF" "#dfdfdf"     "white"        ))

   (grey       base4)
   (red        '("#fb8578" "#ff6655" "red"          ))
   (orange     '("#fdce5f" "#dd8844" "brightred"    ))
   (green      '("#9fed9c" "#99bb66" "green"        ))
   (teal       '("#4db5bd" "#44b9b1" "brightgreen"  ))
   (yellow     '("#eddc91" "#ECBE7B" "yellow"       ))
   (blue       '("#7db9fe" "#51afef" "brightblue"   ))
   (dark-blue  '("#5f68de" "#2257A0" "blue"         ))
   (magenta    '("#e29bf7" "#c678dd" "brightmagenta"))
   (violet     '("#aeb9f3" "#a9a1e1" "magenta"      ))
   (cyan       '("#75e0f9" "#46D9FF" "brightcyan"   ))
   (dark-cyan  '("#5699AF" "#5699AF" "cyan"         ))

   ;; These are the "universal syntax classes" that doom-themes establishes.
   ;; These *must* be included in every doom themes, or your theme will throw an
   ;; error, as they are used in the base theme defined in doom-themes-base.
   (highlight      "#8496ff")
   (vertical-bar   (doom-darken base1 0.1))
   (selection      dark-blue)
   (builtin        blue)
   (comments       "#63677f")
   (doc-comments   (doom-lighten (if nuclear-brighter-comments dark-cyan base5) 0.25))
   (constants      yellow)
   (functions      blue)
   (keywords       magenta)
   (methods        violet)
   (operators      cyan)
   (type           orange)
   (strings        green)
   (variables      red)
   (numbers        violet)
   (region         `(,(doom-lighten (car bg-alt) 0.15) ,@(doom-lighten (cdr base1) 0.35)))
   (error          red)
   (warning        yellow)
   (success        green)
   (vc-modified    orange)
   (vc-added       green)
   (vc-deleted     red)

   ;; These are extra color variables used only in this theme; i.e. they aren't
   ;; mandatory for derived themes.
   (modeline-fg              fg)
   (modeline-fg-alt          base5)
   (modeline-bg              (if nuclear-brighter-modeline
                                 (doom-darken blue 0.45)
                               (doom-darken bg-alt 0.1)))
   (modeline-bg-alt          (if nuclear-brighter-modeline
                                 (doom-darken blue 0.475)
                               `(,(doom-darken (car bg-alt) 0.15) ,@(cdr bg))))
   (modeline-bg-inactive     `(,(car bg-alt) ,@(cdr base1)))
   (modeline-bg-inactive-alt `(,(doom-darken (car bg-alt) 0.1) ,@(cdr bg)))

   (-modeline-pad
    (when nuclear-padded-modeline
      (if (integerp nuclear-padded-modeline) nuclear-padded-modeline 4))))


  ;;;; Base theme face overrides
  (((line-number &override) :foreground base4)
   ((line-number-current-line &override) :foreground violet)
   ((font-lock-comment-face &override)
    :background (if nuclear-brighter-comments (doom-lighten bg 0.05)))
   (mode-line
    :background modeline-bg :foreground modeline-fg
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg)))
   (mode-line-inactive
    :background modeline-bg-inactive :foreground modeline-fg-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-inactive)))
   (mode-line-emphasis :foreground (if nuclear-brighter-modeline base8 highlight))

   ;;;; css-mode <built-in> / scss-mode
   (css-proprietary-property :foreground orange)
   (css-property             :foreground green)
   (css-selector             :foreground blue)
   ;;;; doom-modeline
   (doom-modeline-bar :background (if nuclear-brighter-modeline modeline-bg highlight))
   (doom-modeline-buffer-file :inherit 'mode-line-buffer-id :weight 'bold)
   (doom-modeline-buffer-path :inherit 'mode-line-emphasis :weight 'bold)
   (doom-modeline-buffer-project-root :foreground green :weight 'bold)
   ;;;; elscreen
   (elscreen-tab-other-screen-face :background "#353a42" :foreground "#1e2022")
   ;;;; ivy
   (ivy-current-match :background dark-blue :distant-foreground base0 :weight 'normal)
   ;;;; LaTeX-mode
   (font-latex-math-face :foreground green)
   ;;;; markdown-mode
   (markdown-markup-face :foreground base5)
   (markdown-header-face :inherit 'bold :foreground red)
   ((markdown-code-face &override) :background (doom-lighten base3 0.05))
   ;;;; rjsx-mode
   (rjsx-tag :foreground red)
   (rjsx-attr :foreground orange)
   ;;;; solaire-mode
   (solaire-mode-line-face
    :inherit 'mode-line
    :background modeline-bg-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-alt)))
   (solaire-mode-line-inactive-face
    :inherit 'mode-line-inactive
    :background modeline-bg-inactive-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-inactive-alt))))

  ;;;; Base theme variable overrides-
  ())

;;; nuclear-theme.el ends here
#+end_src
******** Generator
:PROPERTIES:
:header-args+: :tangle no
:END:
#+name: gen-doom-theme
#+begin_src elisp :var palette=palette
(defun dt--color (color)
  (let ((k (-> color symbol-name (substring 1))))
    (cadr (assoc k palette))))

(defmacro dt--buffer->string (&rest body)
  `(with-temp-buffer
     ,@body
     (buffer-string)))

(defun dt--slurp (f)
  (dt--buffer->string
   (insert-file-contents f)))

(defun dt--replace (s match replacement)
  (replace-regexp-in-string match replacement s 'fixedcase 'literal))

(defun dt--replace-sexp (s match replacement)
  (dt--buffer->string
   (insert s)
   (goto-char (point-min))
   (re-search-forward match)
   ;; Calling `forward-sexp' and `backward-sexp' here to preserve whitespace.
   (forward-sexp)
   (backward-sexp)
   (kill-sexp)
   (insert (format "%S" replacement))))

(defun dt--gen-doom-theme (f)
  (-as->
   (dt--slurp f) $
   (dt--replace-sexp $ "def-doom-theme" 'doom-nuclear)
   (dt--replace $ "doom-one" "nuclear")
   (-reduce-from
    (-lambda (s (match replacement))
      (dt--replace-sexp s match replacement))
    $
    (-partition
     2
     (let ((match-base-color (lambda (form)
                               (rx-to-string `(seq "(" ,form (+ whitespace) "'("))))
           (match-face (lambda (&rest forms)
                         (rx-to-string `(seq "(" ,@forms)))))
       (list
        (funcall match-base-color "fg") (dt--color :fg)
        (funcall match-base-color "red") (dt--color :red)
        (funcall match-base-color "orange") (dt--color :orange)
        (funcall match-base-color "green") (dt--color :green)
        (funcall match-base-color "yellow") (dt--color :yellow)
        (funcall match-base-color "blue") (dt--color :blue)
        (funcall match-base-color "dark-blue") (dt--color :dark-blue)
        (funcall match-base-color "magenta") (dt--color :magenta)
        (funcall match-base-color "violet") (dt--color :violet)
        (funcall match-base-color "cyan") (dt--color :cyan)
        (funcall match-face "highlight") (dt--color :highlight)
        (funcall match-face "builtin") 'blue
        (funcall match-face "comments") (dt--color :comments)
        (funcall match-face "constants") 'yellow
        (funcall match-face "functions") 'blue
        (funcall match-face "keywords") 'magenta
        (funcall match-face "methods") 'violet
        (funcall match-face "operators") 'cyan
        (funcall match-face "type") 'orange
        (funcall match-face "variables") 'red
        (funcall match-face "numbers") 'violet
        (funcall match-face "line-number-current-line" '(+? anything) ":foreground") 'violet))))
   (dt--replace $ (rx ";; Added" (*? anything) "\n") "")
   (dt--replace $ (rx ";; Author" (*? anything) "\n") "")
   (dt--replace $ (rx ";; Maintainer" (*? anything) "\n") "")
   (dt--replace $ (rx ";; Source" (*? anything) "\n") "")))

;; REVIEW do this better (don't hardcode it?). Add a :path: tag to this org header if necessary. Perhaps it would be best to have the doom-themes repo be an explicit dependency in some way and manage like I do other Guix or Doom/straight dependencies.
(dt--gen-doom-theme "~/.config/emacs/.local/straight/repos/themes/themes/doom-one-theme.el")
#+end_src

#+name: unescape
#+begin_src elisp :var s=""
(-as-> s $
       (substring s 1 -1) ; Remove outer quotes.
       (replace-regexp-in-string (rx "\\n" ) "\n" $) ; Unescape newlines specifically before unescaping everything else (not how this works / why it's necessary).
       (replace-regexp-in-string (rx "\\" (group anything)) "\\1" $))
#+end_src
****** Projects
******* Phrenetic :path:
#+begin_src elisp
(load "~/projects/phrenetic/meta" 'noerror 'nomessage)

(pushnew! safe-local-variable-values
          '(eval . (with-eval-after-load 'geiser-guile
                     (let ((root-dir
                            (file-name-directory
                             (locate-dominating-file default-directory ".dir-locals.el"))))
                       (make-local-variable 'geiser-guile-load-path)
                       (add-to-list 'geiser-guile-load-path root-dir)))))
#+end_src
******* Nyxt
- TODO donno if I should keep this section in particular (it's not really impoportant), I'm just thinking I want to start trying out adding safe local variables for other codebases so I can get their advantages. Also the changes it makes persist (modify ~lisp-imenu-generic-expression~), I don't know if that's a good idae.
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(eval . (cl-flet ((enhance-imenu-lisp
                              (&rest keywords)
                              (dolist (keyword keywords)
                                (add-to-list
                                 'lisp-imenu-generic-expression
                                 (list (purecopy (concat (capitalize keyword)
                                                         (if (string= (substring-no-properties keyword -1) "s")
                                                             "es"
                                                           "s")))
                                       (purecopy (concat "^\\s-*("
                                                         (regexp-opt
                                                          (list (concat "define-" keyword))
                                                          t)
                                                         "\\s-+\\(" lisp-mode-symbol-regexp "\\)"))
                                       2)))))
                     ;; This adds the argument to the list of imenu known keywords.
                     (enhance-imenu-lisp
                      "bookmarklet-command"
                      "class"
                      "command"
                      "ffi-method"
                      "function"
                      "mode"
                      "parenscript"
                      "user-class"))))
#+end_src
******* Hyperdrive :path:
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(cider-preferred-build-tool . shadow-cljs)
          '(cider-default-cljs-repl . shadow)
          '(cider-shadow-default-options . ":app")
          '(cider-offer-to-open-cljs-app-in-browser . nil)
          '(cider-clojure-cli-global-options . "-A:dev")
          '(eval . (setenv "DATOMIC_APP_INFO_MAP" "{:app-name \"neutrino\"}"))
          '(eval . (setenv "DATOMIC_ENV_MAP" "{:env :dev}"))
          '(cider-clojure-cli-global-options . nil))

(prodigy-define-service
  :name "Amplify Mock"
  :command "amplify"
  :args '("mock")
  :cwd "~/projects/Krush/hyperdrive/apps/singularity"
  :kill-process-buffer-on-stop t)

(prodigy-define-service
  :name "Datomic Access (exogenesis)"
  :command "bash"
  :args '("datomic" "client" "access" "exogenesis")
  :cwd "~/projects/Krush/hyperdrive/ion/team"
  :kill-process-buffer-on-stop t)
#+end_src
******* Massrealty :path:
#+begin_src elisp
;; (pushnew! safe-local-variable-values
;;           '(ssh-deploy-root-remote . "/ssh:massrealty@35.196.144.73:/home/massrealty/deploy/homes/public_html/")
;;           '(ssh-deploy-automatically-detect-remote-changes . t))

;; (after! org-gcal
;;   (add-to-list 'org-gcal-fetch-file-alist `("krzysztof@massrealty.com" . ,(concat biome--org-gcal-dir "/krzysztof@massrealty.com.org")) 'append))
#+end_src
****** WIP
#+begin_src elisp
(after! org
  (add-to-list 'org-agenda-files (concat biome--org-dir "/spring_cleaning") 'append))

;; I don't think I'll ever need this with Sway. Is it worth keeping this and having an "I'm not on Sway / some WM" conditional around it?
;; (add-to-list 'initial-frame-alist '(fullscreen . fullboth))

(map! "s-A" #'app-launcher-run-app)

(map! "s-&" (lambda (command)
              (interactive (list (read-shell-command "$ ")))
              (call-process-shell-command command nil 0 nil)))

(map! :leader
      "s-," (lookup-key doom-leader-map (kbd "<")))

(after! company
  (map! :map company-active-map
        "s-[" #'company-show-doc-buffer ; Currently opens Help, it would be better if I made it use Helpful.
        "s-]" #'company-show-location))

(after! evil-org
  (map! :map evil-org-mode-map
        (:prefix "g"
         :nv "{" #'evil-backward-paragraph
         :nv "}" #'evil-forward-paragraph)))

;; TODO Maybe do this if popping to the side is too annoying
;; (after! geiser-repl
;;   (setq geiser-repl-use-other-window nil))

;; Doesn't work yet: you have to switch to the buffer "manually" once before it starts being treated as real
(map! "s-d m" (cmd! (doom-set-buffer-real (current-buffer) t)))

;; `forward-char' in original definition is messing things up, do this for now
;; (defun +eshell/search-history ()
;;   (interactive)
;;   (consult-history))
(after! esh-mode
  (map! :map eshell-mode-map
        "C-s" #'consult-history))

;; Remove the :mode set by the Doom module. It's unnecessary (`guix-drv-mode.el' already does this, and for /nix/store drvs specifically) and it shadows `guix-derivation-mode'.
;; TODO should this go in the Guix or Nix config section?
(use-package! nix-drv-mode
  :defer t
  :init
  (setq auto-mode-alist (delete '("\\.drv\\'" . nix-drv-mode) auto-mode-alist)))

(after! vertico
  (setq vertico-count 20  ; Trying out, maybe too big.
        vertico-scroll-margin 7))
#+end_src
******* "status bar"
Not using waybar at the moment so these are handy.
#+begin_src elisp
(use-package! battery
  :config
  (display-battery-mode 1))

(use-package! time
  :config
  (setq display-time-day-and-date t)
  ;; (setq display-time-24hr-format t)
  (display-time-mode 1))
#+end_src
******* keybinding ideas
#+begin_src elisp
;; If I keep this I can get rid of the "C-_" binding I have too. Update: maybe? Some places C-_ works and some s-h does (in vertico)? What about my key translation for C-? ? Straighten all this shit out.
(biome--trans "s-h" "C-h")

(map! "s-o" (lookup-key doom-leader-map (kbd "<")))
;; Get rid of binding for =s-r=?
(map! "s-r" nil)

;; Maybe "C-s-i" but then I'll have to change my sexp-movement command(s). Maybe keep this even if I do that, for consistency.
(biome--trans "C-S-i" "<backtab>")
;; Also messes with my sexp-movement bindings
;; (map! "C-s-j" #'evil-scroll-down
;;       "C-s-k" #'evil-scroll-up)

(after! evil
  (map! :map evil-motion-state-map
        ;; Maybe "C-s-o" but then I'll have to change my sexp-movement command(s). There are other bindings for jump-forward though, maybe I'll just use those.
        "C-S-o" #'evil-jump-forward))

;; Maybe `s-S' to save-and-tangle? If I don't get some sort of auto-tangling thing going
;; - maybe it could be "save and eval defun (C-M-x)" in lisp/programming modes?'
;; Maybe a hotkey that just jumps back and forth between my most recently focused browser window and eemacs?
;; Maybe bind `s-o' in `consult-buffer' to "close consult-buffer and open +vertico/switch-workspace-buffer"
#+end_src
******* phrenetic auto-tangle :path:
- TODO Might be easier to do this with file-local variables.
#+begin_src elisp
;; (setq biome--phrenetic-dir "~/projects/phrenetic")

;; (add-hook! 'org-mode-hook
;;   (defun biome-add-org-autotangle-after-save-hook-h ()
;;     (add-hook! 'after-save-hook :local
;;       (defun biome-autotangle-h ()
;;         (when (file-in-directory-p buffer-file-name biome--phrenetic-dir)
;;           ;; TODO ensure there aren't files in the output directory that no longer correspond to the org file. Just wipe it?
;;           (let ((org-confirm-babel-evaluate nil))
;;             (org-babel-tangle)))))))
#+end_src
******* org-tanglesync
#+begin_src elisp
;; (use-package! org-tanglesync
;;   :hook ((org-mode . org-tanglesync-mode)
;;          ((prog-mode text-mode) . org-tanglesync-watch-mode))
;;   :config
;;   (setq org-tanglesync-watch-files '("/home/pharcosyle/projects/phrenetic/phrenetic.org")))
#+end_src
******* Temporary copypasta from bloodhound
Copying this here for now, for convenience.
#+begin_src elisp
(setq my-dotfiles-git-dir (concat "--git-dir=" (expand-file-name "~/home-state.git")))
;; (setq my-dotfiles-work-tree (concat "--work-tree=" (expand-file-name "~")))
(map! "s-b" (cmd!
             (pushnew! magit-git-global-arguments my-dotfiles-git-dir)
             (magit-status "~")))
(map! "s-B" (cmd!
             ;; (delq! my-dotfiles-git-dir magit-git-global-arguments)
             ;; Why is the above not working? Doing this for now:
             ;; - Update: because `delq!' tests for equality with `eq'
             (setq magit-git-global-arguments (remove my-dotfiles-git-dir magit-git-global-arguments))))
#+end_src
******* until I get semicolon working
#+begin_src elisp
(map! (:map minibuffer-local-map
       "C-:" #'embark-act
       "C-c C-:" #'embark-export)
      (:leader
       "A" #'embark-dwim)
      ;; Trying out cycling (temp)
      "C-:" #'embark-act
      "s-q" #'embark-cycle)
#+end_src
******* ligatures
Probably move these to ~after!~ blocks
#+begin_src elisp
(set-ligatures! '(html-mode nxml-mode web-mode)
  :font-ligatures '("<!--" "-->" "</>" "</" "/>" ; Fira Code
                    "://"))
#+end_src
****** Out-of-band
Useful for making quick configuration additions if the the active Doomdir isn't writable (for example if it's symlinked to the Guix store).
#+begin_src elisp :var oob-dir=(meta-get-dir)
(let ((oob-dir (concat "~/projects/phrenetic/" oob-dir))) ; TODO currently `meta-get-dir' returns a path relative to the phrenetic dir. That might change but regardless don't hardcode the path here eventually.
  (let* ((file "out-of-band"))
    (or (load (concat oob-dir "/" file) 'noerror 'nomessage)
        (load! file nil 'noerror))))
#+end_src
******* File
#+begin_src elisp :tangle (meta-in-dir "out-of-band.el")
#+end_src
***** Packages :version:
#+begin_src elisp :tangle (meta-in-dir "packages.el")
;; -*- no-byte-compile: t; -*-

(package! dash :pin "0ac1ecf6b56eb67bb81a3cf70f8d4354b5782341") ; TODO make this be introduced by my doom config (where I need it)?
(package! expand-region :pin "c5c4362741deebb0985a8a29f9b8b0e25160764a")
(package! tldr :pin "d3fd2a809a266c005915026799121c78e8b358f0")
(package! trashed :pin "ddf5830730544435a068f2dc9ac75a81ea69df1d")

(package! guix :pin "c9aef52121b458297e70bb50f49f7276b4a8d759")
(package! build-farm :pin "5c268a3c235ace0d79ef1ec82c440120317e06f5") ; REVIEW trying out
(package! guix-packaging ; REVIEW trying out
  :recipe (:host github
           :repo "ryanprior/emacs-guix-packaging"
           :files (:defaults "snippets"))
  :pin "5bbd1f1a268b3dfd813a75125ca88cbf0bef6529")

(package! bluetooth :pin "3a3c3c04437518f1ce0e940adf4a5e020b9755c3") ; TODO just maybe make this dependent on my "bluetooth feature"

(package! symon :pin "8dd8b6df49b03cd7d31b85aedbe9dd08fb922335")

(package! org-tanglesync :pin "af83a73ae542d5cb3c9d433cbf2ce1d4f4259117")

(package! i3wm-config-mode :pin "3574d88241118ed6cc5a3022b6dde58d6f5af9dd") ; TODO maybe make this part of a Sway / Window Manager feature or introduced by my Dotfiles project

(package! app-launcher
  :recipe (:host github
           :repo "SebastienWae/app-launcher")
  :pin "d5015e394b0a666a8c7c4d4bdf786266e773b145")

(package! 0x0 :pin "63cd5eccc85e527f28e1acc89502a53245000428")
#+end_src
*** Git
#+begin_src scheme
(define* (he-git #:key
                 full-name
                 email
                 sign-commits? ; TODO make this (sign-commits? #t) once I have my gpg stuff set up and I'm passing a gpg-sign-key.
                 gpg-sign-key
                 ;; git-send-email?
                 extra-config)
  (list
   ;; (when git-send-email?
   ;;   (simple-service
   ;;    'git-send-email-package
   ;;    home-profile-service-type
   ;;    (list (list git "send-email"))))
   (service
    home-git-service-type
    (home-git-configuration
     (config
      `((user
         ((name . ,full-name)
          (email . ,email)
          ,@(if sign-commits?
                `((signingkey . ,gpg-sign-key)) '())))
        ;; TODO stuff from feature-git, figure it out later
        ;; (merge
        ;;  ;; diff3 makes it easier to solve conflicts with smerge, zdiff3
        ;;  ;; should make a conflict scope smaller, but guile-git fails if
        ;;  ;; this option is set.
        ;;  ((conflictStyle . diff3)))
        ;; (diff
        ;;  ;; histogram should be smarter about diff generation.
        ;;  ((algorithm . histogram)))
        (commit
         (,@(if sign-commits?
                '((gpgsign . #t)) '())))
        ;; (sendemail
        ;;  ((annotate . #t)))
        ;;  TODO these two (http and gpg) sections were in the RDE example home environment (but notably not in the rde feature-git). Figure out what they're for after I do gpg.
        ;; (http "https://weak.example.com"
        ;;       ((ssl-verify . #f)))
        ;; (gpg
        ;;  ((program . ,(file-append gnupg "/bin/gpg"))))
        ,@(if extra-config
              extra-config '())))))))
#+end_src
*** SSH
#+begin_src scheme
(define (he-ssh)
  (list
   (service home-openssh-service-type)))
#+end_src
*** Direnv
#+begin_src scheme
(define* (he-direnv #:key shell)
  (list
   ;; REVIEW This might not be necessary once I integrate emacs-envrc during my Doom/Straight/Guix integration (clarification: the envrc emacs package needs to have direnv on the command line, the emacs-direnv Guix package bakes it in)
   (simple-service
    'direnv-add-package
    home-profile-service-type
    (list direnv))

   (let ((direnv-hook
          (lambda (shell)
            (let ((direnv-bin (file-append direnv "/bin/direnv")))
              (mixed-text-file
               "direnv-hook"
               "command -v " direnv-bin " > /dev/null && eval \"$(" direnv-bin " hook " shell ")\"")))))
     (case shell
       ;; ((#:shell/bash) (simple-service
       ;;                  'direnv-bash-hook
       ;;                  home-bash-service-type
       ;;                  (home-bash-extension
       ;;                   (bashrc
       ;;                    (list (direnv-hook "bash"))))))
       ((#:shell/zsh) (simple-service
                       'direnv-zsh-hook
                       home-zsh-service-type
                       (home-zsh-extension
                        (zshrc
                         (list (direnv-hook "zsh"))))))))))
#+end_src
*** Desktop
**** Desktop packages
#+begin_src scheme
(define* (he-desktop-packages
          #:key
          (packages (list pavucontrol

                          ;; "protonvpn-cli" ; TODO Appears to be broken after the big Guix frozen-updates upgrade.

                          ;; nyxt
                          ;; gst-libav
                          ;; gst-plugins-bad
                          ;; gst-plugins-base
                          ;; gst-plugins-good
                          ;; gst-plugins-ugly
                          )))
  (list
   (simple-service
    'desktop-packages-add
    home-profile-service-type
    packages)))
#+end_src
**** XDG
#+begin_src scheme
(define* (he-xdg
          #:key
          (xdg-user-directories-configuration
           (let* ((xdg-user-subdir "/files")
                  (xdg-dir (lambda (path)
                             (string-append "$HOME" xdg-user-subdir path))))
             (home-xdg-user-directories-configuration
              (desktop "$HOME/desktop")
              (documents (xdg-dir "/docs"))
              (download "$HOME/dl")
              (music (xdg-dir "/music"))
              (pictures (xdg-dir "/pics"))
              (publicshare (xdg-dir "/public"))
              (templates (xdg-dir "/templates"))
              (videos (xdg-dir "/vids"))))))
  (list
   (simple-service
    'add-xdg-packages
    home-profile-service-type
    (list xdg-utils
          xdg-user-dirs ; I don't think I need this (the only reason would be if programs ever call the `xdg-user-dir' shell command and this package isn't an input to theirs).
          desktop-file-utils)) ; I don't think I need this at all but it adds elisp code (a mode for editing .desktop files). Andrew Tropin has it, I'll keep it just in case.

   (service
    home-xdg-user-directories-service-type
    xdg-user-directories-configuration)))
#+end_src
**** Pipewire
#+begin_src scheme
(define (he-pipewire)
  (append
   (pipewire-services)
   (wireplumber-services)))

(define (pipewire-services)
  (list
   (simple-service
    'pipewire-add-package
    home-profile-service-type
    (list pipewire-0.3))

   (simple-service
    'pipewire-add-shepherd-daemons
    home-shepherd-service-type
    (list
     (shepherd-service
      (provision '(pipewire))
      (start #~(make-forkexec-constructor
                (list #$(file-append pipewire-0.3 "/bin/pipewire"))
                #:log-file (string-append
                            (or (getenv "XDG_LOG_HOME")
                                (format #f "~a/.local/var/log"
                                        (getenv "HOME")))
                            "/pipewire.log")
                #:environment-variables
                (append (list "DISABLE_RTKIT=1")
                        (default-environment-variables))))
      (stop  #~(make-kill-destructor))
      (auto-start? #f))
     (shepherd-service
      (provision '(pipewire-pulse pulseaudio))
      (requirement '(pipewire pipewire-media-session))
      (start #~(make-forkexec-constructor
                (list #$(file-append pipewire-0.3 "/bin/pipewire-pulse"))
                #:log-file (string-append
                            (or (getenv "XDG_LOG_HOME")
                                (format #f "~a/.local/var/log"
                                        (getenv "HOME")))
                            "/pipewire-pulse.log")
                #:environment-variables
                (append (list "DISABLE_RTKIT=1")
                        (default-environment-variables))))
      (stop  #~(make-kill-destructor))
      (auto-start? #f))))

   (simple-service
    'pipewire-add-alsa-config
    home-xdg-configuration-files-service-type
    `(("alsa/asoundrc"
       ,(mixed-text-file
         "asoundrc"
         "<" (file-append pipewire-0.3 "/share/alsa/alsa.conf.d/50-pipewire.conf") ">" "\n"
         "<" (file-append pipewire-0.3 "/share/alsa/alsa.conf.d/99-pipewire-default.conf") ">" "\n"
         "\n"
         "pcm_type.pipewire {" "\n"
         "  lib " (file-append pipewire-0.3 "/lib/alsa-lib/libasound_module_pcm_pipewire.so") "\n"
         "}" "\n"
         "\n"
         "ctl_type.pipewire {" "\n"
         "  lib " (file-append pipewire-0.3 "/lib/alsa-lib/libasound_module_ctl_pipewire.so") "\n"
         "}" "\n"))))))
#+end_src
***** Wireplumber
#+begin_src scheme
(define (wireplumber-services)
  (list
   (simple-service
    'wireplumber-add-package
    home-profile-service-type
    (list wireplumber))

   (simple-service
    'wireplumber-add-shepherd-daemon
    home-shepherd-service-type
    (list
     (shepherd-service
      (provision '(wireplumber pipewire-media-session))
      (requirement '(pipewire))
      (start #~(make-forkexec-constructor
                (list #$(file-append wireplumber "/bin/wireplumber"))
                #:log-file (string-append
                            (or (getenv "XDG_LOG_HOME")
                                (format #f "~a/.local/var/log"
                                        (getenv "HOME")))
                            "/wireplumber.log")
                #:environment-variables
                (append (list "DISABLE_RTKIT=1")
                        (default-environment-variables))))
      (stop  #~(make-kill-destructor))
      (auto-start? #f))))))
#+end_src
**** Flatpak
#+begin_src scheme
(define (he-flatpak)
  (list
   (simple-service
    'flatpak-add-packages
    home-profile-service-type
    (list flatpak
          xdg-desktop-portal
          xdg-desktop-portal-wlr))))
#+end_src
***** Make Flatpak apps visible
TODO and remove "tangle no"
#+begin_src sh :tangle no
export XDG_DATA_DIRS=$HOME/.local/share/flatpak/exports/share:$XDG_DATA_DIRS
#+end_src
***** WIP Flatpak
TODO and remove "tangle no"
Ran these manually
#+begin_src sh :tangle no
flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

# flatpak install --user flathub com.spotify.Client
# flatpak install --user flathub us.zoom.Zoom
#+end_src
****** how to pin?
Some cursorily-googled intel:
- [[https://github.com/flatpak/flatpak/issues/3097][flatpak/flatpak#3097 Is there a way to install a specific version?]]
- [[https://discourse.flathub.org/t/install-an-older-version-of-an-app/320/3][Install an older version of an app - #3 by gjanssens - Flathub Discourse]]
**** Window managers
***** Sway
#+begin_src scheme
;; #:use-module (gnu system keyboard)
;;
;; (define (keyboard-layout-to-sway-config keyboard-layout)
;;   (let ((kb-options (string-join
;;                      (keyboard-layout-options keyboard-layout) ",")))
;;     `((input *
;;              ((xkb_layout  ,(keyboard-layout-name keyboard-layout))
;;               (xkb_variant ,(keyboard-layout-variant keyboard-layout))
;;               (xkb_options ,kb-options))))))

(define* (he-sway #:key
                  pipewire?
                  extra-config
                  (sway-mod 'Mod1)
                  ;; (add-keyboard-layout-to-config? #t)
                  (xwayland? #t)
                  (screen-locker "loginctl lock-session")
                  idle-manager
                  application-launcher
                  default-terminal
                  (backup-terminal default-terminal)
                  (bg-image (local-file "../../res/alucard_bg.png"))) ; TODO relative path is brittle

  (let* ((kb-layout #f ;; (get-value 'keyboard-layout config)
                    )
         (layout-config  (if (and #f ; add-keyboard-layout-to-config?
                                  kb-layout)
                             #f ; (keyboard-layout-to-sway-config kb-layout)
                             '())))
    (list
     (service
      home-sway-service-type
      (home-sway-configuration
       (package sway) ; TODO remove this line when I'm not using sway-latest any more
       (config
        `((xwayland ,(if xwayland? 'enable 'disable))
          (,#~"")
          ;; ,@layout-config ; TODO [sway-wip]

          (input type:keyboard
                 ((xkb_file ~/projects/phrenetic/ekskaybee.xkb)
                  (repeat_delay 250)
                  (repeat_rate 35)))
          (input type:touchpad
                 ((natural_scroll enabled)
                  (tap enabled)))

          (,#~"\n\n# General settings:")
          (set $mod ,sway-mod)
          (set $term ,default-terminal)
          (set $backup-term ,backup-terminal)
          (set $menu ,application-launcher)
          (set $lock ,screen-locker)

          (floating_modifier $mod normal)

          (bindsym --to-code $mod+Shift+r reload)

          (,#~"\n\n# Update dbus environment variables:")
          (exec ,(file-append dbus "/bin/dbus-update-activation-environment")
                WAYLAND_DISPLAY XDG_CURRENT_DESKTOP)

          (,#~"\n\n# Launching external applications:")
          (bindsym $mod+Control+Shift+Return exec $backup-term)
          (bindsym $mod+Return exec $term)

          (bindsym --to-code $mod+Shift+d exec $menu)
          (bindsym --to-code $mod+Control+Shift+l exec $lock)

          (,#~"\n\n# Manipulating windows:")
          (bindsym --to-code $mod+Shift+c kill)
          (bindsym --to-code $mod+Shift+f fullscreen)
          (bindsym $mod+Shift+space floating toggle)
          (bindsym $mod+Control+space focus mode_toggle)

          (bindsym $mod+h focus left)
          (bindsym $mod+j focus down)
          (bindsym $mod+k focus up)
          (bindsym $mod+l focus right)

          (bindsym $mod+Shift+h move left)
          (bindsym $mod+Shift+j move down)
          (bindsym $mod+Shift+k move up)
          (bindsym $mod+Shift+l move right)

          (,#~"\n\n# Moving around workspaces:")
          (bindsym $mod+tab workspace back_and_forth)
          ,@(append-map
             (lambda (x)
               `((bindsym ,(format #f "$mod+~a" (modulo x 10))
                          workspace number ,x)
                 (bindsym ,(format #f "$mod+Shift+~a" (modulo x 10))
                          move container to workspace number ,x)))
             (iota 10 1))

          (,#~"\n\n# Scratchpad settings:")
          (bindsym --to-code $mod+Shift+minus move scratchpad)
          (bindsym --to-code $mod+minus scratchpad show)

          (,#~"")
          (default_border pixel)
          (default_floating_border pixel)
          (gaps inner 8)

          (,#~"")
          (bindsym $mod+Shift+b splith)
          (bindsym $mod+Shift+v splitv)
          (bindsym $mod+Shift+s layout stacking)
          (bindsym $mod+Shift+w layout tabbed)
          (bindsym $mod+Shift+e layout toggle split)
          (bindsym $mod+Shift+a focus parent)
          (bindsym $mod+Shift+q exec ,(file-append sway "/bin/swaynag")
                   -t warning -m "'You pressed the exit shortcut. Do you really want to exit sway?'"
                   -b "'Yes, exit sway'" ,#~(format #f "'~a exit'" #$(file-append sway "/bin/swaymsg")))
          (gaps left 78) ; To accommodate the crack in my screen.
          ;; TODO probably put these in some more generic location. They're for any WM, just not e.g. Gnome
          (exec herd start pipewire)
          (exec herd start wireplumber)
          (exec herd start pipewire-pulse)))))

     (when idle-manager
       (simple-service
        'sway-enable-idle-manager
        home-sway-service-type
        `((,#~"")
          (exec ,idle-manager))))

     (simple-service
      'sway-add-brightness-control
      home-sway-service-type
      (let* ((step 10)
             (step->symbol (lambda (op)
                             (symbol-append (string->symbol (number->string step)) '% op)))
             (brightnessctl (file-append brightnessctl "/bin/brightnessctl")))
        `((bindsym --locked XF86MonBrightnessUp exec ,brightnessctl set ,(step->symbol '+))
          (bindsym --locked XF86MonBrightnessDown exec ,brightnessctl set ,(step->symbol '-)))))

     (simple-service
      'sway-add-audio-control
      home-sway-service-type
      ;; TODO what's are the "\\\n"s about? Probably will be clear once I see the generated file.
      ;; TODO maybe parameterize out the step value like in the brightness control code (with `step->symbol')
      (let ((pactl (file-append pulseaudio "/bin/pactl")))
        `((bindsym --locked XF86AudioRaiseVolume "\\\n"
                   exec ,pactl set-sink-mute @DEFAULT_SINK@ "false; \\\n"
                   exec ,pactl set-sink-volume @DEFAULT_SINK@ +5%)
          (bindsym --locked XF86AudioLowerVolume "\\\n"
                   exec ,pactl set-sink-mute @DEFAULT_SINK@ "false; \\\n"
                   exec ,pactl set-sink-volume @DEFAULT_SINK@ -5%)
          (bindsym --locked XF86AudioMute
                   exec ,pactl set-sink-mute @DEFAULT_SINK@ toggle)
          (bindsym --locked XF86AudioMicMute
                   exec ,pactl set-source-mute @DEFAULT_SOURCE@ toggle))))

     (simple-service
      'sway-add-player-controls
      home-sway-service-type
      (let ((playerctl (file-append playerctl "/bin/playerctl")))
        `((bindsym --locked XF86AudioPlay exec ,playerctl play-pause)
          (bindsym --locked XF86AudioPrev exec ,playerctl previous)
          (bindsym --locked XF86AudioNext exec ,playerctl next))))

     (when bg-image
       (simple-service
        'sway-add-bg-image
        home-sway-service-type
        `((output * bg ,bg-image fill))))

     (when extra-config
       (simple-service
        'sway-configuration
        home-sway-service-type
        `(,@extra-config
          (,#~""))))

     (simple-service
      'sway-reload-config-on-change
      home-run-on-change-service-type
      `(("files/.config/sway/config"
         ,#~(system* #$(file-append sway "/bin/swaymsg") "reload"))))

     (simple-service
      'xdg-desktop-portal-wlr-configuration
      home-xdg-configuration-files-service-type
      `(("xdg-desktop-portal-wlr/config"
         ,(mixed-text-file
           "xdg-desktop-portal-wlr-config"
           ;; TODO [sway-wip] do with newlines (note that I should string-join so it's still one arg to `format') (and do it for that sway-screenshot line too)
           ;; TODO [sway-wip] then comment this entire simple-service out.
           #~(format #f "[screencast]
output_name=
max_fps=30
chooser_cmd=~a -f %o -or -c ff0000
chooser_type=simple"
                     #$(file-append slurp "/bin/slurp"))))))

     (simple-service
      'packages-for-sway
      home-profile-service-type
      (list qtwayland ; Copied from RDE: I don't know what this is for.
            swayhide ; TODO I'm pretty sure this isn't required for anything. I'm keeping it around for now so I can try it out, though.
            xdg-desktop-portal
            xdg-desktop-portal-wlr))

     (simple-service
      'set-wayland-specific-env-vars
      home-environment-variables-service-type
      ;; Copied from RDE: I don't know what all of these do.
      (append
       '(("XDG_CURRENT_DESKTOP" . "sway")
         ("XDG_SESSION_TYPE" . "wayland")
         ("SDL_VIDEODRIVER" . "wayland")
         ("MOZ_ENABLE_WAYLAND" . "1")
         ("CLUTTER_BACKEND" . "wayland")
         ("ELM_ENGINE" . "wayland_egl")
         ("ECORE_EVAS_ENGINE" . "wayland-egl")
         ("QT_QPA_PLATFORM" . "wayland-egl")
         ("_JAVA_AWT_WM_NONREPARENTING" . "1"))
       (if pipewire?
           '(("RTC_USE_PIPEWIRE" . "true")) '())))

     (simple-service
      'packages-for-sway-fonts
      home-profile-service-type
      (list font-google-noto)) ; A font with good unicode coverage that should cover most needs.

     (sway-screenshot-service))))
#+end_src
****** TODO [#E] Conditionalize Sway environment variables
These should only be set for Sway and might mess up other sessions, like Gnome.
- check for the presence of =DESKTOP_SESSION=sway=?
- some (not particularly helpful) resources:
  - [[https://lists.sr.ht/~abcdw/rde-devel/%3C871qy1vtaz.fsf%40minikn.xyz%3E][{BUG} feature-sway breaks existing GNOME sessions  sourcehut lists]]
  - [[https://www.reddit.com/r/swaywm/comments/sw9lct/whats_the_recommended_way_of_setting_environment/][Whats the recommended way of setting environment variables? .profile doesnt w...]]
****** Sway screenshot
#+begin_src scheme
;; TODO [sway-wip] curious what the 303030AA are, wait until I've built the config to check what the finished command looks like. Update: it's a grey color with high opacity I think.
(define (sway-screenshot-service)
  (simple-service
   'sway-screenshot
   home-sway-service-type
   ;; TODO [sway-wip] change these keys? I don't have a Print key (or do I?)
   `((bindsym $mod+Print exec ,shot-output)
     (bindsym $mod+Control+Print exec ,swappy-clipboard)
     (bindsym $mod+Shift+Print exec ,shot-window-or-selection))))

(define subject-output
  #~(format #f "~a -t get_outputs | ~a -r '.[] | select(.focused) | .name'"
            #$(file-append sway "/bin/swaymsg")
            #$(file-append jq "/bin/jq")))

(define subject-window-or-selection
  #~(format #f "~a -t get_tree | ~a -r '.. | select(.pid? and .visible?) \
| .rect | \"\\(.x),\\(.y) \\(.width)x\\(.height)\"' | ~a -b ~a -B ~a"
            #$(file-append sway "/bin/swaymsg")
            #$(file-append jq "/bin/jq")
            #$(file-append slurp "/bin/slurp")
            "303030AA"
            "303030AA"))

(define* (shot-script subject #:key output geom (file "-"))
  (program-file
   (string-append "sway-shot-" subject)
   #~(system
      (format #f "~a ~a~a~a | ~a"
              #$(file-append grim "/bin/grim")
              #$(if output #~(string-append "-o \"$(" #$output ")\" ") "")
              #$(if geom #~(string-append "-g \"$(" #$geom ")\" ") "")
              #$file
              #$(file-append wl-clipboard "/bin/wl-copy")))))

(define shot-output
  (shot-script "output" #:output subject-output))

(define shot-window-or-selection
  (shot-script "window-or-selection" #:geom subject-window-or-selection))

(define swappy-clipboard
  (program-file
   "sway-swappy-clipboard"
   #~(system
      (format #f "~a | ~a -f -"
              #$(file-append wl-clipboard "/bin/wl-paste")
              #$(file-append swappy "/bin/swappy")))))
#+end_src
**** Screen lockers
***** Swaylock
#+begin_src scheme
(define* (he-swaylock #:key
                      (swaylock-effects? #t)
                      extra-config)
  (list
   (service
    home-swaylock-service-type
    (home-swaylock-configuration
     (swaylock (if swaylock-effects?
                   swaylock-effects
                   swaylock))
     (config
      `((show-failed-attempts . #t)
        (daemonize . #t)
        ;; (show-keyboard-layout . ,show-keyboard-layout?) ; TODO [sway-wip]
        ;; TODO [sway-wip] Andrew Tropin: TODO: Source color from colorscheme
        (color . 3e3e3e)
        (indicator-caps-lock)
        ,@(if extra-config
              extra-config '())))))))

(define (swaylock-screen-locker)
  "/run/setuid-programs/swaylock") ; According to Andrew Tropin, this can be changed to a store path once https://issues.guix.gnu.org/53468 is resolved.
#+end_src
**** Idle managers
***** Swayidle
#+begin_src scheme
(define* (he-swayidle #:key
                      sway?
                      screen-locker
                      (lock-timeout 300)
                      extra-config)
  (list
   (service
    home-swayidle-service-type
    (home-swayidle-configuration
     (config
      `(,@(if screen-locker
              (let ((lock-cmd-quoted (format #f "'~a'" screen-locker)))
                `((lock ,lock-cmd-quoted)
                  (before-sleep ,lock-cmd-quoted)
                  (timeout ,lock-timeout ,lock-cmd-quoted)))
              '())
        ,@(if extra-config
              extra-config '())))))

   (when sway?
     (let* ((swaymsg (file-append sway "/bin/swaymsg"))
            (swaymsg-cmd (lambda (cmd)
                           #~(format #f "'~a \"~a\"'" #$swaymsg #$cmd)))
            (idle-timeout (+ lock-timeout 30)))
       (simple-service
        'swayidle-add-sway-dpms
        home-swayidle-service-type
        `((timeout ,idle-timeout ,(swaymsg-cmd "output * dpms off") resume ,(swaymsg-cmd "output * dpms on"))))))))

(define (swayidle-idle-manager)
  (file-append swayidle "/bin/swayidle -w"))
#+end_src
**** Status bars
***** Waybar
#+begin_src scheme
(define* (he-waybar #:key
                    sway?
                    (waybar-modules
                     (list
                      ;; TODO [sway-wip] conditionalize the sway ones?
                      (waybar-sway-workspaces)
                      ;; (waybar-sway-window)
                      (waybar-tray)
                      (waybar-idle-inhibitor)
                      ;; (waybar-temperature)
                      (waybar-sway-language)
                      (waybar-battery)
                      (waybar-clock)))
                    (base16-css (local-file "base16-default-dark.css"))
                    font
                    transitions?)
  (append
   (list
    (service
     home-waybar-service-type
     (home-waybar-configuration
      (config #(((position . top)
                 (name . main))))
      ;; TODO [sway-wip] Andrew Tropin: TODO: fix tray menu styles.
      (style-css
       `(,#~(format #f "@import \"~a\";\n" #$base16-css)
            (*
             ((font-family . #(,@(if font
                                     (list
                                      (-> font (assoc-ref #:font/name) string->symbol))
                                     '())
                               FontAwesome))
              ,@(if transitions? '() '((transition . none)))
              (box-shadow . none)
              (text-shadow . none)
              (min-height . 0)))

            (tooltip
             ((border . (solid @base02))
              (background . @base01)
              (opacity . 0.9)))

            ((tooltip label)
             ((color . @base05)
              (padding . 0)))

            (#{#waybar}#
             ((color . @base04)
              (background . @base01)))

            (#((.modules-right label)
               (.modules-right image))
             ((margin . (0.4em 0.2em))
              (padding . (0 0.4em))
              (background . @base02)
              (border-radius . 0.2em)))

            (.modules-left
             ((margin-left . 0.2em)))

            (.modules-right
             ((margin-right . 0.2em))))))))

   waybar-modules

   (list
    (simple-service
     'waybar-add-font-package
     home-profile-service-type
     (list font-awesome))

    (simple-service
     'waybar-reload-config-on-change
     home-run-on-change-service-type
     ;; TODO [sway-wip] factor out the command
     `(("files/.config/waybar/style.css"
        ,#~(system* #$(file-append psmisc "/bin/killall") "-SIGUSR2" "waybar"))
       ("files/.config/waybar/config"
        ,#~(system* #$(file-append psmisc "/bin/killall") "-SIGUSR2" "waybar"))))

    ;; I could pass the waybar command to the sway module (like I do with the screen locker and idle manager) instead of making this module aware of Sway, however the the `bar' command can take other arguments (see https://man.archlinux.org/man/sway-bar.5.en) that I might perhaps need in the future (though I think they only apply to swaybar, not waybar).
    (when sway?
      (simple-service
       'waybar-add-to-sway
       home-sway-service-type
       `((bar swaybar_command ,(file-append waybar "/bin/waybar"))
         (bindsym $mod+backslash exec ,(file-append psmisc "/bin/killall") -SIGUSR1 waybar)))))))
#+end_src
****** Base16 CSS
#+begin_src css :tangle (meta-in-dir "base16-default-dark.css")
@define-color base00 #181818;
@define-color base01 #282828;
@define-color base02 #383838;
@define-color base03 #585858;
@define-color base04 #b8b8b8;
@define-color base05 #d8d8d8;
@define-color base06 #e8e8e8;
@define-color base07 #f8f8f8;
@define-color base08 #ab4642;
@define-color base09 #dc9656;
@define-color base0A #f7ca88;
@define-color base0B #a1b56c;
@define-color base0C #86c1b9;
@define-color base0D #7cafc2;
@define-color base0E #ba8baf;
@define-color base0F #a16946;
#+end_src
****** Modules
#+begin_src scheme
(define* (waybar-module name
                        #:optional
                        config
                        style
                        #:key
                        (placement 'modules-right)
                        (bar-id 'main))
  (simple-service
   (symbol-append 'waybar-module- name)
   home-waybar-service-type
   (home-waybar-extension
    (config `#(((name . ,bar-id)
                (,placement . #(,name))
                (,name . ,(if config
                              config '())))))
    (style-css (if style
                   style '())))))

(define (waybar-sway-language)
  (waybar-module 'sway/language))

(define (waybar-sway-window)
  (waybar-module
   'sway/window
   `()
   `((#{#window}#
      ((margin-left . 1em)
       (margin-right . 1em))))
   #:placement 'modules-center))

(define* (waybar-sway-workspaces
          #:key
          persistent-workspaces
          (format-icons '(("1" . )
                          ("2" . )
                          ("3" . )
                          ("4" . )
                          ("6" . ) ; 
                          ("7" . ) ; 
                          ("8" . )
                          ("9" . )
                          ("10" . )

                          ("urgent" . )
                          ("focused" . )
                          ("default" . ))))
  (waybar-module
   'sway/workspaces
   `((disable-scroll . #t)
     (format . {icon})
     ;; TODO [sway-wip] Andrew Tropin: FIXME: Height becomes higher when icons are not used.
     (format-icons . ,format-icons)
     (persistent_workspaces . ,(if persistent-workspaces
                                   persistent-workspaces '())))
   `(((#{#workspaces}# button)
      ((background . none)
       (border-radius . 0.2em)
       (margin . (0.4em 0.2em))
       (padding . (0.1em 0.2em))
       (color . @base05)))

     ((#{#workspaces}# button:hover)
      ((background . none)
       (border-color . @base07)))

     ((#{#workspaces}# button.focused)
      ((background . @base02)
       (color . @base07)))

     ((#{#workspaces}# button.urgent)
      ((color . @base08))))
   #:placement 'modules-left))

(define (waybar-tray)
  (waybar-module
   'tray
   `()
   `(((#{#tray}# menu)
      ((color . @base05)
       (background . @base01)
       (border . (solid 1px))
       (border-color . @base02)))

     ((#{#tray}# menu menuitem)
      ((padding-top . 0px)
       (padding-bottom . 0px)
       (margin-top . 0.1em)
       (margin-bottom . 0em)))

     ((#{#tray}# menu menuitem:hover)
      ((background . none)))

     ((#{#tray}# menu separator)
      ((background . @base03)
       (padding-top . 1px)
       (margin-top . 0.2em)
       (margin-bottom . 0.2em))))))

(define (waybar-temperature)
  (waybar-module 'temperature))

(define (waybar-idle-inhibitor)
  (waybar-module
   'idle_inhibitor
   '((format . {icon})
     (format-icons . ((activated . )
                      (deactivated . ))))))

(define* (waybar-clock #:key
                       (format "{:%Y-%m-%d %H:%M}")
                       timezone)
  ;; (define emacsclient (get-value 'emacs-client config))
  ;; (define (emacsclient-cmd command)
  ;;   #~(format #f "\"~a --eval \\\"(~a)\\\"\"" #$emacsclient #$command))
  (waybar-module
   'clock
   `((tooltip-format . "<big>{:%Y %B}</big>\n<tt><small>{calendar}</small></tt>")
     ,@(if timezone
           `((timezone . ,timezone)) '())
     (format . ,format)
     ;; ,@(if emacsclient
     ;;       `((on-click . ,(emacsclient-cmd "world-clock"))
     ;;         (on-click-right . ,(emacsclient-cmd "calendar")))
     ;;       '())
     )))

(define (waybar-battery)
  (waybar-module
   'battery
   `((format . "{capacity}% {icon}")
     (format-charging . ,(format #f "{capacity}~a {icon}" ""))
     (states . ((empty . 10)
                (low . 20)
                (half-low . 40)
                (half . 60)
                (high . 90)
                (full . 100)))
     (format-icons . ((empty . )
                      (low . )
                      (half-low . )
                      (half . )
                      (high . )
                      (full . ))))
   `((#{#battery.discharging.empty}#
      ,(if #f ; TODO [sway-wip] was `intense?'
           `((color . @base02)
             (background . @base08))
           `((color . @base08))))
     (#{#battery.discharging.low}#
      ,(if #f ; TODO [sway-wip] was `intense?'
           `((color . @base02)
             (background . @base09))
           `((color . @base09)))))))
#+end_src
**** Application launchers
***** Rofi
#+begin_src scheme
(define* (he-rofi #:key
                  wayland?
                  (theme "Arc-Dark"))
  (list
   (service
    home-rofi-service-type
    (home-rofi-configuration
     (rofi (get-rofi wayland?))
     ;; TODO Trying out Andrew Tropin's confguration as-is for now, revisit later.
     (config-rasi
      `((configuration
         ((modi . "run,ssh,drun")
          (drun-show-actions . #t)
          (show-icons . #t)
          (kb-row-tab . "")
          (kb-row-select . "Tab")
          (kb-secondary-paste . "Control+y")
          (kb-remove-word-forward . "Alt+d")
          (kb-remove-word-back . "Control+w,Control+BackSpace")
          (kb-clear-line . "Control+slash")
          (kb-page-next . "Control+v")
          (kb-page-prev . "Alt+v")))
        ,#~(format #f "@theme \"~a\"" #$theme)))))))

(define* (rofi-application-launcher #:key wayland?)
  (file-append (get-rofi wayland?) "/bin/rofi -show drun"))

(define (get-rofi wayland?)
  (if wayland?
      rofi-wayland
      rofi))
#+end_src
**** Terminals
***** Alacritty
#+begin_src scheme
(define* (he-alacritty #:key
                       font
                       config-file) ; (config-file (local-file "alacritty.yml"))
  (list
   (service
    home-alacritty-service-type
    (home-alacritty-configuration
     (config
      ;; TODO keeping this padding thing here for now, revisit it later
      `((window . ((padding . ((x . 10)
                               (y . 5)))))
        ,@(if font
              `((font . ((normal . ((style . , (font-weight->style
                                                (assoc-ref font #:font/weight)))
                                    (family . ,(assoc-ref font #:font/name))))
                         (size . ,(assoc-ref font #:font/size)))))
              '())
        ,@(if config-file
              `((import . #(,config-file)))
              '())))))))

(define (font-weight->style weight)
  (->> weight
       symbol->string
       (string-delete #\-)
       string-capitalize))

(define (alacritty-terminal)
  (file-append alacritty "/bin/alacritty"))
#+end_src
**** Applets
***** Gammastep
- TODO broken tray icon. Probably I need to have some part of the =gammastep= package on the path so it can find the icon. Don't worry about this for now, maybe there will be some way to tell =papirus-icon-theme= to use a different icon or something.
#+begin_src scheme
(define (gammastep-shepherd-service _)
  (list
   (shepherd-service
    (provision '(gammastep-applet))
    (respawn? #f)
    (start #~(lambda (wayland-display . _)
               ((make-forkexec-constructor
                 (list #$(file-append gammastep "/bin/gammastep-indicator") "-l 44:-123")
                 #:environment-variables
                 ;; (list (string-append "WAYLAND_DISPLAY=" wayland-display))
                 (call-with-input-file "/tmp/env-for-applets" read)))))
    (stop #~(make-kill-destructor))
    (auto-start? #f))))

(define gammastep-applet-service-type
  (service-type (name 'he-gammastep-applet)
                (extensions
                 (list (service-extension
                        home-shepherd-service-type
                        gammastep-shepherd-service)))
                (default-value #f)
                (description "Gammastep applet.")))
#+end_src
***** Network Manager
#+begin_src scheme
(define (network-manager-shepherd-service _)
  (list
   (shepherd-service
    (provision '(nm-applet))
    (respawn? #f)
    (start #~(lambda (wayland-display . _)
               ((make-forkexec-constructor
                 (list #$(file-append network-manager-applet "/bin/nm-applet") "--indicator")
                 #:environment-variables
                 ;; (list (string-append "WAYLAND_DISPLAY=" wayland-display))
                 (call-with-input-file "/tmp/env-for-applets" read)))))
    (stop #~(make-kill-destructor))
    (auto-start? #f))))

(define network-manager-applet-service-type
  (service-type (name 'he-network-manager-applet)
                (extensions
                 (list (service-extension
                        home-shepherd-service-type
                        network-manager-shepherd-service)))
                (default-value #f)
                (description "Network manager applet.")))
#+end_src
***** Udiskie
#+begin_src scheme
(define (udiskie-shepherd-service _)
  (list
   (shepherd-service
    (provision '(udiskie-applet))
    (respawn? #f)
    (start #~(lambda (wayland-display . _)
               ((make-forkexec-constructor
                 (list #$(file-append udiskie "/bin/udiskie")
                       "--tray"
                       ;; (string-append "--file-manager="
                       ;;                #$(file-append xdg-utils "/bin/xdg-open"))
                       )
                 #:environment-variables
                 ;; (list (string-append "WAYLAND_DISPLAY=" wayland-display))
                 (call-with-input-file "/tmp/env-for-applets" read)))))
    (stop #~(make-kill-destructor))
    (auto-start? #f))))

(define udiskie-applet-service-type
  (service-type (name 'he-udiskie-applet)
                (extensions
                 (list (service-extension
                        home-shepherd-service-type
                        udiskie-shepherd-service)))
                (default-value #f)
                (description "Udiskie applet.")))
#+end_src
** Base HE
#+begin_src scheme :tangle (meta-in-dir "base-he.scm")
(define-module (ebullient home base-he)
  #:use-module (gnu home)
  #:use-module (gnu services)
  #:use-module (ebullient home components)
  #:use-module (ebullient utils)
  #:export (base-he))

(define* (base-he #:key
                  full-name
                  email
                  (login-shell #:shell/bash)
                  developer?
                  (interactive-shell (if developer?
                                         #:shell/zsh login-shell))
                  nix?
                  desktop?
                  pipewire?
                  sessions)
  (home-environment
   (services
    (filter
     service?
     (let ((font-mono font-monospace))
       (append
        (he-packages)
        (he-shells #:login-shell login-shell
                   #:interactive-shell interactive-shell)
        (he-fonts #:fonts (list font-mono))
        (if nix?
            (he-nix) '())
        (if developer?
            (append
             (he-emacs #:zsh-vterm? (eq? interactive-shell #:shell/zsh))
             (he-doom #:full-name full-name
                      #:email email
                      #:font font-mono)
             (he-git #:full-name full-name
                     #:email email)
             (he-ssh)
             (he-direnv #:shell interactive-shell))
            '())
        (if desktop?
            (append
             (he-desktop-packages)
             (he-xdg)
             (if pipewire?
                 (he-pipewire) '())
             (he-flatpak)
             (if (member #:session/sway (or sessions '()))
                 (let ((screen-locker (swaylock-screen-locker)))
                   (append
                    (he-sway #:pipewire? pipewire?
                             #:screen-locker screen-locker
                             #:idle-manager (swayidle-idle-manager)
                             #:application-launcher (rofi-application-launcher #:wayland? #t)
                             #:default-terminal (alacritty-terminal)
                             ;; #:backup-terminal (alacritty-terminal)
                             )
                    (he-swaylock)
                    (he-swayidle #:sway? #t
                                 #:screen-locker screen-locker)
                    (he-waybar #:sway? #t
                               #:font font-mono)
                    (he-rofi #:wayland? #t)
                    (he-alacritty #:font font-mono)
                    ;; TODO probably put these in some more generic location. They're for any WM, just not e.g. Gnome
                    ;; (list
                    ;;  (service gammastep-applet-service-type)
                    ;;  (service network-manager-applet-service-type)
                    ;;  (service udiskie-applet-service-type))
                    ))
                 '()))
            '())))))))
#+end_src
* Union
#+begin_src scheme :tangle (meta-in-dir "ebullient/union.scm")
(define-module (ebullient union)
  #:use-module (gnu services)
  #:use-module (gnu services home)
  #:use-module (gnu system)
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:export (union))

(define* (union #:key
                os
                hes)
  (operating-system
    (inherit os)
    (services
     (append
      (operating-system-user-services os)
      (map
       (match-lambda
         ((user . he)
          (service guix-home-service-type `((,user . ,he)))))
       hes)))))
#+end_src
* Utils
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "ebullient/utils.scm")
:END:
#+begin_src scheme
(define-module (ebullient utils)
  #:use-module (guix git-download)
  #:use-module ((guix inferior) #:select (inferior-for-channels lookup-inferior-packages))
  #:use-module (guix packages)
  #:use-module (gnu services)
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:use-module ((srfi srfi-1) #:select (take drop remove fold first append-map))
  #:export (update-list
            when-let
            if-let
            when-not
            if-not
            ->
            ->>
            as->
            keyvals
            update-services*
            update-services
            ;; get-inferior-package
            with-git-version
            with-git-commit
            with-git-url))

(define (update-list l pred f)
  (map (lambda (x)
         (if (pred x) (f x) x))
       l))
#+end_src
** Branching
#+begin_src scheme
(define-syntax when-let
  (syntax-rules ()
    ((_ ((var expr)) body ...)
     (let ((var expr))
       (when var body ...)))))

(define-syntax if-let
  (syntax-rules ()
    ((_ ((var expr)) then else)
     (let ((var expr))
       (if var then else)))))

(define-syntax when-not
  (syntax-rules ()
    ((_ test body ...)
     (when (not test) body ...))))

(define-syntax if-not
  (syntax-rules ()
    ((_ test then else)
     (if (not test) then else))))
#+end_src
** Functions
#+begin_src scheme
(define-syntax ->
  (syntax-rules ()
    ((_ x) x)
    ((_ x (f args ...) expr ...) (-> (f x args ...) expr ...))
    ((_ x f expr ...) (-> (f x) expr ...))))

(define-syntax ->>
  (syntax-rules ()
    ((_ x) x)
    ((_ x (f args ...) expr ...) (->> (f args ... x) expr ...))
    ((_ x f expr ...) (->> (f x) expr ...))))

(define-syntax as->
  (lambda (x)
    (syntax-case x ()
      ((_ exp name) #'exp)
      ((_ exp name form form* ...)
       (with-syntax ((x (datum->syntax #'form (syntax->datum #'name))))
         #'(let ((x exp))
             (as-> form name form* ...)))))))
#+end_src
** Association lists
#+begin_src scheme
(define (keyvals x)
  (append-map
   (match-lambda
     ((k . v)
      (list k v)))
   x))
#+end_src
** Guix
#+begin_src scheme
(define (update-services* services pred update-fn)
  (update-list
   services
   pred
   (lambda (svc)
     (service (service-kind svc)
              (update-fn (service-value svc))))))

(define (update-services services kind update-fn)
  (update-services*
   services
   (lambda (svc)
     (eq? (service-kind svc) kind))
   update-fn))

;; (define (get-inferior-package channels package)
;;   (-> (inferior-for-channels channels)
;;       (lookup-inferior-packages package)
;;       first))

(define* (with-git pkg
                   #:key
                   upstream-version
                   revision
                   commit
                   hash)
  (package
    (inherit pkg)
    (version (if revision
                 (git-version upstream-version revision commit)
                 upstream-version))
    (source
     (origin
       (inherit (package-source pkg))
       (uri (git-reference
             (inherit (-> pkg package-source origin-uri))
             (commit commit)))
       (sha256
        (base32
         hash))
       (file-name (git-file-name (package-name pkg) version))))))

(define* (with-git-version pkg #:key version commit hash)
  (with-git pkg
            #:upstream-version version
            #:commit commit
            #:hash hash))

(define* (with-git-commit pkg #:key (revision "0") commit hash)
  (with-git pkg
            #:upstream-version (package-version pkg)
            #:revision revision
            #:commit commit
            #:hash hash))

(define (with-git-url pkg url)
  (package
    (inherit pkg)
    (source
     (origin
       (inherit (package-source pkg))
       (uri (git-reference
             (inherit (-> pkg package-source origin-uri))
             (url url)))))))
#+end_src
* Auxillary
:PROPERTIES:
:meta-dir+: /penitent
:END:
** Packages
:PROPERTIES:
:meta-dir+: /packages
:END:
*** AWS CLI :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "aws.scm")
:END:
- TODO
  - generate the autocompletion index
    As described here:
    [[https://github.com/aws/aws-cli/tree/v2#cli-dev-version][GitHub - aws/aws-cli at v2 (cli dev version)]]
    [[https://github.com/NixOS/nixpkgs/blob/nixos-unstable/pkgs/tools/admin/awscli2/default.nix#L95][nixpkgs/default.nix at nixos-unstable  NixOS/nixpkgs  GitHub]]
  - set up command completion
    [[https://github.com/aws/aws-cli/tree/v2#command-completion][GitHub - aws/aws-cli at v2 (command completion)]]
  - [2022-04-13 Wed] dependencies don't need to be propagated?
    [[https://github.com/guix-mirror/guix/commit/fc89b50b7bb2edbc38b20adf8c899934dedcb6c3][gnu: awscli: Do not propagate inputs.  guix-mirror/guix@fc89b50  GitHub]]
    This is for v1, might not apply here. At the time of this writing, this commit is only two hours old, see if there's any follow-up.
#+begin_src scheme
(define-module (penitent packages aws)
  #:use-module (guix build-system python)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages check) #:select (python-mock python-pytest python-coverage python-pytest-cov python-pytest-xdist))
  #:use-module ((gnu packages cmake) #:select (cmake))
  #:use-module ((gnu packages groff) #:select (groff))
  #:use-module ((gnu packages python-web) #:select (awscli) #:prefix python-web:)
  #:use-module ((gnu packages python-web) #:select (python-urllib3))
  #:use-module ((gnu packages python-xyz) #:select (python-prompt-toolkit) #:prefix python:)
  #:use-module ((gnu packages python-xyz) #:select (python-colorama-for-awscli python-docutils-0.15 python-wcwidth python-distro python-jmespath python-boto3 python-botocore python-six python-jsonschema))
  #:use-module ((gnu packages python-crypto) #:select (python-cryptography) #:prefix python-crypto:)
  #:use-module ((gnu packages serialization) #:select (python-ruamel.yaml))
  #:use-module ((gnu packages time) #:select (python-dateutil)))

(define-public awscli
  (package
    (inherit python-web:awscli)
    (version "2.4.23")
    (source
     (origin
       (method git-fetch)
       (uri (git-reference
             (url "https://github.com/aws/aws-cli")
             (commit version)))
       (sha256
        (base32
         "1xdgj6w6ibfiwpzd85g9lhk106nxrw06c9bdcrmfr68zaa32k6ff"))
       (file-name (git-file-name (package-name python-web:awscli) version))))
    (arguments
     (substitute-keyword-arguments (package-arguments python-web:awscli)
       ;; A few tests fail at present but I'm not gonna sweat it. A number more error but I think that's mostly due to the lack of network access. The vast majority pass:
       ;; Total tests ~7000 (failures=3, errors=222, skipped=6)
       ((#:tests? _) #f)))
    (propagated-inputs
     (list python-colorama-for-awscli
           python-docutils-0.15
           python-cryptography
           python-ruamel.yaml-0.15
           python-wcwidth
           python-prompt-toolkit
           python-distro-1.5
           python-awscrt
           python-dateutil
           python-jmespath
           python-urllib3))
    (native-inputs
     (list groff
           ;; For tests.
           python-jsonschema
           python-mock
           python-pytest
           python-coverage
           python-pytest-cov
           python-pytest-xdist))))
#+end_src
**** Deps :package:version:
#+begin_src scheme
(define python-awscrt
  (package
    (name "python-awscrt")
    (version "0.12.4")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "awscrt" version))
       (sha256
        (base32 "1cmfkcv2zzirxsb989vx1hvna9nv24pghcvypl0zaxsjphv97mka"))))
    (build-system python-build-system)
    (native-inputs
     (list
      cmake
      ;; For tests.
      python-boto3))
    (home-page "https://github.com/awslabs/aws-crt-python")
    (synopsis "A common runtime for AWS Python projects")
    (description "This package provides a common runtime for AWS Python projects")
    (license license:asl2.0)))

(define python-cryptography
  (package
    (inherit python-crypto:python-cryptography)
    (version "3.3.2")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "cryptography" version))
       (sha256
        (base32
         "1vcvw4lkw1spiq322pm1256kail8nck6bbgpdxx3pqa905wd6q2s"))))))

(define python-ruamel.yaml-0.15
  (package
    (inherit python-ruamel.yaml)
    (version "0.15.100")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "ruamel.yaml" version))
       (sha256
        (base32
         "1r5j9n2jdq48z0k4bdia1f7krn8f2x3y49i9ba9iks2rg83g6hlf"))))))

(define python-prompt-toolkit
  (package
    (inherit python:python-prompt-toolkit)
    (version "3.0.28")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "prompt_toolkit" version))
       (sha256
        (base32
         "0l0nnm9fvs8lklk2qq8mylb9jrlxvlqzpmqr4n7rdhl63rmx274z"))))))

(define python-distro-1.5
  (package
    (inherit python-distro)
    (version "1.5.0")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "distro" version))
       (sha256
        (base32
         "14nz51cqlnxmgfqqilxyvjwwa5xfivdvlm0d0b1qzgcgwdm7an0f"))))))
#+end_src
*** Datomic CLI tools :package:version:
- TODO =bin/datomic= introduces a dependency (~com.datomic/tools.ops~)
  Is that something I'd want to include in the package or whatever?
#+begin_src scheme :tangle (meta-in-dir "datomic.scm")
(define-module (penitent packages datomic)
  #:use-module (guix build-system copy)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((gnu packages compression) #:select (unzip))
  #:use-module ((nonguix licenses) #:prefix license:))

(define-public datomic-cli-tools
  (package
    (name "datomic-cli-tools")
    (version "1.0.91")
    (source
     (origin
       (method url-fetch)
       (uri (string-append "https://datomic-releases-1fc2183a.s3.amazonaws.com/tools/datomic-cli/datomic-cli-" version ".zip"))
       (sha256
        (base32
         "1xicmbsig8f1p5r9rxkhndi0f9l9w421zf49rbx44yc6v0db523b"))))
    (build-system copy-build-system)
    (arguments
     `(#:install-plan
       '(("." "bin" #:include-regexp ("^\\./datomic")) ; Files that start with "datomic" are the scripts. Restrict to this subset to automatically pick up any added in the future without being too inclusive about what we add to bin.
         ("README.txt" "share/doc/datomic/"))
       #:phases
       ,#~(modify-phases %standard-phases
            (add-after 'install 'make-scripts-executable
              (lambda _
                (for-each (lambda (f) (chmod f #o555))
                          (find-files (string-append #$output "/bin"))))))))
    (native-inputs
     (list unzip))
    (home-page "https://docs.datomic.com/cloud/index.html")
    (synopsis "CLI tools for Datomic")
    (description synopsis)
    (license (license:nonfree "https://www.datomic.com/cloud-eula.html"))))
#+end_src
*** Clojure
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "clojure.scm")
:END:
**** =man= pages :upstream:
#+begin_src scheme
(define-module (penitent packages clojure)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages clojure) #:select (clojure-tools) #:prefix clojure:))

(define (with-man-pages clojure-tools)
  (package
    (inherit clojure-tools)
    (arguments
     (substitute-keyword-arguments (package-arguments clojure-tools)
       ((#:install-plan install-plan)
        #~(append #$install-plan '(("clojure.1" "/share/man/man1/")
                                   ("clj.1" "/share/man/man1/"))))))))

(define-public clojure-tools-with-man-pages
  (with-man-pages clojure:clojure-tools))
#+end_src
* Configurations
:PROPERTIES:
:meta-dir+: /exuberant
:END:
** Frostfire
#+begin_src scheme :tangle (meta-in-dir "frostfire.scm") :noweb yes
(define-module (exuberant frostfire)
  #:use-module (ebullient home base-he)
  #:use-module (ebullient system base-os)
  #:use-module (ebullient union)
  #:export (os
            primary-he
            aux-he
            guest-he))

(define nix? #t)
(define desktop? #t)
(define pipewire? #t)

(define primary-name "pharcosyle")
(define primary-full-name "Krzysztof Baranowski")
(define aux-name "pcoulson")
(define aux-full-name "Phil Coulson")
(define guest-name "gandalf")

(define os
  (base-os #:host-name "frostfire"
           #:timezone "America/Los_Angeles"
           #:users `(((#:name . ,primary-name)
                      (#:comment . ,primary-full-name)
                      (#:admin? . #t))
                     ((#:name . ,aux-name)
                      (#:comment . ,aux-full-name)
                      (#:admin? . #t))
                     ((#:name . ,guest-name)
                      (#:comment . "Speak Friend and Enter")
                      (#:password . "mellon")))
           ;; #:auto-login "pharcosyle" ; REVIEW Enable this later.
           #:disk-encryption? #t
           #:luks-uuid "<<frostfire-luks-uuid>>"
           #:stateless? #t
           #:nix? nix?
           #:console? #t
           #:desktop? desktop?
           #:pipewire? pipewire?
           #:bluetooth? #t
           #:sessions '(#:session/gnome
                        #:session/sway)
           #:laptop? #t
           #:macbook? #t))

(define primary-he
  (base-he #:full-name primary-full-name
           #:email "pharcosyle@gmail.com"
           #:developer? #t
           #:nix? nix?
           #:desktop? desktop?
           #:pipewire? pipewire?
           #:sessions '(#:session/sway)))

(define aux-he
  (base-he #:full-name aux-full-name
           #:email "pharcosyle+phil_coulson@gmail.com"
           #:developer? #t
           #:nix? nix?
           #:desktop? desktop?
           #:pipewire? pipewire?
           #:sessions '(#:session/sway)))

(define guest-he
  (base-he #:desktop? desktop?
           #:pipewire? pipewire?))

(define frostfire
  (union #:os os
         #:hes `(;; (,primary-name . ,primary-he)
                 (,aux-name . ,aux-he)
                 ;; (,guest-name . ,guest-he)
                 )))
#+end_src
*** LUKS UUID :external_state:
#+name: frostfire-luks-uuid
#+begin_src org
bdda56af-6ca0-4953-bc13-d5af8715e0e5
#+end_src
*** Channels
#+begin_src scheme :tangle (meta-in-dir "channels")
(list (channel
        (name 'guix)
        (url "https://git.savannah.gnu.org/git/guix.git")
        (introduction
          (make-channel-introduction
            "9edb3f66fd807b096b48283debdcddccfea34bad"
            (openpgp-fingerprint
              "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA"))))
      (channel
        (name 'flat)
        (url "https://github.com/flatwhatson/guix-channel.git")
        (introduction
          (make-channel-introduction
            "33f86a4b48205c0dc19d7c036c85393f0766f806"
            (openpgp-fingerprint
              "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490"))))
      (channel
        (name 'rde)
        (url "https://git.sr.ht/~abcdw/rde")
        (introduction
          (make-channel-introduction
            "257cebd587b66e4d865b3537a9a88cccd7107c95"
            (openpgp-fingerprint
              "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
      (channel
        (name 'nonguix)
        (url "https://gitlab.com/nonguix/nonguix")
        (introduction
          (make-channel-introduction
            "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
            (openpgp-fingerprint
              "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5")))))

;; (cons* (channel
;;         (name 'phrenetic)
;;         (url "https://github.com/pharcosyle/phrenetic")
;;         (branch "tangled"))
;;        %default-channels)

;; (cons* (channel
;;         (name 'phrenetic)
;;         (url "file:///home/pharcosyle/projects/phrenetic")
;;         (branch "tangled"))
;;        %default-channels)
#+end_src
*** Channels lock :version:
#+begin_src scheme :tangle (meta-in-dir "channels-lock")
(list (channel
        (name 'guix)
        (url "https://git.savannah.gnu.org/git/guix.git")
        (branch "master")
        (commit
          "04ac1a248c188e4e49e6372e8336c31d32d1c96e")
        (introduction
          (make-channel-introduction
            "9edb3f66fd807b096b48283debdcddccfea34bad"
            (openpgp-fingerprint
              "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA"))))
      (channel
        (name 'flat)
        (url "https://github.com/flatwhatson/guix-channel.git")
        (branch "master")
        (commit
          "ece373bcd1e00ef746fb7b104e56ab610cc4af2a")
        (introduction
          (make-channel-introduction
            "33f86a4b48205c0dc19d7c036c85393f0766f806"
            (openpgp-fingerprint
              "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490"))))
      (channel
        (name 'rde)
        (url "https://git.sr.ht/~abcdw/rde")
        (branch "master")
        (commit
          "520e1429593c2daf4a296a9ea55c4aa32848b491")
        (introduction
          (make-channel-introduction
            "257cebd587b66e4d865b3537a9a88cccd7107c95"
            (openpgp-fingerprint
              "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
      (channel
        (name 'nonguix)
        (url "https://gitlab.com/nonguix/nonguix")
        (branch "master")
        (commit
          "35533c763a81365e14d0b58ad262e8f88c82872c")
        (introduction
          (make-channel-introduction
            "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
            (openpgp-fingerprint
              "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
      ;; (channel
      ;;   (name 'phrenetic)
      ;;   (url "https://github.com/pharcosyle/phrenetic")
      ;;   (branch "tangled")
      ;;   (commit
      ;;     "6ace11ddf9e03eefa85495ab5463e0a000240587"))
      ;; (channel
      ;;   (name 'phrenetic)
      ;;   (url "file:///home/pharcosyle/projects/phrenetic")
      ;;   (branch "tangled")
      ;;   (commit
      ;;     "6ace11ddf9e03eefa85495ab5463e0a000240587"))
      )
#+end_src
** Scripts WIP
TODO Are the double-quotes I have around --expression args okay?
#+begin_src sh :var os_name="" os_dir=(meta-get-dir)
sudo guix time-machine \
	--channels="$os_dir"/$os_name-channels-lock \
	-- \
	system \
	--load-path=. \
	--expression="(@ (exuberant os $os_name) os)" \
	reconfigure
#+end_src

#+begin_src sh :var he_name="" he_dir=(meta-get-dir)
guix pull --channels="$he_dir"/$he_name-channels-lock
#+end_src
#+begin_src sh :var he_name=""
guix home \
	--load-path=. \
	--expression="(@ (exuberant he $he_name) he)" \
	reconfigure
#+end_src

#+begin_src sh :var name="" dir=""
guix time-machine \
	--channels="$dir"/$name-channels \
	-- \
	describe --format=channels > "$dir"/$name-channels-lock
#+end_src
* Channel
#+begin_src scheme :tangle (meta-in-dir ".guix-channel")
(channel
 (version 0)
 (dependencies
  (channel
   (name flat)
   (url "https://github.com/flatwhatson/guix-channel.git")
   (introduction
    (make-channel-introduction
     "33f86a4b48205c0dc19d7c036c85393f0766f806"
     (openpgp-fingerprint
      "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490"))))
  (channel
   (name rde)
   (url "https://git.sr.ht/~abcdw/rde")
   (introduction
    (make-channel-introduction
     "257cebd587b66e4d865b3537a9a88cccd7107c95"
     (openpgp-fingerprint
      "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
  (channel
   (name nonguix)
   (url "https://gitlab.com/nonguix/nonguix")
   (introduction
    (make-channel-introduction
     "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
     (openpgp-fingerprint
      "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))))
#+end_src
* Dev
** Git config
#+begin_src gitconfig :tangle (meta-in-dir ".git/config")
[branch "master"]
	remote = origin
	merge = refs/heads/master

[branch "tangled"]
	remote = origin
	merge = refs/heads/tangled
#+end_src
** Git ignore
- TODO maybe make this a =,*= with excludes later

#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
/.gitignore
# TODO temporary
/.guix-channel
ebullient/
penitent/
exuberant/
README.org
LICENSE

# TODO from old phrenetic Dev > Git ignore
# # REVIEW I might want to have the res files (e.g. =alucard_bg.png=) placed closer to where they're used. Don't worry about this right now, gitignores are a pain and they've been changing frequently as I rewrite stuff.
# #+begin_src gitignore :tangle (meta-in-dir ".gitignore")
# /*
# !res/
# #+end_src
#+end_src
** Github
*** Git config
#+begin_src gitconfig :tangle (meta-in-dir ".git/config")
[remote "origin"]
	url = https://github.com/pharcosyle/phrenetic.git
	fetch = +refs/heads/*:refs/remotes/origin/*
#+end_src
*** Readme
#+begin_src org :tangle (meta-in-dir "README.org")
,* Phrenetic
A configuration framework and collection of useful packages/services for [[https://guix.gnu.org/][GNU Guix]].

It's decent.
,* [[file:phrenetic.org][Browse the full source]]
,* Usage
Install as a [[https://guix.gnu.org/manual/devel/en/guix.html#Channels][Guix channel]] with the following declaration:
,#+begin_src scheme
(channel
 (name 'phrenetic)
 (url "https://github.com/pharcosyle/phrenetic")
 (branch "tangled"))
,#+end_src
,* Noteworthy features
Some stuff I haven't seen elsewhere folks might be interested in:
- Stateless service :: Configure your Guix to run with an ephemeral, in-memory root directory. Kind of like [[https://grahamc.com/blog/erase-your-darlings][Erase your darlings: immutable infrastructure for mutable systems]] but using Guix/Btrfs instead of NixOS/ZFS.
- Doom package and module :: [[https://github.com/doomemacs/doomemacs][Doom Emacs]] packaged for Guix and with patches to better organize Emacs state, a service to set up symlinks, etc.
- Guix integration for [[https://github.com/radian-software/straight.el][Straight.el]] :: Your Straight or Doom-based Emacs configuration can use Guix Emacs packages under hood (but with the revisions you, or Doom, specify). Get the best of both worlds! Still WIP.
- Miscellaneous packages :: Guix packages for stuff not upstream yet: Datomic CLI tools, the AWS CLI v2, etc.
,* A word about literate programming
I use Emacs' =org-mode= to structure my code as a single file that I can export ("tangle") into numerous source files. This allows me to annotate and organize related code in potentially different languages with different output paths together in a way that easy for humans to read and reason about. This does necessitate maintaining a separate =tangled= branch (set as the Github default) so others can use it easily, though.
,* Contributing
Pull requests welcome! Targeting =master= is ideal but if you aren't familiar with literate programming / Emacs / =org=mode= then making your changes on the =tangled= branch is also fine (I'll reverse-tangle it for you).
,* Acknowledgements
This project incorporates code from Andrew Tropin's excellent [[https://github.com/abcdw/rde][RDE]], many thanks to him.
#+end_src
*** License
#+begin_src fundamental :tangle (meta-in-dir "LICENSE")
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
#+end_src
* Dev local
** Git config
- REVIEW I may want to pull this out for reuse across all my projects since this bit of git config will always be the same (on a Guix system that is, so ideally have multiple default git configs per-OS and select the right one dynamically when tangling)
#+begin_src gitconfig :tangle (meta-in-dir ".git/config")
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
#+end_src
** Emacs directory-local variables
- TODO Causes gesier to fail to load outside of this directory
  *don't do this until I figure out how I'm doing per-project Emcas config* I might not end up doing Geiser setup this way at all
  Since the ~with-eval-after-load~ body will get called wherever geiser-guile is first loaded, if the geiser library isn't loaded yet and I e.g. visit a file in this directory, then leave, then try to =M-x guix p e= while I'm viewing a file elsewhere it'll fail to run since it loads geiser internally and can't find a dominating .dir-locals.
  - an alternative approach to setting up geiser for a project: [[https://github.com/guix-mirror/guix/blob/master/.dir-locals.el#L21][guix/.dir-locals.el at master  guix-mirror/guix  GitHub]]
    Maybe try that or something like it.
    - here's where I got the original approach, for reference: [[https://github.com/flatwhatson/flycheck-guile#troubleshooting][GitHub - flatwhatson/flycheck-guile: A Flycheck checker for GNU Guile]]
  - update [2022-03-26 Sat]: this won't work as-is any more
    I have multiple directories to load (ebullient, exuberant...)
#+begin_src elisp :tangle (meta-in-dir ".dir-locals.el")
((nil
  (eval . (with-eval-after-load 'geiser-guile
            (let ((root-dir
                   (file-name-directory
                    (locate-dominating-file default-directory ".dir-locals.el"))))
              (make-local-variable 'geiser-guile-load-path)
              (add-to-list 'geiser-guile-load-path root-dir))))))
#+end_src

#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
/.dir-locals.el
#+end_src
